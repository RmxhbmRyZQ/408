# 计算机组成原理

* [第一章 计算机系统概述](#计算机系统概述)
* [第二章 数据的表示和运算](#数据的表示和运算)
* [第三章 存储系统](#存储系统)
* [第四章 指令系统](#指令系统)
* [第五章 中央处理器](#中央处理器)
* [第六章 总线](#总线)
* [第七章 输入输出系统](#输入输出系统)

# 计算机系统概述

## 计算机发展历程*

### 计算机硬件的发展

#### 计算机的四代变化

从 1946 年世界上第一台电子数字计算机（Electronic Numerical Integrator And Computer，`ENIAC`）问世以来，计算机的发展已经经历了四代

1. 第一代计算机（1946—1957年）电子管时代，特点：
   1. 逻辑元件采用**电子管**
   2. 使用**机器语言**进行编程
   3. 主存用延迟线或磁鼓存储信息，**容量极小**
   4. 体积庞大，成本高
   5. **运算速度较低**，一般只有几千次到几万次每秒
2. 第二代计算机（1958—1964年）晶体管时代，特点：
   1. 逻辑元件采用**晶体管**
   2. 运算速度提高到几万次到几十万次每秒
   3. 主存使用磁心存储器
   4. 软件**开始使用高级语言**，如 FORTRAN，有了操作系统的雏形
3. 第三代计算机（1965—1971年）中小规模集成电路时代，特点：
   1. 逻辑元件采用**中小规模集成电路**
   2. **半导体存储器**开始取代磁心存储器
   3. **高级语言发展迅速**，操作系统也进一步发展，开始有了分时操作系统
4. 第四代计算机（1972年至今）超大规模集成电路时代，特点：
   1. 逻辑元件采用**大规模集成电路和超大规模集成电路**，产生了**微处理器**
   2. 诸如并行、流水线、高速缓存和虚拟存储器等概念用在了这代计算机中

#### 计算机元件的更新换代

1. 摩尔定律：当价格不变时，集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍

2. 半导体存储器的发展：

   1970 年，仙童半导体公司生产出第一个较大容量的半导体存储器，至今，半导体存储器经历了11 代：

   单芯片 `1KB、4KB、16KB、64KB、256KB、1MB、4MB、16MB、64MB、256MB` 和现在的 `1GB`

3. 微处理器的发展：

   自1971年Intel公司开发出第一个微处理器Intel 4004 至今，微处理器经历了 Intel 8008 （8位）、Intel 8080 （8位）、Intel 8086 （16位）、Intel 8088 （16位）、Intel 80286 （16位）、Intel 80386 （32位）、Intel 80486 （32位）、Pentium （32位）、Pentium pro （64位）、Pentium II （64 位）、Pentium II （64位）、Pentium 4 （64位）等

   这里的 32 位、64 位指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数

### 计算机软件的发展

计算机软件技术的蓬勃发展，也为计算机系统的发展做出了很大的贡献

计算机语言的发展经历了**面向机器的机器语言和汇编语言**、**面向问题的高级语言**

其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的 FORTRAN、结构化程序设计的 PASCAL 到面向对象的 C++ 和适应网络环境的 Java

直接影响计算机系统性能提升的各种系统软件也有了长足的发展，特别是操作系统，如 Windows、UNIX、Linux 等

选择题：把汇编语言源程序转变为机械语言程序的过程是汇编

### 计算机的分类与发展方向

电子计算机可分为电子模拟计算机和电子数字计算机

数字计算机又可按用途分为**专用计算机**和**通用计算机**。这是根据计算机的效率、速度及运行的经济性和适应性来划分的

通用计算机又分为巨型机、大型机、中型机、小型机、微型机和单片机 6 类，它们的体积、功耗、性能、数据存储量、指令系统的复杂程度和价格依次递减

此外，计算机按指令和数据流还可分为：

1. 单指令流和单数据流系统（`SISD`），即传统**冯·诺依曼**体系结构
2. 单指令流和多数据流系统（`SIMD`），包括阵列处理器和向量处理器系统
3. 多指令流和单数据流系统（`MISD`），这种计算机实际上不存在
4. 多指令流和多数据流系统（`MIMD`），包括**多处理器和多计算机**系统

计算机的发展趋势正向着两极分化：

1. 是微型计算机向更微型化、网络化、高效能、多用途方向发展
2. 是巨型机向更巨型化、超高速、并行处理、智能化方向发展

## 计算机系统层次结构

### 计算机系统的组成

**硬件系统和软件系统共同构成了一个<u>完整的计算机系统</u>**

硬件即物理设备；软件是在硬件上运行的程序和相关的数据及文档

计算机系统性能的好坏，很大程度上是由**软件的效率和作用来表征的**（软件的运行情况），而软件性能的发挥又离不开硬件的支持、对某一功能来说，其**既可以用软件实现，又可以用硬件实现**，则称为软硬件在**逻辑上是等效的**

在设计计算机系统时，要进行软/硬件的功能分配。一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。而用软件实现可以提高灵活性，但效率往往不如硬件实现高

### 计算机硬件的基本组成

#### 早期的冯 · 诺依曼机

冯 · 诺依曼在研究 `EDVAC` 机时提出了存储程序的概念，存储程序的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯 · 诺依曼机，其特点如下：

1. 计算机硬件系统由**运算器、存储器、控制器、输入设备、输出设备** 5 大部件组成
2. **指令和数据以同等地位存储在存储器中**，并可按地址寻访
3. 指令和数据**均用二进制代码表示**
4. 指令由**操作码和地址码**组成，操作码指出操作的类型，地址码指出操作数的地址
5. 指令在存储器内按顺序存放。指令是**顺序执行**的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序
6. 早期的冯 · 诺依曼机以**运算器为中心**，输入/输出设备通过运算器与存储器传送数据

注意：存储程序的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束

选择题：冯 · 诺依曼机最根本的特征是采用存储程序原理，基本工作方式是**控制流驱动方式**

选择题：冯 · 诺依曼机中指令和数据均以二进制形式存放在存储器中，CPU 区分它们的依据是**指令周期的不同阶段**，取值阶段取指令，执行阶段取数据

#### 现代计算机的组织结构*

在微处理器问世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递

大量 I/O 设备的速度太慢，因此以运算器为中心的结构不能够满足计算机发展的要求

**现代计算机已发展为以存储器为中心**，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率

目前绝大多数现代计算机仍遵循冯 · 诺依曼的存储程序的设计思想

#### 计算机的功能部件

传统冯·诺依曼计算机和现代计算机的结构虽然有所不同，但**功能部件是一致的**

##### 输入设备

输入设备的主要功能是<u>将程序和数据以机器所能识别和接受的形式输入计算机</u>
最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等

##### 输出设备

输出设备的任务是将计算机处理的结果**以人们所能接受的形式**或其他系统所要求的信息形式**输出**

最常用、最基本的输出设备是显示器、打印机。计算机的输入/输出设备（简称 I/O 设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分

##### 存储器

**存储器是计算机的存储部件，用来存放程序和数据**

存储器分为主存储器（简称主存，也称内存储器）和辅助存储器（简称辅存，也称外存储器）

CPU 能够**直接访问的主存储器**。辅助存储器用于**记忆更多的信息**，辅助存储器中必须调入主存后，才能为CPU 所访问

主存储器是**按存储单元的地址进行存取**，这种存取方式称为按地址存取方式（**相联存储器也可以按内容访问的**）

主存储器由四个部分组成：

1. **存储体存放二进制信息**，由存储单元组成，存储单元由存储元件组成，每个存储元件存储一位的二进制代码

   **存储单元的的长度称为存储字**，存储字长是字节的偶数倍

2. 地址寄存器（MAR）**存放访存地址**，经过地址译码后找到所选的存储单元

   其位数对于着存储单元的个数，**MAR 的长度与 PC 寄存器的长度相等**

3. 数据寄存器（MDR）用于**暂存要从存储器中读或写的信息**，一般**与存储字长相等**

4. 时序控制逻辑用于产生存储器操作所需的各种时序信号（表示是读还是写操作）

注意：MAR 与 MDR 虽然是存储器的一部分，但在现代 CPU 中却是存在于 CPU 中的；另外，后文提到的高速缓存（Cache）也存在于 CPU 中

##### 运算器

运算器是计算机的执行部件，用于进行**算术运算和逻辑运算**

1. 算术运算是按算术运算规则进行的运算，如加、减、乘、除
2. 逻辑运算包括与、或、非、异或、比较、移位等运算

**运算器的核心是算术逻辑单元** （Arithmetic and Logical Unit，ALU）

运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（`ACC`）、乘商寄存器（`MQ`）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前 3 个寄存器是必须具备的

运算器内还有程序**状态寄存器**（`PSW`），也称标志寄存器，用于存放 ALU 运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等

##### 控制器

控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作

控制器由程序计数器（PC）、指令寄存器（IR）和控制单元（CU）组成

- PC 用来**存放当前欲执行指令的地址**，可以**自动加 1** 以形成下一条指令的地址，它**与主存的 MAR 之间有一条直接通路**
- IR 用来**存放当前的指令**，其<u>内容来自主存的 MDR</u>
- 指令中的**操作码 OP(IR) 送至 CU**，用以**分析指令**并发出各种微操作命令序列
- 而**地址码 Ad(IR) 送往 MAR**，用以**取操作数**

一般将运算器和控制器集成到同一个芯片上，称为中央处理器（CPU），**CPU 和主存储器共同构成主机**，而除主机外的其他硬件装置（外存、I/O 设备等）统称为外部设备，简称外设

CPU 包含 ALU、通用寄存器组 `GPRs`、标志寄存器、控制器、指令寄存器 IR、程序计数器 PC、存储器地址寄存器 MAR 和存储器数据寄存器 MDR

图中从控制器送出的虚线就是控制信号：

1. 控制如何修改 PC 以得到下一条指令的地址
2. 控制 ALU 执行什么运算
3. 控制主存是进行读操作还是写操作（读/写控制信号）

![image-20211002131847132](..\images\image-20211002131847132.png)

CPU 和主存之间通过一组总线相连，总线中有地址、控制和数据 3 组信号线

MAR 中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元

控制线中有读/写信号线，指出数据是从 MDR 写入主存，还是主存读入 MDR

### 计算机软件的分类

#### 系统软件和应用软件

系统软件是一组保证计算机系统高效、正确运行的基础软件，通常**作为系统资源提供给用户使用**。系统软件主要有操作系统（OS)、数据库管理系统（DBMS)、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等

应用软件是指用户为**解决某个应用领域中的各类问题而编制的程序**，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等

简单来说就是，系统软件提供接口，而应用软件是功能的实现

#### 三个级别的语言

1. 机器语言：又称二进制代码语言，机器语言是计算机**唯一可以直接识别和执行的语言**
2. 汇编语言：汇编语言用英文单词或其缩写代替二进制的指令代码，使用汇编语言编辑的程序，**必须经过汇编程序的系统软件的翻译**，转换为机器语言后，才能在计算机的硬件系统上执行
3. 高级语言：高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言**需要经过编译程序编译成汇编语言程序**，然后经过**汇编操作得到机器语言程序**，或**直接由高级语言程序翻译成机器语言程序**

将非机械语言翻译成机械语言的软件系统称为翻译程序，分为：汇编程序，汇编器；解释程序，解释器；编译程序，编译器

#### 软件和硬件的逻辑功能等价性

对某一功能来说，既可以由硬件实现，又可以由软件实现，它们在功能上是等价的

这一等价性被称为软、硬件逻辑功能的等价性（时间不等价）

软件和硬件逻辑功能的等价性是计算机系统设计的重要依据

当研制一台计算机时，设计者必须明确分配每一级的任务，确定哪些功能使用硬件实现，哪些功能使用软件实现

软件和硬件功能界面的划分是由设计目标、性能价格比、技术水平等综合因素决足的

### 计算机工作步骤

计算机的工作过程分为以下三个步骤：

1. 把源程序和数据装入主存储器
2. 将源程序转换成可执行文件
3. 从可执行文件的首地址开始逐条执行指令

#### 从源程序到可执行程序

C 语言程序都必须被**转换为一系列的低级机器指令**，这些指令按照一种称为**可执行目标文件的格式打好包**，并以**二进制磁盘文件的形式存放起来**

以 UNIX 系统中的 GCC 编译器程序为例，翻译源程序文件 `hello.c` 的整个翻译过程可分为4个阶段完成：

1. 预处理阶段：对**预处理语句**（以 # 开头）进行编译，输出结果是一个以 .i 为扩展名的源文件 `hello.i`
2. 编译阶段：编译器（`ccl`）**生成一个汇编语言源程序** `hello.s`
3. 汇编阶段：汇编器（as）将 `hello.s` **翻译成机器语言指令**，打包成一个称为可重定位目标文件的 `hello.o`
4. 链接阶段：链接器（`ld`）**将多个可重定位目标文件**和标准库函数**合并为一个可执行目标文件**，或简称可执行文件

选择题：硬件描述语言程序是一种描述电路的代码，计算机不可直接执行

#### 程序执行过糕的措述

1. shell 程序将用户从键盘输入的字符逐一读入 CPU 寄存器，然后保存到主存储器中，在主存的缓冲区形成字符串 “./hello”
2. 接收到 Enter 键时，shell 调出操作系统的内核程序，由内核来加载磁盘上的可执行文件 hello 到主存中
3. 内核加载完可执行文件中的代码和数据后，将 hello 的第一条指令的地址送至 PC，CPU 随后开始执行 hello 程序
4. 将已加载到主存的字符串 “hello world!” 从主存取到 CPU 的寄存器中，然后将 CPU 寄存器中的字符送到显示器

<u>程序的执行过程就是数据在 CPU、主存储器和 I/O 设备之间流动的过程，所有数据的流动都是通过总线、I/O 接口等进行的</u>

#### 指令执行过程的描述

PC 寄存器存放第一条指令位置，根据 PC 取出第一条指令，经过译码、执行步骤等，控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址，用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止

下面以取数指令为例进行说明，其信息流程如下：

1. **取指令**：(PC)→MAR→M→MDR→IR 根据 PC 取指令到 IR
   1. 将 PC 的内容送 MAR
   2. MAR 中的内容直接送地址线
   3. 控制器将读信号送读/写信号线
   4. 主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上
   5. MDR 从数据线接收指令信息，并传送到 IR 中
2. **分析指令**：OP(IR)→CU 指令译码并送出控制信号
   - 控制器根据 IR 中指令的操作码，生成相应的控制信号，送到不同的执行部件
   - 这里是取数指令，因此读控制信号被送到总线的控制线上
3. **执行指令**：Ad(IR)→MAR→M→MDR→ACC 取数操作
   1. 将 IR 中指令的地址码送 MAR，MAR 中的内容送地址线
   2. 控制器将读信号送读/写信号线，从主存指定存储单元读出操作数
   3. 通过数据线送至 MDR 再传送到 ACC 中
   4. 取完一条指令，还须为取下一条指令做准备，形成下一条指令的地址，即 (PC) + 1→PC

### 计算机系统的多级层次结构

**现代计算机是一个硬件与软件组成的综合体**。由于计算机越来越复杂，所以使用分层模式把整个领域，分成多个层次，让负责每个层次的人仅需关心自己负责的区域，而不需要关心下层的实现，以便构成合理、高效的计算机系统

1. 第 1 级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令（即一个指令执行的每个过程）
2. 第 2 级是传统机器语言层，它也是一个实际的机器层，·由微程序解释机器指令系统
3. 第 3 级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层
4. 第 4 级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序，这一层由汇编程序支持和执行
5. 第 5 级是高级语言层，它是面向用户的，是为方便用户编写应用程序而设置的，该层由各种高级语言编译程序支持和执行

在**高级语言层之上，还可以有应用程序层**，它由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件等

**把没有配备软件的纯硬件系统称为裸机**。第 3 层～第 5 层称为虚拟机，简单来说就是软件实现的机器。虚拟机只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层次的语言来了解和使用计算机，而不必关心下层是如何工作的

层次之间的关系紧密，**下层是上层的基础，上层是下层的扩展**。随着超大规模集成电路技术的不断发展，**部分软件功能将由硬件来实现**，因而软/硬件交界面的划分也不是绝对的

## 计算机性能的指标

### 计算机的主要性能指标

#### 机械字长

机器字长是指计算机**进行一次整数运算所能处理的二进制数据的位数**，通常与 CPU 的寄存器位数、加法器有关

**机器字长一般等于内部寄存器的大小**，字长越长，数的表示范围越大，计算精度越高

计算机字长通常选定为字节（8位）的整数倍

#### 数据通路带宽

数据通路带宽是指**数据总线一次所能并行传送信息的位数**

数据通路宽度是指**外部数据总线的宽度**，它与 CPU 内部的数据总线宽度有可能不同

注意：各个子系统通过数据总线连接形成的数据传送路径称为数据通路

#### 主存容量

主存容量是指**主存储器所能存储信息的最大容量**，通常以字节来衡量，也可用字数 × 字长（如 `512K×16` 位）来表示存储容量

其中，MDR 的位数反映存储单元的位数，MAR 的位数反映可寻址范围的最大值（而不一定是实际存储器的存储容量）

例如，MAR 为 16 位，表示 $2^{16}= 65536$，即此存储体内有 65536 个存储单元；若 MDR 为 32 位，表示每次取 32 位的数据，存储容量写作 `64K×32` 位

#### 运算速度

##### 吞吐量和响应时间

- 吞吐量：指**系统在单位时间内处理请求的数量**

  它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备

  几乎每步都关系到主存，因此**系统吞吐量主要取决于主存的存取周期**

- 响应时间：指从<u>用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间</u>

  通常包括 CPU 时间（执行时间）与等待时间（I/O 时间）

##### 主频和 CPU 时钟周期

- 主频（CPU 时钟频率）：**机器内部主时钟的频率**，是衡量机器速度的重要参数

  对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快

- CPU 时钟周期：通常为节拍脉冲或 T 周期，即**主频的倒数**，它是 CPU 中**最小的时间单位**，执行指令的每个动作至少需要 1 个时钟周期

##### CPI 指令执行周期

CPI（Clock cycle Per Instruction）：即执行**一条指令所需的时钟周期数**

不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其 CPI  指该程序或该机器指令集中的**所有指令执行所需的平均时钟周期数**，此时 CPI 是一个平均值

##### CPU 执行时间

CPU 执行时间：指**运行一个程序所花费的时间**

CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 × CPI) / 主频

CPU 执行时间取决于三个要素：

1. 主频（时钟频率）
2. 每条指令执行所用的时钟周期数（CPI）
3. 指令条数

主频、CPI 和指令条数是相互制约的，**更改指令集可以减少程序所含指令的条数**，但同时可能引起 CPU 结构的调整，从而**可能会增加时钟周期的宽度**（降低主频）

选择题：CPU 的 CPI 与时钟频率无关，因为时钟频率的变化并不会影响 CPI

##### MIPS

MIPS（Million Instructions Per Second），即**每秒执行多少百万条指令**

MIPS = 指令条数 / (执行时间 × $10^6$)=主频 / (CPI × $10^6$)

MIPS 对不同机器进行性能比较是有缺陷的，因为在机器 `M1` 上某条指令的功能，在机器 `M2` 上要用多条指令来完成

<u>不同机器的 CPI 和时钟周期也不同，因而同一条指令在不同机器上所用的时间也不同</u>

##### 浮点数指标

- `MFLOPS`（Mega Floating-point Operations Per Second），即每秒执行多少百万次浮点运算
- `GFLOPS`（Giga Floating-point Operations Per Second），即每秒执行多少十亿次浮点运算
- `TFLOPS`（Tera Floating-point Operations Per Second），即每秒执行多少万亿次浮点运算
- `PFLOPS` = 浮点操作次数（执行时间×$10^{15}$）
- `EFLOPS` = 浮点操作次数（执行时间×$10^{18}$）
- `ZFLOPS` = 浮点操作次数（执行时间×$10^{21}$）

注意：在描述存储容量、文件大小等时，K、M、G、T 通常用 2 的幂次表示，如 $1Kb =2^{10}b$；在描述速率、频率等时，k、M、G、T 通常用 10 的幂次表示，如 $1kb/s = 10^3b/s$

选择题：在用于**科学**计算的计算机中，标志系统性能的最有用的参数是浮点数计算的效率

#### 基准程序

基准程序（Benchmarks）是**通过运行时间来评价性能的一组程序**，能够很好反映机器在运行实际负载时的性能

但有些机器在硬件上仅优化了基准程序使用的指令，导致基准程序运行得很快，得不到准确的性能评测结果

### 几个专业术语

1. 系列机：具有**基本相同的体系结构**，使用**相同基本指令系统**的多个**不同型号**的计算机组成的一个产品系列
2. 兼容：指**计算机软件或硬件的通用性**，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性，如 32 位的软件能在 64 位中运行
3. 软件可移植性：指把使用在**某个系列计算机中的软件**直接或进行很少的修改就能**运行在另一个系列计算机中的可能性**
4. 固件：**将程序固定在 ROM 中组成的部件称为固件**。固件是一种具有软件特性的硬件，固件的性能指标介于硬件与软件之间，吸收了软/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物

## 常见问题和易混淆知识点

1. 同一个功能既可以由软件实现又可以由硬件实现吗？

   在逻辑功能上，软件和硬件是等效的。许多功能**既可以由硬件直接实现，又可以在硬件的配合下由软件实现**

   乘法运算既可用专门的乘法器实现，硬件电路；也可用乘法子程序来实现，多个加法指令

2. 翻译程序、汇编程序、编译程序、解释程序的区别和联系是什么？

   翻译程序是指把高级语言源程序翻译成机器语言程序的软件，翻译程序有两种：

   1. 编译程序：它将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序
   2. 解释程序：它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，不会生成目标程序

   汇编程序也是一种语言翻译程序，它**把汇编语言源程序翻译为机器语言程序**，汇编语言与机器语言一一对应

   编译程序与汇编程序的区别：

   若源语言是高级语言，而目标语言是汇编语言或机器语言之类的低级语言，则这样的一个翻译程序称为编译程序

   若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序

3. 什么是透明性？透明是指什么都能看见吗？

   在计算机领域中，站在某类用户的角度，若**感觉不到某个事物或属性的存在**，则称某个事物或属性是**透明的**

   如在 CPU 中，IR、MAR 和 MDR 对各类程序员都是透明的

4. 机器字长、指令字长、存储字长的区别和联系是什么？

   - 机器字长：计算机**能直接处理的二进制数据的位数**，机器字长一般等于**内部寄存器的大小**，它**决定了计算机的运算精度**
   - 指令字长：一个**指令字中**包含的**二进制代码的位数**
   - 存储字长：一个**存储单元**存储的**二进制代码的长度**

   一般指令字长取**存储字长的整数倍**，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取指周期为机器周期的 2 倍

   早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据

   随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍

   注意：<u>机器字长、指令字长和存储字长，三者在数值上可以相等也可以不等，视不同机器而定</u>

5. 计算机体系结构和计算机组成的区别和联系是什么？

   **计算机体系结构**是指**机器语言或汇编语言程序员所看得到的传统机器的属性**，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性（接口）

   **计算机组成**是指**如何实现计算机体系结构所体现的属性**，它包含对许多对程序员来说透明的取指、分析指令的硬件细节

   许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大

6. 基准程序执行得越快说明机器的性能越好吗？

   一般情况下，基准测试程序能够反映机器性能的好坏

   但是，由于基准程序中的语句存在频度的差异，因此**运行结果并不能完全说明问题**

# 数据的表示和运算

## 数制与编码

### 进位计数制及其相互转换

计算机内部使用二进制的原因如下：

1. 使用有两个稳定状态的物理器件就可以二进制两种状态，**制造成本比较低**
2. 二进制位 1 和 0 正好与逻辑值“真”和“假”对应，为实现逻辑运算和程序中的逻辑判断提供了便利条件
3. 二进制的**编码和运算规则都很简单**，通过逻辑门电路能**方便地实现算术运算**

#### 进位计数法

十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数

在进位计数法中，**每个数位所用到的不同数码的个数称为基数**，如十进制的基数为 10（0~9）

一个 r 进制数（$K_n\cdots K_0K_{-1}\cdots K_{-m}$）的数值可表示为 $\displaystyle\sum^{-m}_{i=n}K_ir^i$ 其中 r 是基数；$r^i$ 是第 i 位的位权，整数位的最低位规定为第 0 位；$K_i$ 的取值范围是 $0 \sim r - 1$ 共 r 个数码中的任意一个

1. 二进制：计算机中用得最多的是基数为 2 的计数制，二进制只有 0 和 1 两种数字符号，计数逢二进一
2. 八进制：基数为 8，有 0~7 共 8 个不同的数字符号，计数逢八进一
3. 十六进制：基数为16，逢十六进个数位可取 0～9、A、B、C、D、E、F 中的任意一个，其中 A～F 分别表示10～15

#### 不同进制数之间的相互转换

##### 二进制转八和十六进制

转八进制：小数点分开， 3 个二进制一组，不够加零，转完后再和起来

![image-20211003233537657](..\images\image-20211003233537657.png)

转十六进制差不多，4 个一组

![image-20211003233608718](..\images\image-20211003233608718.png)

##### 任意进制转十进制

将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数

如，$(11011.1)_2=1\times 2^4+1\times2^3+0\times2^2+1\times2^1+1\times2^0+1\times2^{-1}=27.5$

##### 十进制转任意进制

这里需要对整数部分和小数部分分开转换，使用除基取余法转换整数部分，使用乘基取整法转换小数部分

使用 123.6875 作为例子转换为 2 进制

除基取余法：`123 = 0b1111011`

![image-20211003234346692](..\images\image-20211003234346692.png)

乘基取整法：`0.6875= 0b0.1011`

![image-20211003234403924](..\images\image-20211003234403924.png)

因此 `123.6875 = 0b1111011.1011`

注意：在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并**不是每个十进制小数都可以准确地用二进制表示**

注意：关于十进制数转换为任意进制数为何采用除基取余法和乘基取整法，以及所取之数放置位置的原理，请结合 r 进制数的数值表示公式思考，而不应死记硬背

### 真值和机械数

这种**带“+”或“-”符号的数称为真值**，真值是机器数所代表的实际值

通常采用数的符号和数值一起编码的方法来表示数据，通常用 0 表示正，用 1 表示负

如 0101 是 +5，这种把**符号“数字化”的数称为机器数**

### BCD 码*

二进制编码的十进制数（Binary-Coded Decimal,BCD）通常采用 4 位二进制数来表示一位十进制数中的0～9这10 个数码

1. 8421 码（最常用）：是一种有权码，它表示的十进制数是 $D = 8b_3+4b_2+2b_1+1b_0$

   如 9 $\to$ 1001，再相加时大于 9 需要再加 6 来进行修正，并向高位进位，然后查看高位是否要修正

   ![image-20211004104324123](..\images\image-20211004104324123.png)

2. 余 3 码：是一种无权码，是在 8421 码的基础上加 3 形成的

3. 2421 码：是一种有权码，它表示的十进制是 $D = 2b_3+4b_2+2b_1+1b_0$，特点是大于等于 5 的 4 位二进制中最高位为 1，小于 5 的最高位为 0，如 5 $\to$ 1011

### 字符与字符串*

#### 字符编码 ASCII 码

ASCII 码是 7 位二进制编码，每个字节的最高位为 0，包含 10 个数字 52 个英文字母，和一些符号共 128 个字符

在 ASCII 码中，编码值 0～31 为控制字符，用于通信控制或设备的功能控制；编码值 127 是 DEL 码；编码值 32 是空格SP；编码值32～126共95个字符称为可印刷字符

注意：`0x30` 是 0，`0x20` 是空格，`0x41` 是 A，`0x61` 是 a

#### 汉字的表示和编码

汉字的编码包括汉字的**输入编码、汉字内码、汉字字形码**三种，它们是计算机中用于输入、内部处理和输出三种用途的编码

区位码用两字节表示一个汉字，每字节用七位码，区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码

国标码将十进制的区位码转换为十六进制数后，再在每字节上加上 `20H`，**国标码和区位码都是输入码**

汉字和图形符号排列在一个 94 行 94 列的二维代码表中（汉字字形码）

为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改为 1，这就是汉字内码

### 校验码*

由**若干位代码组成的一个字叫码字**，将两个码字逐位进行对比，具有**不同的位的个数称为两个码字间的距离**

- 由若干 0 和 1 构成的叫码字，1001 和 0100 的码距为三，因为 134 位不同

一种编码方案可能有若干个合法码字，**各合法码字间的<u>最小</u>距离称为码距**

码距不小于 2 的数据校验码，开始具有检错的能力；码距大于等于 3 时可能有纠错能力

校验码是指能够**发现**或能够**自动纠正错误的数据编码**，也称检错纠错编码

校验码的原理是通过增加一些冗余码，通过增加码距的方法来检验或纠错编码

#### 奇偶校验码

在原编码上加一个校验位，它的码距等于 2，<u>可以检测出奇数位错误，但不能确定出错的位置，也不能够检测出偶数位错误</u>，增加的冗余位称为奇偶校验位

奇偶校验实现的方法：由若干位有效信息再加上一个二进制位（校验位）组成校验码，校验位的取值（0 或 1）将**使整个校验码中 1 的个数为奇数或偶数**，所以有两种可供选择的校验规律：

1. 奇校验码：整个校验码（有效信息位和校验位）中 **1 的个数为奇数**
2. 偶校验码：整个校验码（有效信息位和校验位）中 **1 的个数为偶数**

如 10101 他有奇数个 1 也就足够了，所以奇校验码为 0；但要令 1 的个数为偶数个还差一点，所以偶校验码为 1

#### 海明校验码

海明码（Hamming Code，也译为汉明码）是广泛采用的一种有效的校验码

实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中

当某一位出错后，就会引起有关的几个校验位的值发生变化，这**不但可以发现错位，还能指出错位的位置**

根据纠错理论得 L - 1 = D + C 且 $D\geq C$ 即编码最小码距 L 越大，其检测错误的位数 D 越大，纠正错误的位数 C 也越大

下面用一个例子来介绍求海明码的步骤，求 1010：

1. 确定海明码的位数：

   设 n 为有效信息的位数，k 为校验位的位数，则有**关系 n + k ≤ $2^k$ - 1**，若要检测两位错，则需再增加 1 位校验位

   海明码位数为 $n + k = 7<2^3- 1$ 成立，则信息位为 $D_4D_3D_2D_1$（1010）；校验位为 $P_3P_2P_1$，海明码为 $H_7\sim H_1$

2. 确定校验码的分布：**校验码 $P_i$ 在海明位号为 $2^{i-1}$ 位置上**，$P_1P_2P_3$ 的位号为 $H_1H_2H_4$ 其余的是信息位

   在 $H_7H_6H_5H_4H_3H_2H_1$ 的数据是 $D_4D_3D_2P_3D_1P_2P_1$

3. 分组以形成校验关系：**把信息位的海明位号化成二进制**

   如 $D_4$ 在 $H_7$ 上，二进制为 `0b111`，$D_3$=`0b110`，$D_2$=`0b101`，$D_1$=`0b11`

4. 校验位取值：**$P_i$ 是第 3 步得到的二进制的第 i 位为 1 的信息位的异或**

   第 3 步得到的二进制的第 1 位为 1 的是 $D_1D_2D_4$ 所以 $P_1=D_1\bigoplus D_2\bigoplus D_4=0$

   同理 $P_2=D_1\bigoplus D_3 \bigoplus D_4=1$，$P_3=D_2\bigoplus D_3\bigoplus D_4=0$

   所以 1010 对应的海明码为 101<u>0</u>0<u>10</u> 下划线为校验位

5. 海明码的验证原理：

   把每个检验位和参与生成该校验位的信息位进行异或，构成 k 个校验方程

   <img src="..\images\image-20211006215718417.png" alt="image-20211006215718417" style="zoom:150%;" />

   若 $S_3S_2S_1$ 的值位 000，则无错；否则这个数就是错误位的位号，**如 $S_3S_2S_1=001$ 说明 $H_1$ 出错了**

#### 循环冗余校验码（CRC）

CRC 的基本思想是：**在 K 位信息码后再拼接 R 位的校验码**，整个编码的长度为 N 位，因此，这种编码又称（N, K）码

CRC 码基于线性编码理论，在发送端，将要传送的 K 位二进制信息码左移 R 位，将它**与生成多项式 G(x) 做模 2 除法**，生成一个 R 位校验码，并附在信息码后，构成一个新的二进制码（CRC 码)，共 K + R 位

在接收端，利用生成多项式对接收到的编码做模 2 除法，以检测和确定出错的位置，如整除则无错，其中生成多项式是接收端和发送端的一个约定

任意一个二进制数码都可用一个系数仅为 0 或 1 的多项式与其对应，生成多项式 G(x) 的最高幂次为 R，转换成对应的二进制数有 R + 1 位

选择题：在**大量数据**传送过程中，常用且有效的校验方法是 CRC

##### 模 2 除法

1. 用除数对被除数最高几位做异或
2. 除数向右移一位，若余数最高位为 1，商为 1 转第 1 步；若最高位为零 0，商为 0 转第 2 步
3. 循环直到余数位小于除数位时，该余数位最终余数

![image-20211005132755098](..\images\image-20211005132755098.png)

##### 例子

问题：设生成多项式位 $G(x)=x^3+x^2+1$，信息码为 101001，求对应的 CRC 码

初始信息分析：

R = 生成多项式最高次幂 = 3，K = 信息码长度 = 6，N = K + R = 9

生成多项式 G(x) 对应的二进制码为 1101

解题：

1. 将原信息左移 R 位，得到 101001000

2. 使用模 2 除法得到余数 001，则 CRC 码为 101001<u>001</u>

3. 接收端收到的 CRC 码，用生成多项式 G(x) 做模 2 除法，若**余数为 0，则码字无错**

   若接收端将受到的 CRC 码 $C_9C_8C_7C_6C_5C_4C_3C_2C_1$ 进行模 2 除法，得到的**余数为 010 不为零，则说明有错误**

   特别的，当 n + R ≤ $2^R$ - 1 时，有纠错功能，如上面的余数 010 就表示 $C_2$ 出错了

## 定点数的表示与运算

### 定点数的表示

#### 无符号数和有符号数的表示

- 无符号数：指**整个机械字长都是数值位**，没有符号位，若机械字长为 n 则范围为 $0\sim2^n-1$
- 有符号数：使用**最高位表示符号**，**0 为正 1 为负**，除最高位的是数值位

有符号数的机器表示有原码、补码、反码和移码，用 X 表示真值，用 $[X]_原$ 表示原码，$[X]_补$ 表示补码，$[X]_反$ 表示反码，$[X_移]$ 表示移码

#### 机械数的定点表示

根据小数点的位置是否固定，在计算机中有两种数据格式：定点表示和浮点表示

定点表示即约定机器数中的小数点位置是固定不变的，理论上，小数点位置固定在哪一位都可以

但在计算机中：<u>将小数点的位置固定在数据的最高位之前，称为定点小数；固定在最低位之后，称为定点整数</u>

在现代计算机中，通常用**定点补码整数表示整数**，用**定点原码小数表示浮点数的尾数部分**，用**移码表示浮点数的阶码部分**

##### 定点小数

定点小数是纯小数，不含有整数部分，小数点在符号位后在最高数值位前，存放如 `0.xxxxx` 的数据

定点小数的数据形式为 $x_0.x_1x_2\cdots x_n$，其中 $x_0$ 为符号位，$x_1\sim x_n$ 为数值位，$x_1$ 为最高有效位

##### 定点整数

定点整数是纯整数，不含有小数部分，小数点在最低位之后，存放如 `xxxxxx` 的数据

定点整数的数据形式为 $x_0x_1x_2\cdots x_n$，其中 $x_0$ 为符号位，$x_1\sim x_n$ 为数值位，$x_n$ 为最高有效位

#### 原码、补码、反码、移码

##### 原码表示法

原码是一种比较简单、直观的机器数表示法，用机器数的**最高位表示符号**，**其余位表示数的绝对值**

- 纯小数的定义：$[x]_原=\left\{\begin{matrix} x&1>x\geq0\\1+|x|&0\geq x>-1 \end{matrix}\right.$

  对于正小数 $x=+0.x_1x_2\cdots x_n$，有 $[x]_原=0.x_1x_2\cdots x_n$；对于负小数 $x=-0.x_1x_2\cdots x_n$，有 $[x]_原 =1.x_1x_2\cdots x_n$

  若字长为 n + 1，则原码的表示范围为 $-(1-2^{-n})≤x\leq 1-2^{-n}$

- 纯整数的源码定义：$[x]_原=\left\{\begin{matrix} x&2^n>x\geq0\\2^n+|x|&0\geq x>-2^n\end{matrix}\right.$（n 是整数位数）

  若 $x_1=+1110$，$x_2=-1110$，字长为 8 位，则 $[x_1]_原=0,0001110$，$[x_2]_原=1,0001110$

  若字长为 n + 1，则原码的表示范围为 $-(2^n-1)\leq x\leq 2^n-1$

注意：**真值零的原码表示不唯一**，即 $[+0]_原= 00000$ 和 $[-0]_原= 10000$

##### 补码表示法

在原码对于两个不同符号数的加法（或同符号数的减法）先要比较两个数的绝对值大小，然后用绝对值大的数减去绝对值小的数，最后还要给结果选择合适的符号；而**补码的加减法则统一采用加法操作实现**

- 纯小数的补码定义：$[x]_补=\left\{\begin{matrix} x&1>x\geq0\\2-|x|&0> x\geq-1 \end{matrix}\right.$（mod 2）可直接写成 $2+x$（mod 2）

  对于正数 $x=+0.x_1x_2\cdots x_n$，有 $[x]_补=0.x_1x_2\cdots x_n$；对于负数 $x=-0.x_1x_2\cdots x_n$，有 $[x]_补=10.00\cdots0- 0.x_1x_2\cdots x_n$（mod 2）

  若字长为 n + 1，则补码的表示范围为 $-1≤x\leq1 -2^{-n}$（比原码多表示 -1）

- 纯整数的补码定义：$[x]_补=\left\{\begin{matrix} x&2^n>x\geq0\\2^{n+1}-|x|&0\geq x\geq-2^n\end{matrix}\right.$（mod $2^{n+1}$）

  若 $x_1=+1110$，$x_2=-1110$，字长为 8 位，则 $[x_1]_补=0,0001110$，$[x_2]_补=2^8-0,0001101=1,1110011$

  若字长为 n + 1，则补码的表示范围为 $-2^n\leq x\leq 2^n-1$（比原码多表示 $-2^{n}$）

- **模 4 补码，又称变形补码**，即有两个符号位的补码，用在完成算术运算的 ALU 部件中

- **由原码求补码、补码求原码：**

  - 对于正数：补码和原码相同
  - 对于负数：符号位不变，数值位取反后加 1（互换通用）

注意：**真值零的补码表示是唯一的**，对于小数，补码比原码多表示一个 -1；对于整数，补码比原码多表示一个 $-2^n$

选择题：模 4 补码具有模 2 补码全部优点且更容易检测**加减运算中的溢出问题**

##### 反码表示法

反码通常用来作为**由原码求补码或由补码求原码的中间过渡**

对于负数，由原码数值位取反，或补码减一得到；对于正数与原码一致

- 纯小数的反码定义：$[x]_反=\left\{\begin{matrix} x&1>x\geq0\\(2-2^{-n})+x&0\geq x>-1 \end{matrix}\right.$（mod $2-2^{-n}$）

  若 $x_1=+0.0110$，$x_2=-0.0110$，字长为 8 位，则 $[x_1]_反=0.0110000$，$[x_2]_反=1.1111111-0,0110000=1,1001111$

  若字长为 n + 1，则原码的表示范围为 $-(1-2^{-n})≤x\leq 1-2^{-n}$

- 纯整数的反码定义：$[x]_反=\left\{\begin{matrix} x&2^n>x\geq0\\(2^{n+1}-1)+x&0\geq x>-2^n\end{matrix}\right.$（mod $2^{n+1}-1$）

  若 $x_1=+1011$，$x_2=-1011$，字长为 8 位，则 $[x_1]_反=0,0001011$，$[x_2]_反=1,1111111-0,0001011=1,1110100$

  若字长为 n + 1，则原码的表示范围为 $-(2^n-1)\leq x\leq 2^n-1$

注意：**真值零的反码表示不唯一**，即 $[+0]_反= 0.0000$ 和 $[-0]_反= 1.1111$

##### 移码表示法

移码常用来**表示浮点数的阶码**，它**只能表示整数**

移码就是在真值 X 上加上一个常数（偏置值），通常这个常数取 $2^n$，相当于向正方向偏移了若干单位，所以叫移码

移码定义为 $[x]_移 = 2^n+x $（$2^n>x ≥-2^n$ 其中机器字长为 n + 1）

正数 $x_1=+10101$，$x_2 = -10101$，字长为 8 位，则 $[x]_移 = 2^7+10101 =1, 0010101$，$[x]_移 = 2^7+(-10101)= 0,1101011$

移码具有以下特点：

1. 移码中**零的表示唯一**，$[+0]_移=2^n+0=[-0]_移 =2^n-0= 100\cdots0$（n 个 0）
2. **一个真值的移码和补码仅差一个符号位，$[x]_补$ 的符号位取反即得 $[x]_移$**
3. 移码全 0 时，对应真值的最小值 $-2^n$；移码全 1 时，对应真值的最大值 $2^n-1$
4. 移码**保持了数据原有的大小顺序**，移码大真值就大，移码小真值就小

### 定点数的运算

#### 定点数的移位运算

若移位后的**数值超过存储的界限**，导致运算错误，这就叫做溢出

如四位存储，无符号 1000 左移后变成 0000 原本应该是 10000 但超出存储限制变成 0000

以及补码 1000 左移还是 1000 但表达的数值错误了，发生溢出

##### 算术移位

算术移位的对象是**有符号数**，在移位过程中**符号位保持不变**（移码是浮点数，没有移位）

对于真值，左移一位若不产生溢出，相当于乘以 2；右移一位若不产生舍去，相当于除以 2

- 正数的原码、补码、反码相同，在移位后**使用 0 填充空位**
- 负数的原码、补码、反码不同，所以要分开考虑：
  - 原码：移位时仅移动数值位，**空位填 0**
  - 反码：移位时仅移动数值位，**空位填 1**（与原码相反）
  - 补码：移位时仅移动数值位，**左移空位填 0，右移空位填 1**

注意：不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补 0

思考：虽然说是说仅移动数值位，但是溢出时还是会修改符号位，如对于 int 类型 `0x80000001` 左移就变成 `0x2`

##### 逻辑移位

逻辑移位将操作数视为**无符号数**（正数），所以移位与算术位移正数的方法一样，**空位填 0**

##### 循环位移

循环移位分为带进位标志位 CF 的循环移位（大循环）和不带进位标志位的循环移位（小循环）

![image-20211007160822062](..\images\image-20211007160822062.png)

循环移位的主要特点是，**移出的数位又被移入数据中**，而是否带进位则要看是否将进位标志位加入循环位移

- 不带进位标志位：移出位**移入标志位，也移入空位**
- 带进位标志位：移出位移入标志位，标志位移到空位

循环移位操作特别适合将数据的低字节数据和高字节数据互换

#### 原码定点数的加减法运算

设 $[X]_原 =x_s.x_1x_2\cdots x_n$ 和 $[Y]_原=y_s.y_1y_2\cdots y_n$，进行加减运算的规则如下

加法规则：

1. 先判符号位
2. 若相同，则绝对值相加，结果符号位不变
3. 若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同

减法规则：

1. 将减数符号取反
2. 将它们按原码加法进行运算

注意：运算时注意机器字长，当左边位出现溢出时，将溢出位丢掉

#### 补码定点数加减法运算

补码加减运算规则简单，易于实现，因此计算机系统中**普遍采用补码加减运算**

1. 参与运算的**两个操作数均用补码表示**，**符号位也要参与运算**
2. 若做加法，则两数的补码直接相加；若做减法，则取减数的相反值的补码，再相加
   * 当参加运算的数是定点小数时，模 M = 2；当参加运算的数是定点整数时，模 $M = 2^n + 1$
   * **公式：$[A+B]_补=[A]_补+[B]_补$（mod M），$[A-B]_补=[A]_补+[-B]_补$（mod M）**
   * 注意：mod M 运算是为了将溢出位丢掉
3. 补码运算的结果亦为补码（符号位在计算时直接得出）

#### 符号扩展

在计算机算术运算中，有时必须把 n 位定点数转换成 m 位定点数（m > n），这称为符号扩展

注意：符号扩展时，**整数**的多余部分在**符号位后**；**小数**的多余部分在**末尾**

正数的符号扩展：新符号位的值等于原符号位的值，多余部分使用 0 填充

负数的符号扩展：根据**机械数的不同有不同的处理**

- 原码：新符号位的值等于原符号位的值，**多余部分使用 0 填充**

- 补码：新符号位的值等于原符号位的值，多余部分**整数用 1，小数用 0** 填充

  整数是 $1,0101\to1,11110101$；而小数是 $1.0101\to1.01010000$

- 反码：新符号位的值等于原符号位的值，**多余部分使用 1 填充**

#### 溢出概念和判别方法

溢出是指运算结果**超过了数的表示范围**，称**大于机器所能表示的最大正数为上溢**，称**小于机器所能表示的最小负数为下溢**

仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，补码的溢出判断有 3 种

##### 采用一位符号位

减法运算在机器中是用加法器实现的，因此<u>参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出</u>

设 A 的符号为 $A_S$，B 的符号为 $B_S$，运算结果的符号为 $S_S$,，则溢出逻辑表达式为 $V=A_SB_S\bar{S_S}+\bar A_S\bar B_SS_S$

解释：在离散数学中 $ab=a \& b$，$a+b=a|b$，$\overline{a}=\sim a$，式子意思是：**两个负号得正号 | 两个正号得负号**

若 V = 0，表示无溢出；若 V = 1，表示有溢出

##### 采用双符号位

双符号位法也称模 4 补码。这里的思路和上面的一样，也是看进位的，且会分析是什么溢出

运算结果的两个**符号位 $S_{s1}S_{s2}$ 相同，表示未溢出**；运算结果的两个**符号位 $S_{s1}S_{s2}$ 不同，表示溢出**，此时**最高位符号位代表真正的符号**

1. $S_{s1}S_{s2}=00$：表示结果为正数，无溢出（无进位）
2. $S_{s1}S_{s2}=01$：表示结果正溢出（单进位），`00,1011 + 00,1000` = 19 > 15
3. $S_{s1}S_{s2}=10$：表示结果负溢出（单进位），`11,0001 + 11,0010` = -27 < -16
4. $S_{s1}S_{s2}=11$：表示结果为负数，无溢出（双进位）

溢出逻辑判断表达式为 $V=S_{s1}\bigoplus S_{s2}$，若 V = 0，表示无溢出；若 V = l，表示有溢出

模 4 补码的特点：

1. 相比于模 2 补码，更容易检查**加减法**溢出的问题
2. 在存储时**仅存储一个符号位**，仅在计算时才扩展为两个
3. 在算术移位时，**仅底符号位要参与平移**，这样容易判断是否溢出

##### 根据符号和数据进位情况

若**符号位的进位 $C_S$ 与最高数位的进位 $C_1$ 相同**，则说明**没有溢出**，**否则表示发生溢出**

溢出逻辑判断表达式为 $V=C_S\bigoplus C_1$，若 V = 0，表示无溢出；V = 1，表示有溢出

思路：根据补码溢出只会发生在，两个负数相加或两个正数相加的情况下，它们在单进位时都是溢出的

负数合法时，进位是双进位的；正数合法时，进位是零进位的

#### 定点数的乘法运算

##### 原码一位乘法

原码一位乘法的**符号位与数值位分开求**，乘积符号由**两个数的符号位异或**形成，乘积的数值则是**两个数的绝对值相乘之积**

设 $[X]_原=x_s.x_1x_2\cdots x_n$，$[Y]_原=y_s.y_1y_2\cdots y_n$，则运算规则如下：

1. 被乘数和乘数均取绝对值参加运算，符号位为 $x_s\bigoplus y_s$
2. 部分积的长度同被乘数，取 n + 1 位，以便存放乘法过程中绝对值大于等于 1 的值，初值为 0
3. 从乘数的最低位 y，开始判断：
   - 若 $y_n=1$，则部分积加上被乘数 |x|，然后**逻辑右移**一位
   - 若 $y_n=0$，则部分积加上 0，然后逻辑右移一位
4. 重复步骤 3，判断 n 次

注意：考虑到运算时可能出现绝对值大于 1 的情况，所以部分积和被乘数取双符号位（感觉可以单符号位）

##### 原码一位乘法例子

题目：设机器字长为 5 位（含 1 位符号位，n = 4)，x = -0.1101，y = 0.1011，采用原码一位乘法求 x · y

|x| = 00.1101，|y| = 00.1011，原码一位乘法的求解过程如下

![image-20211007193915621](..\images\image-20211007193915621.png)

符号位 $P_s=x_s\bigoplus y_s= 1\bigoplus 0= 1$，得 x · y = -0.10001111

##### 无符号数乘法运算电路

![image-20220528143320972](..\images\image-20220528143320972.png)

1. C 存放进位，ALU 负责无符号加法，Y 放乘数，P 为零，计数器设为 32，X 放被乘数
2. 查看 Y 的最低位，如果为 1 就把 X 和 P 相加并放入 P
3. 带进位右移，计数器减一，不为零回到 2，为零乘法结束

##### 补码一位乘法（Booth 算法）

这是一种有符号数的乘法，采用相加和相减操作计算补码数据的乘积

设 $[X]_补=x_s.x_1x_2\cdots x_n$，$[Y]_补=y_s.y_1y_2\cdots y_n$，则运算规则如下：

1. 符号位参与运算，运算的数**均以补码表示**
2. 被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数可取单符号位
3. **乘数末位增设附加位 $y_{n+1}$，且初值为 0**
4. 根据 $(y_n,y_{n+1})$ 的取值来进行操作，见表 2.2
5. 移位按补码**算术右移**规则进行
6. 其中 4，5 步要进行 n 次，最后再进行一次第 4 步；右移 n 次，加 n + 1 次

![image-20211007200323395](..\images\image-20211007200323395.png)

##### 补码一位乘法例子

题目：设机器字长为 5 位（含 1 位符号位，n = 4），x = -0.1101，y = 0.1011，采用 Booth 算法求 x · y

$[x]_补=11.0011$，$[-x]_补=00.1101$，$[y]_补=0.1011$，Booth 算法求解过程如下：

![image-20211007200709117](..\images\image-20211007200709117.png)

所以 $[x\cdot y]_补=1.01110001$，得 x · y = -0.10001111

##### 补码乘法运算电路

![image-20220528150558929](..\images\image-20220528150558929.png)

和无符号乘法器差不多，这里会在 Y 多加一位，并对最低的两位进行异或

而且 ALU 会根据异或的结果进行加或减

##### 补码一位乘法的证明

1. 设 $[X]_补=x_0.x_1x_2\cdots x_n$

   当 $x\geq0$ 时，$[X]_补=0.x_1x_2\cdots x_n=\displaystyle\sum^n_{i=1}x_i2^{-i}=x$

   当 $x < 0$ 时，$[X]_补=1.x_1x_2\cdots x_n=2+x$ 得 $x=1.x_1x_2\cdots x_n-2=-1+\displaystyle\sum^n_{i=1}x_i2^{-i}$

   综上可得 $x=-x_0+\displaystyle\sum^n_{i=1}x_i2^{-i}$ 真值与补码间关系

2. 然后证明 $[x\cdot y]_补=[x]_补\cdot y=[x]_补\cdot(-y_0+\displaystyle\sum^n_{i=1}x_i2^{-i})$ 非常重要，证出这个基本证完

   1. 首先是 x 符号任意，y 是正的。若 x 是正的，显然上式成立；当 x 是负的：
      - $[x]_补=2+x=2^{n+1}+x$（mod 2），$[y]_补=y$
      - $[x]_补\cdot [y]_补=[x]_补\cdot y=2^{n+1}\cdot y+x\cdot y=2(y_1\cdots y_n)+x\cdot y$
      - 其中 $(y_1\cdots y_n)$ 是大于 0 的正整数，根据模运算有 $2(y_1\cdots y_n)=2$（mod 2）
      - 所以有 $[x]_补\cdot [y]_补=2+x\cdot y=[x\cdot y]_补$（mod 2）
      - 即 $[x\cdot y]_补=[x]_补\cdot [y]_补=[x]_补\cdot y$
   2. 接着证明 x 符号任意，y 是负的。
      - $[x]_补=x_0.x_1x_2\cdots x_n$，$[y]_补=1.y_1y_2\cdots y_n$ 即 $y=0.y_1y_2\cdots y_n-1$
      - $[x+y]_补=2+(x+y)=4+(x+y)=(2+x)+(2+y)=[x]_补+[y]_补$（mod 2）
      - $x\cdot y=x(0.y_1y_2\cdots y_n)-x$ 代入 $[x\cdot y]_补$ 得
      - $[x\cdot y]_补=[x(0.y_1y_2\cdots y_n)-x]_补=[x]_补(0.y_1y_2\cdots y_n)+[-x]_补$
   3. 综合 1 和 3 就得到 $[x\cdot y]_补=[x]_补(0.y_1y_2\cdots y_n)-[x]_补\cdot y_0=[x]_补\cdot(-y_0+\displaystyle\sum^n_{i=1}x_i2^{-i})$ 证毕

3. 最后把 2 式展开再修改一下就得出证明

   $[x\cdot y]_补=[x]_补(-y_0+y_12^{-1}+\cdots+y_n2^{-n})$

   $=[x]_补[(y_1-y_0)2^0+\cdots+(y_n-y_{n-1})2^{-(n-1)}+(0-y_n)2^{-n}]$

   $=[x]_补\cdot \displaystyle\sum^n_{i=1}(y_{i+1}-y_i)2^{-i}$

   这就是为什么 $y_{n+1}-y_n=0$ 时加 0；1 时加 $[X]_补$；-1 时加 $[-X]_补$

这里跳了步不是很好，更加详细得证明请看[这里](https://www.docin.com/p-1062001491.html)

##### 乘法运算总结

<img src="..\images\image-20211007212209252.png" alt="image-20211007212209252" style="zoom:150%;" />

#### 定点数的除法运算

##### *恢复余数法

恢复余数法就是被除数不够减时，恢复被除数，并设置商为 0

1. 被除数和除数均取绝对值参加运算，符号位为 $x_s\bigoplus y_s$
2. 使用被除数减除数，若大于零商取 1，左移；若小于零，被除数恢复，商取 0，左移
3. 第 2 步进行 n + 1 次就得到结果

##### 不恢复余数法

设 $[X]_原=x_s.x_1x_2\cdots x_n$，$[Y]_原=y_s.y_1y_2\cdots y_n$，则：

1. 商的符号：$Q_s=x_s\bigoplus y_s$
2. 商的数值：$|Q|=|X|/|Y|$

求 |Q| 的不恢复余数法运算规则如下：

1. 符号位不参与运算
2. 先用被除数减去除数 $(|X|-|Y|=|X|+(-|Y|)=|X|+ [-|Y|]_补)$
   - 当**余数为正**时，商上 1，余数和商**逻辑左移**一位，再**减去除数**
   - 当**余数为负**时，商上 0，余数和商逻辑左移一位，再**加上除数**
3. **当第 n + 1 步余数为负时，需要加上 |Y| 来恢复余数**；左移 n 次，加了 n + 1 次

思路：如果 A - B < 0 那么就应该判断 A - B / 2 来确定商，而这里的不恢复是当 A - B < 0 就使用 A - B + B / 2 = A - B / 2 来取消掉余数的恢复操作

##### 不恢复余数法例子

题目：设机器字长为 5 位（含 1 位符号位，n = 4），x = 0.1011，y = 0.1101，采用原码加减交替除法求 x / y

|x| = 0.1011，|y| = 0.1101，$[|y|]_补$= 0.1101，$[-|y|]_补$ = 1.0011

![image-20211008130833478](..\images\image-20211008130833478.png)

因此 $Q_s=x_s\bigoplus y_s=0$，得 $x/y=+0.1101$，余 $0.0111\times 2^{-4}$

##### 补码一位除法（加减交替法）

**补码一位除法**的特点是，**符号位与数值位一起参加运算，商符自然形成**

1. 符号位参加运算，**除数与被除数均用补码表示**，**商和余数也用补码表示**
2. 若**被除数与除数同号**，则**被除数减去除数**；若**被除数与除数异号**，则**被除数加上除数**
3. 若**余数与除数同号**，则**商上 1**，余数**逻辑左移一位减去除数**；若**余数与除数异号**，则**商上 0**，余数**逻辑左移一位加上除数**
4. 重复执行第 3 步操作 n 次
5. 若**对商的精度没有特殊要求**，则一般采用末位恒置 1 法

思路：思路还是不恢复余数法的思路，但是加了补码的性质下去

- 第 2 步其实是为了使用 |X| - |Y| 确定符号位
- 第 3 中余数与除数同号就相当于不恢复余数法的正，异号就相当于负；由此得出商位

##### 补码一位除法例子

题目：设机器字长为 5 位（含 1 位符号位，n = 4），x = 0.1000，y = -0.1011，采用补码加减交替法求 x / y
$[x]_补 = 00.1000$，$[y]_补=11.0101$，$[-y]_补=00.1011$

![image-20211008135809019](..\images\image-20211008135809019.png)

所以 $[x/y]_补=1.0101$，余 $0.0111\times 2^{-4}$

##### 除法运算电路

![image-20220528152903610](..\images\image-20220528152903610.png)

R 和 Q 联合一起放被除数，Y 放除数，ALU 运算的结果放在 R，R 的数值也会放入 ALU 进行运算，左移时产生商

与上面例子不同被除数的位数是除数的两倍

##### 除法运算总结

![image-20211008135937453](..\images\image-20211008135937453.png)

### C 语言中的整数及其转换

#### 有符号和无符号数的转换

在 C 语言中，有无符号的转换只是把机械数简单的从有符号看成无符号，里面的数值没有变

如短整型变量是 -1，它变成无符号短整型就是 $2^{16}-1=65535$

数值还是那些数值，关键看我们是如何看的，我们用有符号来看它就是有符号的；我们用指令来看，它就是指令

注意：一般代码内，int i = -1; 那么 i 的值就是 `0xffffffff`，即**定点数一般使用补码表示**

#### 不同字长整数的转换

1. 长字节整形转换成短字节整形，会**抹去高位部分**

   ```c
   int i = 0x12345678;
   short j = i;  // 0x5678
   ```

2. 短字节整形转换成高字节整形，会**扩展符号位**

   ```c
   short i = 0x9123;
   int j = i;  // 0xffff9123
   unsigned int k = i;  // 0xffff9123
   
   unsigned short i = 0x9123;
   int j = i;  // 0x00009123
   unsigned int k = i;  // 0x00009123
   ```

### 数据的存储和排列

#### 大小端方式存储

用**最低有效字节（`LSB`）和最高有效字节（`MSB`）**来分别表示数的**最低位和最高位**；`01234567H` 中 `MSB=01H`、`LSB=67H`

现代计算机基本上都采用字节编址，即**每个地址编号中存放 1 字节**

<u>int 和 float 型数据占 4 字节，double 型数据占 8 字节，short 型数占 2 字节，char 和 byte  和 boolean 占 1 字节</u>

根据**数据中各字节在连续字节序列中的排列顺序不同**，分成大端方式和小端方式：

- 大端方式（big endian）：高位对应低地址，低位对应高地址
- 小端方式（little endian）：高位对应高地址，低位对应低地址

![image-20211008144411597](..\images\image-20211008144411597.png)

一行机械指令：`4004d3: 01 05 64 94 04 08  add %eax, 0x8049464`

可以看出里面的操作数地址是使用小端方式存储的

#### 边界对齐方式

假设存储字长为 32 位，可按字节、半字和字寻址

对于机器字长为 32 位的计算机，数据以边界对齐方式存放，**半字地址一定是 2 的整数倍，字地址一定是 4 的整数倍**，这样无论所取的数据是字节、半字还是字，均可一次访存取出

存储的数据不满足上述要求时，填充空白字节使其符合要求，虽然**浪费了一些存储空间**，但**提高取指令和取数的速度**

数据不按边界对齐方式存储时，半字长或字长的指令可能会存储在两个存储字中，此时需要两次访存及调整，影响效率

```c
typedef struct a {
    long long a;  // 0
    char b;  // 8
    short c;  // A
    int d;  // C
    long long e;  // 10
} A;
```

RISC 如 ARM 采用边界对齐方式，而 CISC 如 `x86` 都支持，因为对齐方式取指令时间相同，因此能适应指令流水

**注意：长度为 $2^n$ 的数据类型，所在的地址必定也是 $2^n$ 的倍数**

思考：64 位是不是内存中一个单元其实是 8 个字节，我们取地址时先根据高位地址取字，再根据低 3 位取字节

### 硬件（来源习题）

#### 加法器

溢出标志位 OF 表示结果是否溢出，溢出了置 1（有符号）

- **两正数加起来超过界限，两负数加起来超过界限**，OF = 1

符号标志位 SF 表示**结果的符号**，负数置 1

进位标志位 CF 表示加法器最高位是否有进位（无符号）

- 把 x, y 看成无符号数，**加法时 x + y 超过存储范围，减法时 x - y 为负数**，那么 CF = 1

#### 乘法器

一般乘法器由 ALU、位移器、寄存器、相应的控制逻辑实现

控制逻辑的作用是控制循环次数，控制加法和位移操作

阵列乘法器器，是指不需要循环，直接列 n 个数错位相加，这样电路虽然多，但时钟周期是 1

## 浮点数的表示与运算

### 浮点数的表示

#### 浮点数的表示格式

**浮点数表示为 $N=r^E\times M$** 其中，r 是浮点数阶码的底，与尾数的基数相同；E 和 M 都是有符号的定点数，**E 称为阶码，M 称为尾数**；**浮点数由阶码和尾数组成**

![image-20211009195724842](..\images\image-20211009195724842.png)

阶码是整数，阶符是阶码的符号，阶码的位数表示浮点数的表示范围；它们的数值表示浮点数小数点的位置

**数符是浮点数的符号**，**尾数的位数反映浮点数的精度**

#### 规格化浮点数

为了**提高运算的精度**，需要**充分地利用尾数的有效数位**，即规定尾数的最高数位必须是一个有效值

规格化操作，是指**调整一个非规格化浮点数的尾数和阶码的大小**，令非零的浮点数在尾数的最高数位上保证是一个有效值

- 左规：将**尾数算术左移一位、阶码减 1**（基数为 2 时）；左归可能要进行多次；当**浮点数运算的结果为非规格化**时使用
- 右规：将**尾数算术右移一位、阶码加 1**（基数为 2 时）；只需进行一次；当**浮点数运算的结果尾数出现溢出**时使用

规格化浮点数的尾数 M 的绝对值应满足条件 1 / r ≤ |M| ≤ 1，规格化表示的尾数形式如下：

- 原码规格化后：

  正数为 $0.1??\cdots ?$ 的形式，其最大值表示为 $0.11\cdots 1$，最小值表示为 $0.100\cdots0$，尾数的表示范围为 $1/2≤M≤(1-2^{-n})$
  负数为 $1.1??\cdots?$ 的形式，其最大值表示为 $1.10\cdots0$，最小值表示为 $1.11\cdots1$，尾数的表示范围为 $-(1-2^{-n})≤M≤-1/2$

- 补码规格化后：

  正数为 $0.1??\cdots ?$ 的形式，其最大值表示为 $0.11\cdots 1$，最小值表示为 $0.100\cdots0$，尾数的表示范围为 $1/2≤M≤(1-2^{-n})$

  负数为 $1.0??\cdots?$ 的形式，其最大值表示为 $1.01\cdots1$，最小值表示为 $1.00\cdots0$，尾数的表示范围为 $-1≤M≤-(1/2+2^{-n})$

当浮点数尾数的基数为 2 时，**原码规格化数的尾数最高位一定是 1**，**补码规格化数的尾数最高位一定与尾数符号位相反**

当基数为 4 时，原码规格化形式的尾数**最高两位不全为 0**；当基数为 8 时，原码规格化形式的尾数**最高 3 位不全为 0**

思考：其实规格化可以是没有小数或没有整数部分，但我们常用没有整数部分的；规格化是为了保证没有浪费尾数位，如 0.0000123456 -> 0.123456

思考：基数不为 2 时，规格化也是保证没有浪费尾数位，即没有整数位，但左乘基就有整数位

#### 浮点数的表示范围

运算结果大于最大正数时称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称上溢

数据一旦产生**上溢**（阶码上溢），计算机必须**中断运算操作**，进行溢出处理

当运算结果在 0 至最小正数之间时称为正下溢，在 0 至绝对值最小负数之间时称为负下溢，正下溢和负下溢统称下溢

数据**下溢**时（阶码下溢），浮点数值趋于零，计算机**仅将其当作机器零处理**

![image-20211009205223954](..\images\image-20211009205223954.png)

选择题：浮点数格式如下：7 位阶码，1 位数符，8 位尾数。若阶码用移码，尾数用补码表示，则浮点数所能表示数的范围是 $-2^{63}\sim(1-2^{-8})\times 2^{63}$；阶码最高位是 63，尾数范围是 $-1\sim1-2^{-8}$

注意：浮点数的范围和阶码尾数的位数有关，且要注意使用的编码格式，还有浮点数的标准

#### IEEE 754 标准

##### 定义

![image-20211009205527770](..\images\image-20211009205527770.png)

IEEE 754 标准规定常用的浮点数格式有短浮点数（单精度、float 型）、长浮点数（双精度、double 型)、临时浮点数

<img src="..\images\image-20211009205645688.png" alt="image-20211009205645688" style="zoom:125%;" />

IEEE 754 标准的浮点数（除临时浮点数外），是**尾数**用采取隐藏位策略的**原码**表示，且**阶码用移码**表示的浮点数

用移码表示阶码是因为：**易于比较阶码；检验特殊值容易**（0 或 $\infty$）

以短浮点数为例，最高位为数符位；其后是 8 位阶码，以 2 为底，用移码表示，阶码的偏置值为 $2^{8-1}- 1 = 127$

其后 23 位是原码表示的尾数数值位，对于规格化的二进制浮点数，**数值的最高位是 1（隐含掉）**，尾数数值实际上是 24 位

阶码是以移码形式存储的，对于**短浮点数，偏置值为 127**；对于**长浮点数，偏置值为 1023**，**存储浮点数阶码部分之前，偏置值要先加到阶码真值上**（真值加上偏置值就变成移码）

IEEE 754 标准中，规格化的短浮点数的真值为 $(-1)^s×1.M\times 2^{E-127}$；规格化长浮点数的真值为 $(-1)^s×1.M\times 2^{E-1023}$

**短浮点数 E 的取值为 1~254**，M 为 23 位，共 32 位；**长浮点数 E 的取值为 1~2046**，M 为 52 位，共 64 位

<img src="..\images\image-20211009210655312.png" alt="image-20211009210655312" style="zoom:125%;" />

注意：短浮点数与长浮点数采用隐含尾数最高数位法，多表示一位尾数；**临时浮点数**又称扩展精度浮点数，**无隐含位**

注意：浮点数有一些保留位：

1. +0 和 -0 的表示：阶码全为 0 尾数全为 0，正负由符号位决定

2. $+\infty$ 和 $-\infty$ 的表示：阶码全为 1 尾数全为 0，正负由符号位决定

   ![image-20220529152032824](..\images\image-20220529152032824.png)

思考：因为阶码**全为 0 和全为 1 被占用了**，所以阶码范围是 1 ~ 254；**和移码相比还加了 1**，如阶码 `0x80` 由 0 变成了 1

注意：阶码全为 1 或 0 尾数不全为零时，这种数没有意义，或者不是规格化的浮点数

##### 例题

题目：把 x = -8.25 转换成 IEEE 754 单精度浮点型格式

1. x 是负的，所以数符位取 1
2. 把 8.25 转二进制得 1000.01
3. 右移三位得 1.00001 阶码是 3
4. 阶码加上偏置值有 3 + 127 = 130 = 1000 0010
5. 1.00001 隐含掉最高位有 00001
6. 把数符、阶码、尾数拼接起来得 1 10000010 00001000000000000000000 = `C104 0000H`

#### 定点、浮点表示的区别

1. 数值的表示范围：若定点数和浮点数的字长相同，则**浮点数的数值范围远远大于定点数**

2. 精度：指**一个数所含有效数值位的位数**

   对于字长相同的定点数和浮点数来说，**浮点数虽然扩大了数的表示范围，但精度降低了**

3. 数的运算：

   浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以**浮点运算比定点运算复杂**

4. 溢出问题：

   在定点运算中，当运算结果超出数的表示范围时，发生溢出

   浮点运算中，只有规格化后**阶码超出所能表示的范围**时，才发生溢出（尾数溢出不算溢出）

### 浮点数的加减运算

#### 如何进行加减运算

浮点数运算的特点是阶码运算和尾数运算分开进行，浮点数的加减运算一律采用补码；IEEE 754  可能再计算完后转回原码

1. 对阶：**使得两个数的阶码相等**

   求阶差，然后以**小阶向大阶看齐**的原则，将阶码小的尾数右移一位（基数为 2）阶加 1，直到阶码相等

   尾数右移时，舍弃掉有效位会产生误差，影响精度

2. 尾数求和：将对阶后的**尾数按定点数加（减）运算规则运算**

3. 规格化：
   
   双符号位其补码规格化形式为 $[S]_补= 00.1xx\cdots x$；当尾数小于 0 时，其补码规格化形式为 $[S]_补 =11.0xx\cdots x$
   
   当**尾数求和后不符合规格**，那么就会**使用左规或右规进行调整**（记忆：IEEE 754 的浮点数尾数是原码）
   
   - 左规：当尾数出现 `00.0x` 或 `11.1x` 时，需左规，直到尾数为 `00.1x` 或 `11.0x`
   
     也不用特变记，就是**左移到不能左移**为止，再左移会溢出符号位
   
   - 右规：当尾数求和结果溢出（如尾数为 `10.x` 或 `01.x`）时，需右规
   
4. 舍入：在**对阶**或**右规**的过程中，可能会将尾数低位丢失，引起误差，影响精度

   引入了 0 舍 1 入、和恒置 1，目的是让**引起的误差更小**，令**平均误差为 0** 有舍有入

   - 0 舍 1 入法：（C 语言一般是这个）

     在尾数右移时，**被<u>移去的最高数值位</u>为 0，则舍去；为 1，则在尾数的末位加 1**

     这样做**可能会使尾数又溢出**，此时需再做一次右规

   - 恒置 1 法：

     尾数右移时，不论丢掉的最高数值位（右移多次根据丢掉的最高位补）是 1 还是 0，都使右移后的**尾数末位恒置 1**

     这种方法同样有使尾数变大和变小的两种可能；最底有效位是 1 变小，最低有效位是 0 变大

5. 溢出判断：浮点数加减运算最后一步也需判断溢出

   在浮点数中不根据尾数判断溢出，若尾数溢出了会进行右归规，之后再根据阶码判断溢出

   浮点数的溢出与否是由阶码的符号决定的，以双符号位补码为例：

   - 当阶码的**符号位出现 01** 时，即阶码大于最大阶码时，**表示上溢，进入中断处理**
   - 当阶码的**符号位出现 10** 时，即阶码小于最小阶码时，**表示下溢，按机器零处理**

   左规可能上溢，右规可能下溢：0011 + 0001 上溢，1100 + 1111 下溢

6. C 语言中的浮点数类型及类型转换：

   C 语言中的 float 和  double 类型分别对应于 IEEE 754 单精度浮点数和双精度浮点数

   在 C 程序中**等式的赋值和判断中会出现强制类型转换**，**以 char→int→long→double 和 float→double 最为常见**，从小到大

   - 从 int 转换为 float 时，虽然**不会发生溢出**，但 float 数据位更少**可能有数据舍入**，若从 int 转换为 double 则不会出现
   - 从 int 或 float 转换为 double 时，因为 double 的有效位数更多，因此**能保留精确值**
   - 从 double 转换为 float 时，因为 float 表示范围更小，因此**可能发生溢出**；有效位数变少，因此**可能被舍入**
   - 从 float 或 double 转换为 int 时，因为 int 没有小数部分，所以数据**仅保留整数部分**，影响精度；由于 int 的表示范围更小，因此**可能发生溢出**

#### 例子

题目：已知十进制数 X = -5 / 256、Y = +59 / 1024，按机器补码浮点运算规则计算 X - Y，结果用二进制表示，浮点数格式如下：阶符取 2 位，阶码取 3 位，数符取 2 位，尾数取 9 位

$X = (-101)_2/2^8=(-0.101)\cdot2^{-5}$；$Y = (111011)_2/2^{10}=(0.111011)\cdot2^{-4}$

1. 对阶：X 阶码小，X 右规得 $X=(-0.0101)\cdot2^{-4}$
2. 尾数求差：使用原码相加 X + -Y，由于符号相同直接加 -0.0101 + -0.111011 = -1.001111
3. 溢出判断：尾数溢出，结果右规一次 -0.1001111 阶码加一 -3
4. 结果：结果真值为 $2^{-3}\cdot(-0.1001111)$

注意：浮点数的计算方法有很多种，如原码、补码计算；二进制表示要注意看编码是移码还是补码，符号位是单还是双

## 算术逻辑单元（ALU）

运算器承担了执行各种算术和逻辑运算的工作，运算器由算术逻辑单元（Arithmetic Logic Unit，ALU）、累加器、状态寄存器和通用寄存器组等组成

ALU 的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算，以及移位、求补等操作

计算机运行时，运算器的操作和操作种类由控制器决定

运算器处理的**数据来自存储器**；处理后的**结果数据通常送回存储器**，或**暂存在运算器中**

### 串行加法器和并行加法器

#### 一位全加器

全加器（FA）是最基本的加法单元，有三个输入：加数 $A_i$、加数 $B_i$ 与低位传来的进位 $C_{i-1}$；有两个输出：本位和 $S_i$ 与向高位的进位 $C_i$

和表达式：$S_i=A_i\bigoplus B_i \bigoplus C_{-1}$；进位表达式：$C_i= A_iB_i+(A_i\bigoplus B_i)C_{i-1}$

![image-20211010194334040](..\images\image-20211010194334040.png)

#### 串行加法器

在串行加法器中，**只有一个全加器**，数据逐位串行送入加法器中进行运算

若**操作数长 n 位，则加法就要分 n 次进行**，每次产生一位和，并且串行逐位地送回寄存器

进位触发器用来寄存进位信号，以便参与下一次运算

串行加法器具有**器件少、成本低**的优点，但**运算速度慢**，多用于某些低速的专用运算器

#### 并行加法器

并行加法器由多个全加器组成，其位数与机器的字长相同，各位数据同时运算

虽然操作数的各位是同时提供的，但**高位的运算结果依赖于低位所产生的进位**

并行加法器的最长运算时间主要是由**进位信号的传递时间决定的**，而每个全加器本身的求和延迟只是次要因素

通常将传递进位信号的逻辑线路连接起来构成的进位网络称为**进位链**

进位表达式为 $C_i=G_i+P_iC_{i-1}$ 式中 $G_i$ 是进位产生函数，$G_i=A_iB_i$；$P_i$ 是进位传递函数，$P_i=A_i\bigoplus B_i$.

并行加法器的进位通常分为串行进位与并行进位

##### 串行进位

把 n 个全加器串接起来，就可进行两个 n 位数的相加，这种加法器称为串行进位的并行加法器

串行进位又称行波进位，**每级进位直接依赖于前一级的进位**，即进位信号是逐级形成的

![image-20211010200752574](..\images\image-20211010200752574.png)

- $C_1= A_1B_1 + (A_1\bigoplus B_1)C_0$ 或 $(C_1=G_1+ P_1C_0)$
- $C_2= A_2B_2 + (A_2\bigoplus B_2)C_1$ 或 $(C_2=G_2+ P_2C_1)$
- $C_n= A_nB_n + (A_n\bigoplus B_n)C_{n-1}$ 或 $(C_n=G_n+ P_nC_{n-1})$

低位运算产生进位所需要的时间将可能影响直至最高位运算的时间，所以加快进位产生和提高传递的速度是关键

##### 并行进位

并行进位又称先行进位、同时进位，其特点是各级进位信号同时形成，其思路为：

- $C_1=G_1+ P_1C_0$
- $C_2=G_2+ P_2C_1=G_2+ P_2G_1+ P_2P_1C_0$
- $C_3=G_3+P_3C_2=G_3+P_3G_2+ P_3P_2G_1+ P_3P_2P_1C_0$
- $C_4=G_4+ P_4C_3=G_4+ P_4G_3+P_4P_3G_2+ P_4P_3P_2G_1+ P_4P_3P_2P_1C_0$

所有的进位输出仅由 $G_i$、$P_i$ 及最低进位输入 $C_0$ 决定，而不依赖于 $C_{i-1}$，因此**各级进位输出可以同时产生**

这种进位方式是快速的，与字长无关；随着**加法器位数的增加**，**电路结构会变得很复杂**，所以完全采用并行进位是不现实的

实际上通常采用分组并行进位方式，以 m 个为一组，把 n 位全加器分为若干小组

**小组内**的各位之间实行**并行快速进位**，**小组与小组之间**可以采用**串行进位方式**，也可以采用**并行快速进位方式**

###### 单级先行进位方式*

单级先行进位方式，又称**组内并行、组间串行进位**方式；以 16 位加法器为例，可分为 4 组，每组 4 位

组内的进位逻辑使用并行方式，进位信号 $C_1\sim C_4$ 是同时产生的，实现的电路称为 **4 位先行进位电路（`CLA`）**

把 4 个这样的 `CLA` 加法器串联起来，构成的 16 位单级先行进位加法器

![image-20211011190105258](..\images\image-20211011190105258.png)



###### 多级先行进位公式*

多级先行进位方式，又称**组内并行、组间并行进位**方式；以 16 位加法器为例，可分为 4 组，每组 4 位

第一小组的进位输出 $C_4$ 可以写为：

- $C_4=G_4+ P_4G_3+P_4P_3G_2+ P_4P_3P_2G_1+ P_4P_3P_2P_1C_0=G_1^*+P_1^*C_0$

- $G_1^*=G_4+ P_4G_3+P_4P_3G_2+ P_4P_3P_2G_1$，$P^*_1=P_4P_3P_2P_1$

- $G_i^*$ 称为组进位产生函数，$P_i^*$ 称为组进位传递函数，这两个辅助函数只与 $P_i$、$G_i$ 有关

以此类推：$C_8=G_2^*+ P_2^*C_4=G_2^*+ P_2^*G_1^*+ P_2^*P_1^*C_0$，$C_{12}$=......

**那么 $C_4,C_8,C_{12},C_{16}$ 可以根据 $G_i^*,P_i^*$ 同时产生**；可以知道每个组只需要提供 $P_i^*,G_i^*$ 就好了

那么就有组 1 提供 $G_1^*,P_1^*$ 和 $C_1,C_2,C_3$ 需要 $C_0$，其他组类似，这种电路称为**成组先行进位电路（`BCLA`）**

16 位的两级先行进位加法器可由 4 个 `BCLA` 加法器和 1 个 `CLA` 电路构成

![image-20211011193038250](..\images\image-20211011193038250.png)

首先 `CLA` 根据 $G_i^*,P_i^*$ 同时产生 $C_4,C_8,C_{12},C_{16}$ 给 `BCLA` 加法器内部产生其他进位，如 $C_1C_2C_3$ 等

这种方法可以扩展到多于两级的先行进位加法器，如用三级先行进位结构设计 64 位加法器

这种加法器的优点是**字长对加法时间影响甚小**，缺点是**造价较高**

### 算术逻辑单元的功能和结构

#### 带标志加法器

无符号数加法器只能用于两个无符号数相加，不能进行带符号整数的加/减运算

为了能进行带符号整数的加/减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能生成相应的标志信息

![image-20211010201538884](..\images\image-20211010201538884.png)

- **溢出标志**的逻辑表达式为 $OF = C_n \bigoplus C_{n-1}$
- **符号标志**就是和的符号，即 $SF =F_{n-1}$
- **零标志** `ZF = 1` 当且仅当 F = 0
- **进位/借位标志** $CF= C_{out}\bigoplus C_{in}$，即当 $C_{in}=0$ 时，CF 为进位 $C_{out}$；当 $C_{in}=1$ 时，CF 为进位 $C_{out}$ 取反

注意：为了加快加法运算的速度，实际电路一定使用多级先行进位方式，上图仅为了说明标志信息的获取

#### 算术逻辑单元

ALU 是一种功能较强的**组合逻辑电路**，它**能进行多种算术运算和逻辑运算**

由于加、减、乘、除运算最终都能归结为加法运算，因此 ALU 的核心是带标志加法器，同时也能执行与、或、非等逻辑运算

![image-20211010202357285](..\images\image-20211010202357285.png)

其中 A 和 B 是两个 n 位**操作数输入端**，$C_{in}$ 是**进位输入端**，`ALUop` 是**操作控制端**，用来决定 ALU 所执行的处理功能

如 `ALUop` 选择 Add 运算，ALU 就执行加法运算，输出的结果就是 A 加 B 之和；而且 **`ALUop` 的位数决定了操作的种类**

上图给出了能够完成 3 种运算的 ALU

- 与、或、加法（一位加法用一个全加器实现）
- 在 `ALUop` 的控制下，由一个多路选择器 `MUX` 选择输出 3 种操作结果之一
- 这里有 3 种操作，所以 `ALUop` 至少要有两位

#### 补码加减运算部件*

有两补码数相减 X - Y，转换成 X + (-Y) ，-Y 的补码是取反加一，那么就有 **X - Y = X + ~Y + 1**

无符号整数的二进制表示相当于正整数的补码表示，因此该思路同时**也能实现无符号整数的加/减运算**

下面根据思路来整出**可实现补码加减运算**的电路：

- 在原加法器的 Y 输入端**加 n 个反向器**以实现各位取反的功能
- 加一个 2 选 1 多路选择器，用一个控制端 Sub 来控制，以选择是将原码 Y 还是 $\overline Y$ 输入加法器
- 将控制端 Sub 同时作为低位进位送到加法器
- 控制端 Sub 为 1 时，做减法，实现 $X + \overline Y + 1 = [x]_补+ [-y]_补$
- 控制端 Sub 为 0 时，做加法，实现 $X + Y =[x]_补+ [y]_补$

![image-20211011162547057](..\images\image-20211011162547057.png)

可通过标志信息来区分带符号整数运算结果和无符号整数运算结果：

- 零标志 `ZF = 1` 表示结果为 0，不管是作为无符号数还是作为带符号整数来运算，`ZF` 都有意义

- 进/借位标志 CF 表示**无符号数加/减运算时的进位/借位**

  加法时，CF = 1 表示无符号数加法溢出，因此 CF 等于进位输出 $C_{out}$

  减法时，CF = 1 表示有借位，即不够减，故将进位输出 $C_{out}$ 取反来作为借位标志

  综合可得 $CF= Sub \bigoplus C_{out}$，**对于带符号整数运算，CF 没有意义**

- 溢出标志 OF = 1 表示带符号整数运算时结果发生溢出，对于无符号整数运算，OF 没有意义

- 符号标志 SF = 1 表示结果为负数，否则结果为正数

## 常见问题

1. 如何表示一个数值数据？计算机中的数值数据都是二进制数吗？

   1. 直接用**二进制数表示**，分为无符号数和有符号数，有符号数又分为定点数表示和浮点数表示
   2. **二进制编码的十进制数**，一般都采用 8421 码（也称 `NBCD` 码）来表示，用来表示整数
   
   所以，计算机中的数值数据虽然都用二进制来编码表示，但**不全是二进制数，也有用十进制数表示的**
   
2. 长度为 n + 1 的定点数，按照不同的编码方式，表示的数值范围是多少？

   <img src="..\images\image-20211011195022625.png" alt="image-20211011195022625" style="zoom:150%;" />

3. 设阶码和尾数均用补码表示，阶码部分共 K + 1 位（含 1 位阶符），尾数部分共 n + 1 位（含 1 位数符），则这样的浮点数表示范围是多少？

   <img src="..\images\image-20211011195108974.png" alt="image-20211011195108974" style="zoom:150%;" />

# 存储系统

## 存储器概述

### 存储器的分类

#### 按作用分类

1. 主存储器，简称主存，又称内存储器（**内存**）：

   存放计算机运行期间所需的大量程序和数据，CPU 可以**直接随机地对其进行访问**

   也可以**和高速缓冲存储器及辅助存储器交换数据**，其特点是**容量较小**、**存取速度较快**、每位**价格较高**

2. 辅助存储器，简称辅存，又称外存储器（外存）：

   是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息

   它**不能与 CPU 直接交换信息**，其特点是**容量极大**、**存取速度较慢**、单位**成本低**

3. 高速缓冲存储器，简称 Cache：

   位于**主存和 CPU 之间**，用来存放正在执行的程序段和数据，以便 CPU 能高速地使用它们

   Cache 的**存取速度可与 CPU 的速度相匹配**，但**存储容量小**、**价格高**，现代计算机通常将它们**制作在 CPU 中**

#### 按存储介质分类

按存储介质，存储器可分为：

- 磁表面存储器（磁盘、磁带）
- 磁芯存储器半导体存储器（MOS 型存储器、双极型存储器）
- 光存储器（光盘）

#### 按存取方式分类

1. 随机存储器 RAM：

   存储器的**每个存储单元的内容都可以随机存取**，而且存取时间与存储单元的物理位置无关

   其优点是**读写方便、使用灵活**，主要用作**主存或高速缓冲**存储器，RAM 又分为静态 RAM 和动态 RAM

2. 只读存储器 ROM：

   存储器的内容**只能随机读出而不能写入**，信息一旦写入存储器就固定不变，即使断电，**内容也不会丢失**

   通常用它**存放固定不变的数据**；它**与随机存储器可共同作为主存的一部分**，统一构成主存的地址域

   注意：现在已可通过电擦除等方式进行写入，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多

3. 串行访问存储器：

   对存储单元进行读/写操作时，需**按其物理位置的先后顺序寻址**

   包括**顺序存取存储器**（如磁带）与**直接存取存储器**（如磁盘、光盘）

顺序存取存储器的内容只能按某种顺序存取，存取时间的长短**与信息在存储体上的物理位置有关**，其特点是**存取速度慢**

直接存取存储器存取信息时通常**先寻找整个存储器中的某个小区域**（如磁盘上的磁道，随机访问），再在**小区域内顺序查找**

#### 按信息的可保存性分类

断电后，存储信息即消失的存储器，称为**易失性存储器**，如 RAM

断电后，信息仍然保持的存储器，称为**非易失性存储器**，如 ROM、磁表面存储器和光存储器

若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为**破坏性读出**

若读出时，被读单元原存储信息不被破坏，则称为**非破坏性读出**

具有破坏性读出性能的存储器，每次**读出操作后**，必须**恢复被破坏的信息**

### 存储器的性能指标

存储器有 3 个主要性能指标，即存储容量、单位成本和存储速度，这 3 个指标相互制约

1. 存储容量：**存储字数 × 字长**（如 `1M × 8` 位）

   单位换算：`1B`（Byte 字节）=  `8b`（bit 位）

   存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量

2. 单位成本：每位价格 = 总成本 / 总容量

3. 存储速度：数据传输率 = 数据的宽度 / 存储周期

   1. 存取时间 $T_a$：指一次存储器操作**从开始到完成所经历的时间**，分为读出时间和写入时间

   2. 存取周期 $T_m$：存取周期又称读写周期或访问周期

      指存储器进行一次**完整的读或写操作所需的全部时间**（存储时间 + 恢复时间）

      即连续两次独立访问存储器操作（读或写操作）**之间**所需的最小时间**间隔**

   3. 主存带宽 $B_m$：主存带宽又称**数据传输率**，表示**每秒从主存进出信息的最大数量**，单位为字/秒、字节/秒、位/秒

![image-20211011211555459](..\images\image-20211011211555459.png)

存取时间不等于存储周期，**通常存储周期大于存取时间**

对**任何一种存储器**，在读写操作之后，总要有一段**恢复内部状态**的复原时间（电路状态恢复，或者破坏性读出要恢复）

对于破坏性读出的存储器，**存取周期往往比存取时间大得多**，甚至可达 $T_m = 2T_a$，因为存储器中的信息读出后需要**马上进行再生**

选择题：若某存储器存储周期为 `250ns`，每次读出 16 位，该存储器的数据传输率是 $2B/(250\times 10^{-9}s)=8\times10^6B/s$

## 存储器的层次化结构

### 存储器的性能指标

为了解决存储系统大容量、高速度和低成本 3 个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构

![image-20211012140827410](..\images\image-20211012140827410.png)

存储系统层次结构主要体现在 **Cache - 主存**层次和**主存 - 辅存**层次

前者主要解决 **CPU 和主存速度不匹配**的问题，后者主要解决**存储系统的容量**问题

在存储体系中，**Cache、主存能与 CPU 直接交换信息**，辅存则要通过主存与 CPU 交换信息；主存与 CPU、Cache、辅存都能交换信息

![image-20211012141124311](..\images\image-20211012141124311.png)

存储器层次结构的主要思想是**上一层的存储器作为低一层存储器的高速缓存**

Cache - 主存层次速度接近于 Cache，容量和位价却接近于主存；主存 - 辅存层次速度接近于主存，容量和位价却接近于辅存

这就解决了速度、容量、成本这三者之间的矛盾，现代计算机系统几乎都采用这种三级存储系统

**主存和 Cache 之间的数据调动**是由硬件自动完成的，对所有程序员均**是透明的**；而**主存和辅存之间的数据调动**则是由硬件和操作系统共同完成的，对**应用程序员是透明的**

在主存 - 辅存这一层次的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应

注意：在 Cache - 主存和主存 - 辅存层次中，**上一层中的内容都只是下一层中的内容的副本**

### Cache - 主存效率计算

1. 求 Cache 的命中率：Cache 命中次数 / 主存命中次数
2. 求平均访问时间：Cache 命中率 × Cache 访问时间 + 主存命中率 × 主存访问时间
3. 求 Cache - 主存储系统效率：访问 Cache 时间 / 平均访问时间

题目：Cache 的存储时间是 `100ns`，主存的存储时间是 `1000ns`，若希望平均存储时间不超过 Cache 存储时间的 115%，则 Cache 的命中率至少为多少？

平均存储时间为 `100ns` × 115% = `115ns`

设命中率为 x，得 `100x + 1000(1 - x) ≤ 115` 得 x = 98.33%，因此命中率至少为 99%

## 半导体随机存储器

**主存储器由 DRAM 实现**，靠处理器的那一层（**Cache）则由 SRAM 实现**，它们都属于易失性存储器

DRAM 的每位价格低于 SRAM，速度也慢于 SRAM，价格差异主要是因为制造 SRAM 需要更多的硅

**ROM 属于非易失性存储器**

### SRAM 和 DRAM

#### SRAM 的工作原理

通常把**存放一个二进制**位的物理器件称为**存储元**，它是存储器的最基本的构件

地址码相同的**多个存储元构成一个存储单元**，若干**存储单元的集合构成存储体**

静态随机存储器（SRAM）的存储元是用**双稳态触发器**（六晶体管 MOS）来记忆信息的，因此即使信息被读出后，它仍保持其原状态而不需要再生（**非破坏性读出**）

SRAM 的存取速度快，但集成度低，功耗较大，所以一般用来组成**高速缓冲存储器**

#### DRAM 的工作原理

##### DRAM 的定义

动态随机存储器（DRAM）是利用存储元电路中**栅极电容**上的电荷来存储信息的，DRAM  通常**只使用一个晶体管**，所以它比SRAM 的密度要高很多，由于 DRAM 使用电容存储信息，所以它是**破坏性读出**，每次**读取后要恢复**

DRAM 采用**地址复用技术**，地址线是原来的 1 / 2，地址信号**分行、列两次传送**；SRAM 行和列不一定一样不能使用

相对于 SRAM 来说，DRAM 具有**容易集成、位价低、容量大和功耗低**等优点，但 DRAM 的存取速度比 SRAM 的慢，一般用来组成**大容量主存系统**

DRAM 电容上的电荷一般**只能维持 `1~2ms`**，信息会自动消失，**每隔一定时间必须刷新**，通常取 `2ms`，称为刷新周期

##### DRAM 的刷新

1. 集中刷新：在一个刷新周期内使用一段固定的时间，对存储器的行**逐一刷新**，期间**停止对存储器的读写操作**，称为**死时间**，或访存**死区**

   优点：读写操作时不受刷新工作的影响；缺点：在集中刷新期间不能访问存储器

2. 分散刷新：把对**每行的刷新分散到各个工作周期中**

   一个存储器的**系统工作周期分为两部分**：前半部分用于正常读、写或保持，后半部分用于刷新

   优点：**没有死区**；缺点：**加长了系统的存取周期**，降低了整机的速度

   注意：<u>刷新的行与读的行不是同一行，而且即使没有前半部分也要进行后半部分</u>

3. 异步刷新：是**前两种方法的结合**，它既可**缩短死时间**，又能充分利用最大刷新间隔为 `2ms` 的特点

   具体做法是将刷新周期除以行数，得到两次刷新操作之间的间间隔 t，利用逻辑电路**每隔时间 t 产生一次刷新请求**

   这样可以避免使 CPU 连续等待过长的时间，而且**减少了刷新次数**，从根本上提高了整机的工作效率

DRAM 的刷新需注意以下问题：

1. 刷新对 CPU 是透明的，即**刷新不依赖于外部的访问**
2. **动态 RAM 的刷新单位是行**，由芯片内部自行生成行地址
3. 刷新操作是把信息读出，通过刷新放大器存回存储单元，即读取恢复，所以仅**占用一个存储周期**
4. 刷新时不需要选片，即整个存储器中的**所有芯片同时被刷新**

#### 存储器芯片的内部结构

存储器芯片由存储体、IO 读写电路、地址译码和控制电路等部分组成

<img src="..\images\image-20211012155645393.png" alt="image-20211012155645393" style="zoom:150%;" />

1. 存储体（存储矩阵）**存储体是存储单元的集合**，它由行选择线 X 和列选择线 Y 来选择所访问单元，存储体的相同行、列上的位同时被读出或写入

2. 地址译码器：用来**将地址转换相应的行或列的位置**，如 101 转化为第 5 条线输出高电平，其他线均为低电平

3. I/O 控制电路：用以**控制被选中的单元的读出或写入**，具有放大信息的作用

4. 片选控制信号：用于**选择使用哪一个芯片**，因为单个芯片容量太少

   如果为高电平时对该存储芯片的操作是有效的，否则操作是无效的，多个存储芯片中只会有一个是高电平

5. 读/写控制信号：根据 CPU 给出的是读命令还是写命令，控制被选中单元进行读或写

外面可视的针脚是：

![image-20211012194326895](..\images\image-20211012194326895.png)

1. 地址：针脚和 log(地址) 一样多，DRAM 要除 2

2. 输出：阵脚和其位数一样多

3. 片选：一般是 1 根，但在 DRAM 中片选会变成**行通选和列通选**各占 1 根

   行通选做片选，列通选表示是行地址还是列地址；或者行通选表行地址，列通选表列地址，再加片选线

4. 读写：读写控制可能共用一根，也可能分开使用

#### 存储器的读、写周期

##### RAM 的读周期

![image-20211012183220060](..\images\image-20211012183220060.png)

<u>高电平优先是指在高电平时才是有效的；低电平优先是在低电平才是有效的</u>；$\overline{CS}$ 是**低电平优先**

1. 地址有效是指给出了地址，但地址并不是真正的稳定，因为需要**等待电流流动**
2. 地址稳定后 $\overline{CS}$ 输出片选信号，和地址一起就可以找到要读取的单元
3. 确定要读取的单元后，需要等待数据的电流流出，即数据稳定
4. 数据稳定后 $\overline{CS}$ 就完成工作了，输出完毕
5. 读取完成，输出都取消，但需要等待电流流完，这等待的时间就是恢复

其中 $t_{RC}$ 是存储周期，$t_A$ 是地址有效到数据稳定的时间（读出时间），$t_{CO}$ 是片选保持时间

里面很多地方需要等电流移动，即电流流到合适位置，如片选输出后要等他和地址汇合后才能得到数据位置

##### RAM 的写周期

![image-20211012184948291](..\images\image-20211012184948291.png)

读和写一样，是计算电流等待的过程，确定各自输出的时间

1. 地址有效等到地址稳定
2. 发出片选信号和写命令信号，等片选信号和地址汇合就数据有效
3. 等数据稳定就开始写入数据
4. 写入完就把输出收起，等待电流结束（恢复）

#### SRAM 和 DRAM 的比较

<img src="..\images\image-20211012185553260.png" alt="image-20211012185553260" style="zoom:150%;" />

### 只读存储器

#### 只读存储器的特点

ROM 和 RAM 都是支持随机存取的存储器，其中 SRAM  和 DRAM 均为**易失性半导体存储器**

而 ROM 中有了信息，就不能轻易改变，即使**掉电也不会丢失**，它在计算机系统中是只供读出的存储器

ROM 器件有两个显著的优点：

1. 结构简单，所以位密度比可读写存储器的高
2. 具有非易失性，所以可靠性高

#### ROM 的类型

1. 掩模式只读存储器（MROM）

   MROM 的内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，**写入以后任何人都无法改变其内容**

   优点是**可靠性高，集成度高，价格便宜**；缺点是**灵活性差**

2. 一次可编程只读存储器（PROM）

   PROM 允许用户利用专门的设备（编程器）写入自己的程序，**一旦写入，内容就无法改变**

3. 可擦除可编程只读存储器（EPROM）

   EPROM 不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写

   修改 EPROM 的内容时，先将其全部内容擦除，然后编程，紫外线擦除（`UVEPROM`）和电擦除（EEPROM​）

   EPROM 虽然既可读又可写，但它的**编程次数有限，且写入时间过长**

4. 闪速存储器（Flash Memory）

   Flash Memory 是在 EPROM 与 EEPROM​ 的基础上发展起来的，其主要特点是既可在不加电的情况下**长期保存信息**，又能在线进行**快速擦除与重写**

   闪速存储器既有 EPROM 的价格便宜、集成度高的优点，又有 EEPROM​ 电可擦除重写的特点，且擦除重写的速度快

5. 固态硬盘（Solid State Drives，SSD）

   **基于闪存**的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（FLASH 芯片）组成

   保留了 Flash Memory 长期保存信息、快速擦除与重写的特性

   对比传统硬盘也具有读写速度快、低功耗的特性，缺点是价格较高

选择题：U 盘属于只读存储器，采用 EEPROM 技术，注意：ROM 虽然是随机存储但不是随机存储器

选择题：闪存用 MOS 管，写入前必须先擦出数据，因此写速度比读速度慢，SSD 就是由 Flash 芯片组成

### 主存储器的基本组成

![image-20211012191446231](..\images\image-20211012191446231.png)

由一个个存储 0 或 1 的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部分

为了存取存储体中的信息，必须对存储单元编号（也称编址）

编址单位是指把多少个位编成一个单位，可以按字节编址，也可以按字编址，**现代计算机通常采用字节编址方式**

访问主存的步骤：

1. CPU 把被访问单元的地址送到 MAR 中
2. 通过地址线将主存地址送到主存中的地址寄存器
3. 地址译码器进行译码选中相应单元，同时 CPU 将读写信号通过控制线送到主存的读写控制电路
4. 如果是写操作：CPU 同时将要写的信息送到 MDR 中，在读写控制电路的控制下，经数据线将信号写入选中的单元
5. 如果是读操作，那么主存读出选中单元的内容送到数据线，然后送到 MDR 中

**数据线的宽度与 MDR 的宽度相同**，**地址线的宽度与 MAR 的宽度相同**，数据线数和地址线数**共同反映存储体容量的大小**

如上图，64 位数据线，每次可取 8 个单元的内容，36 位地址寻址范围 $0\sim2^{36}-1$，按字编址芯片容量 $2^{36}\times 64$ 位

## 主存储器与 CPU 的连接

### 连接原理

1. 主存储器通过**数据总线、地址总线、控制总线**与 CPU 连接
2. 数据总线的位数与工作频率的乘积正比于数据传输率
3. 地址总线的**位数**决定了**可寻址的最大内存空间**
4. 控制总线（**读/写**）指出总线周期的类型和本次输入/输出操作完成的时刻

### 主存容量的扩展

单个存储芯片的容量是有限的，在字数或字长方面与实际要求都有差距，因此要扩展以满足要求

#### 位扩展法

在 CPU 的**数据线数与存储芯片的数据位数不相等**时，**必须对存储芯片扩位**，使其数据位数**与 CPU 的数据线数相等**

位扩展的连接方式是**将多个存储芯片**的地址端、**片选**端和读写控制端**相应并联**，**数据端分别引出**

<img src="..\images\image-20211013161147965.png" alt="image-20211013161147965" style="zoom:150%;" />

注意：连接地址线的方式相同，连接数据线的方式不同；会选中所有的芯片，片选信号 $\overline {CS}$ 要连接到所有芯片

#### 字扩展法

字扩展（增加存储器中**字的数量**）将芯片的地址线、**数据线**、读写控制线**相应并联**，由**片选信号来区分各芯片的地址范围**

<img src="..\images\image-20211013161957442.png" alt="image-20211013161957442" style="zoom:150%;" />

使用地址高 2 位选择使用的芯片，低 14 位选择芯片的地址，$\overline{WE}$ 选择读写操作，都使用同一条数据线

注意：仅采用字扩展时，各芯片连接地址线、连接数据线的方式也相同，但要通过 $\overline{CS}$ 选择芯片

#### 字位同时扩展法

<img src="..\images\image-20211013170422782.png" alt="image-20211013170422782" style="zoom:150%;" />

就是**字面意思**，使用两个芯片位扩展到 8 位一组，然后增加 3 组扩展到 `64K` 字

扩展位就使用位扩展的连接，扩展字就使用字扩展的连接

注意：采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，片选信号 $\overline{CS}$ 也不同

### 存储芯片的地址分配和片选

CPU 要实现对存储单元的访问，首先进行片选；然后进行字选，片内的字选通常是由 CPU 送出的 N 条低位地址线完成的

#### 线选法

选择芯片时，使用**一个地址针脚直接连接一个芯片**的 $\overline{CS}$，地址低位用于片内寻址

优点：**不需要地址译码器**，线路简单；缺点：地址空间不连续，选片的地址线必须分时为低电平（否则不能工作），不能充分利用系统的存储器空间，**造成地址资源的浪费**

#### 译码片选法

译码器可以**让 n 根地址针脚选择从 $2^n$ 个芯片中选择一个**，如 000 选第 1 个芯片；010 选第 2 个芯片

8 个芯片如果采用线性法需要 8 位地址，而使用译码片选法仅需要 $\log_28=3$ 位地址

### 存储器与 CPU 的连接

#### 合理选择存储芯片

要组成一个主存系统，主要指存储芯片的类型（RAM 或 ROM）和数量的选择，考虑芯片数量时，要尽量使连线简单、方便

通常选用 **ROM 存放系统程序、标准子程序和各类常数**，RAM 则是为**用户编程**而设置的

#### 地址线的连接

存储芯片的容量不同，其地址线数也不同，而 **CPU 的地址线数往往比存储芯片的地址线数要多**

通常将 **CPU 地址线的低位**与存储芯片的地址线相连，以**选择芯片中的某一单元**，译码由芯片的片内逻辑完成的

而 **CPU 地址线的高位**则在扩充存储芯片时使用，用来**选择存储芯片**，译码由**外接译码器**逻辑完成

选择题：实际的主存容量不能代表 MAR 的位数，因为有扩展的需求，**MAR 的位数和主存地址空间大小有关**

#### 数据线的连接

CPU 的数据线数与存储芯片的数据线数**不一定相等**，在相等时可直接相连

在不等时**必须对存储芯片扩位**，使其数据位数**与 CPU 的数据线数相等**

#### 读/写命令线的连接

CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，**$\overline{WE}$（或 $\overline{WR}$）表示高电平为读，低电平为写**

有些 CPU 的**读/写命令线是分开的**（读为 $\overline{RD}$，写为 $\overline{WE}$，均为低电平有效），此时 CPU 的**读命令线**应**与存储芯片的允许读控制端相连**，而 CPU 的**写命令线**则应**与存储芯片的允许写控制端相连**

#### 片选线的连接

片选线的连接是 CPU 与存储芯片连接的关键，存储器由许多存储芯片叠加而成，**CPU 会给选择的芯片发 $\overline{CS}$（或 $\overline{CE}$） 信号**

片选有效信号与 CPU 的访存控制信号 $\overline{MREO}$ 有关，因为**只有当 CPU 要求访存时，才要求选中存储芯片**

若 CPU 访问 IO，则 $\overline{MREQ}$ 为高（低电平有效的），表示不要求存储器工作

因此单芯片时 $\overline{MREQ}$ 会直接连接 $\overline{CS}$，多芯片时会经过逻辑运算如与非再连 $\overline{CS}$

### 逻辑图绘制*

题目：设 CPU 有 16 根地址线，8 根数据线，并用 $\overline{MREQ}$ 作为访存控制信号（低电平有效），用 $\overline{WR}$ 作为读/写控制信号（高电平为读，低电平为写）。使用 1 片 `2K×8` 位的 ROM 芯片地址 `6000H ~67FFH` 为系统程序区；使用 2 片 `1K×4` 位的 RAM 芯片地址 `6800H ~6BFFH` 为用户程序区，请详细画出存储芯片的片选逻辑图

<img src="..\images\image-20211013202206363.png" alt="image-20211013202206363" style="zoom:150%;" />

首先把地址转成二进制：`6000H = 0b0110 0000 0000 0000`，`6800H = 0b0110 1000 0000 0000`

那么可以注意到只需要在高位 01 100 时选择 ROM，在 01 101 0 时选择 RAM

两个共同的高位是 5 位，所以译码器是五位，然后 CPU 的 $\overline{MREQ}$ 和最高两位为 01 是输入有效判断；低三位为 100 = 4 时选择 ROM，为 101 = 5 时选择 RAM

对 RAM 来说高位比译码器多一位，所以除了移码其挑选外还要判断 $A_{10}$ 是 0，所以加多了个与非电路

注意：低电平优先时要多画一个小圆圈，$G_,\overline{G_{2A}},\overline{G_{2B}}$ 为使能电路，即为 100 时译码器才能工作

## 双端口 RAM 和多模块存储器

### 双端口 RAM

双端口 RAM 是指同一个存储器有左、右**两个独立的端口**，分别具有两组相互独立的地址线、数据线和读写控制线

![image-20211014161711704](..\images\image-20211014161711704.png)

允许**两个独立的控制器同时异步地访问存储单元**，当两个端口的**地址不相同**时，**不会发生冲突**

两个端口**同时存取存储器的同一地址单元**时，会因数据冲突造成数据存储或读取错误，有以下 4 种情况：

1. 两个端口不同时对同一地址单元存取数据
2. 两个端口同时对同一地址单元读出数据
3. 两个端口**同时对同一地址单元写入数据**（写错误）
4. 两个端口**同时对同一地址单元操作**，一个写入数据，另一个读出数据（读错误）

解决方法：置忙信号 BUSY 为 0，由判断逻辑决定暂时关闭一个端口，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问

### 多模块存储器

#### 单体多字存储器

单体多字系统的特点是存储器中**只有一个存储体**，每个存储单元**存储 m 个字**，总线宽度也为 m 个字

CPU 访问主存储器时，主存储器一次读出 m 个字，并根据地址返回一个给 CPU，下次地址在上次取出的 m 个字里面直接返回，如果不在就重新取一次

显然，这增大了存储器的带宽，提高了单体存储器的工作速度

缺点：**指令和数据在主存内必须是连续存放的**，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显

#### 多体并行存储器

多体并行存储器由多体模块组成，**每个模块都有相同的容量和存取速度**，各模块都有独立的读写控制电路、地址寄存器和数据寄存器，它们**既能并行工作，又能交叉工作**

##### 高位交叉编址

高位地址表示体号，低位地址为体内地址

<img src="..\images\image-20211014164922733.png" alt="image-20211014164922733" style="zoom:150%;" />

高位交叉编址方式下，总是把低位的体内地址送到由高位体号确定的模块内进行译码

访问一个**连续主存**块时，总是**访问同一个模块**，存储模块不能被并行访问，因而**不能提高存储器的吞吐率**

注意：模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是**顺序存储器**（顺序方式）

选择题：虽然连续时像顺序存储，但隔 n 个地址来寻址也是可以让模块并行工作的，但可能性比较小

##### 低位交叉编址

低位地址为体号，高位地址为体内地址

![image-20211014165910493](..\images\image-20211014165910493.png)

低位交叉编址方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码

**连续地址数据存放在相邻模块中**，因此称采用此编址方式的存储器为**交叉存储器**（交叉方式）

采用低位交叉编址后，可在不改变每个模块存取周期的前提下，**采用流水线的方式并行存取**，提高存储器的带宽

![image-20211014182950556](..\images\image-20211014182950556.png)

设模块字长等于数据总线宽度，模块存取一个字的**存取周期为 T**，总线**传送周期为 r**

为实现流水线方式存取，存储器交叉模块数必须**大于等于** $m= T/r$ 式中，m 称为交叉存取度

**连续存取 m 个字**所需的时间为 $t_1=T+(m-1)r$ 而**顺序方式连续读取 m 个字**所需的时间为 $t_2 = mT$

思考：跳转地址后，加载的地址可能依然是流水线的地址，如 4 个模块加载地址为 0123 8567 依然是流水线，因为 8 地址也是在第一模块的，所以这里虽然连续地址没有单体快，但适合于跳转

思考：双端口是多核 CPU 使用，而多模块是流水线增加带宽，那么我们的 CPU 是不是两个都使用？

选择题：4 个 8 位存储器采用交叉方式，与 32 位的存储器总线相连，主存每次最多读写 32 位数据，则读 double 型变量需要 3 个存储周期，因为 $1 + \lceil(8-1) / 4\rceil=3$ // 注意 double 要读两次

## 外存储器

### 磁盘存储器

所谓磁表面存储，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息

磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器

#### 磁表面存储器的优缺点

优点：

1. 存储容量大，位价格低
2. 记录介质可重复使用
3. 记录信息可长期保存而不丢失，甚至可脱机存档
4. 非破坏性读出，读出时不需要再生

缺点：存取速度慢，机械结构复杂，对工作环境要求较高

#### 磁盘设备的组成

1. 存储区域：**一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位，即磁盘按块存取**

   - 磁头数 Heads：即**记录面数**，**一个记录面对应一个磁头**，磁头用于读取/写入盘片上记录面的信息
   - 柱面数 Cylinders：**硬盘每面盘片上有多少条磁道**，不同面有相同的磁道，磁道是一个圆环
   - 扇区数 Sectors：表示**每条磁道上有多少个扇区**

   ![2843224-46fb935cd31addbd](..\images\2843224-46fb935cd31addbd.png)

2. 硬盘存储器的组成：硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成

   - 磁盘驱动器：核心部件是**磁头组件和盘片组件**，温彻斯特盘是一种可移动磁头固定盘片的硬盘存储器
   - 磁盘控制器：**硬盘存储器和主机的接口**，即电路，主流的标准有 `IDE、SCSI、SATA` 等

#### 磁记录原理

原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作

编码方法：按某种方案，把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换

磁记录方式：通常采用调频制 FM 和改进型调频制 `MFM` 的记录方式

#### 磁盘的性能指标

- 磁盘的容量：磁盘容量有非格式化容量和格式化容量之分

  非格式化容量是指<u>磁记录表面可利用的磁化单元总数</u>，它由道密度和位密度计算而来

  格式化容量是指<u>按照某种特定的记录格式所能存储信息的总量</u>，可能容量没使用充分

  **格式化后的容量比非格式化容量要小**

- 记录密度：记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示

  1. 道密度：沿磁盘半径方向**单位长度上的磁道数**
  2. 位密度：磁道**单位长度上能记录的二进制代码位数**，外圈密度小，内圈密度大
  3. 面密度：**位密度和道密度的乘积**，一个磁道的数据乘以磁道数

- 平均存取时间：平均存取时间由三部分构成，**加起来就是了**：

  1. 寻道时间：磁头移动到目的磁道的时间
  2. 旋转延迟时间：磁头定位到要读写扇区的时间，**取旋转一周时间的一半**
  3. 传输时间：传输数据所花费的时间

  由于寻道和找扇区的距离远近不一，因此**前两部分通常取平均值**

- 数据传输率：磁盘存储器在**单位时间内向主机传送数据的字节数**，称为数据传输率

  假设磁盘转数为 r 转/秒，每条磁道容量为 N 字节，则**数据传输率为 $D_r=rN$**

#### 磁盘地址

若系统中有 4 个驱动器，每个驱动器代表一个磁盘，每个磁盘 256 个磁道、16 个盘面，每个盘面划分为 16 个扇区

则**每个扇区地址要 18 位二进制代码**

![image-20211028155328795](..\images\image-20211028155328795.png)

#### 硬盘的工作过程

硬盘的主要操作是**寻址、读盘、写盘**；每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字

硬盘属于机械式部件，其**读写操作是串行的**，不能在同一时刻既读又写，也**不能在同一时刻读两组数据**或写两组数据

### 磁盘阵列

RAID（廉价冗余磁盘阵列）是指将**多个独立的物理磁盘组成一个独立的逻辑盘**，数据在多个物理盘上分割交叉存储、并行访问，**具有更好的存储性能、可靠性和安全性**

- RAID 0：无冗余和无校验的磁盘阵列，类似于**多模块低位交叉**，提高存储容量和读取速度
- RAID 1：镜像磁盘阵列，如使用**两个磁盘进行读写，互为备份**
- RAID 2：采用纠错的海明码的磁盘阵列，这里及下面，**使用校验码，当数据出错时进行纠正**
- RAID 3：位交叉奇偶校验的磁盘阵列
- RAID 4：块交叉奇偶校验的磁盘阵列
- RAID 5：无独立校验的奇偶校验磁盘阵列

在 `RAID1 ~ RAID5` 几种方案中，数据损坏都可以恢复，提高了系统的可靠性

RAID 通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力

### 光盘存储器*

光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触方式记录信息

完整的光盘存储系统由光盘片、光盘驱动器、光盘控制器和光盘驱动软件组成

光盘片由透明的聚合物基片、铝合金反射层、漆膜保护层的固盘构成

特点：具有存储密度高、携带方便、成本低、容量大、存储期限长和容易保存等优点

**光盘的类型**如下：

- CD-ROM：只读型光盘，只能读出其中的内容，不能写入或修改
- CD-R：只可写入一次信息，之后不可修改
- CD-`RW`：可读可写光盘，可以重复读写
- `DVD-ROM`：高容量的 CD-ROM，`DVD` 表示通用数字化多功能光盘

### 固态硬盘

固态硬盘是一种基于闪存 Flash Memory 技术的存储器，属于电可擦除 ROM，即 EEPROM

它与 U 盘并没有本质上的差别，只是容量更大，存取性能更好

#### 组成

闪存翻译层：负责翻译逻辑块号，找到对应页 Page

存储介质：**由多个闪存芯片 Flash Chip 组成；每个芯片包含多个块 block；每个块包含多个页 page**

#### 读写性能特性

**以页 page 为单位读/写**，相当于磁盘的扇区

**以块 block 为单位擦除**，擦千净的块，其中的每页都可以写一次，读无限次

支持随机访问，系统给定一个逻辑地址，闪存翻译层可**通过电路迅速定位到对应的物理地址**

读快、写慢：**要写的页如果有数据，则不能写入**，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页

额外：移动后，逻辑块号对应的物理快号也会变；虽然操作系统给出的是同一个地址，但闪存翻译层会映射到移动后的地方

#### 与机械硬盘相比的特点

SSD **读写速度快，随机访问性能高**，用**电路控制**访问位置；机械硬盘通过**移动磁臂旋转磁盘控制**访问位置，有**寻道时间和旋转延迟**

SSD 安静<u>无噪音、耐摔抗震、能耗低、造价更贵</u>

SSD 的**一个块被擦除次数过多（重复写同一个块）可能会坏掉**，而机械硬盘的扇区不会因为写的次数太多而坏掉

#### 磨损均衡技术

思想：**将擦除平均分布在各个块上,以提升使用寿命**

动态磨损均衡：写入数据时，优先**选择累计擦除次数少的新闪存块**

静态磨损均衡：SSD 监测并自动进行数据分配、迁移，**让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务**；如一些块一直被写，变成老块，就把写的少的新块和老块内容交换，以后写的时候就写新块了

额外：操作系统也有磁盘整理，把可用的页合并到一个块上，擦除全红的块空出空间（红色是已删除的页）

思考：块内地址应该是连续的，所以操作系统整理页时，会在文件夹修改对应的文件的地址

![image-20220602151756996](..\images\image-20220602151756996.png)

### 综合应用题

题目：硬磁盘共有 4 个记录面，存储区域内半径为 `10cm`，外半径为 `15.5cm`，道密度为 60 道/cm，外层位密度为 `600bit/cm`，转速为 6000 转/分

1. 硬磁盘的磁道总数是多少？
2. 硬磁盘的容量是多少？
3. 将长度超过一个磁道容量的文件记录在同一个柱面上是否合理？
4. 假定每个扇区的容量为 `512B`，每个磁道有 12 个扇区，寻道的平均等待时间为 `10.5ms`，试计算磁盘平均存取时间

解答：

1. 磁道总数：`60 × (15.5cm - 15cm) × 4 = 1320`

2. 外磁道长度：`3.14 × 15.5cm × 2 = 97.34cm`

   到磁道信息量：`600bit/cm × 97.34cm = 7300.5B = 7300B`，磁道不能放 `0.5B`

   总量为：`7300B × 1320 = 963600B`

3. 合理，**因为不需要重新寻找磁道，读写速度变快了**

4. 旋转延迟时间：`60s / 6000转 = 10ms`，取平均得 `5ms`

   扫过一个扇区时间：`10ms / 12 = 0.83ms`

   磁盘平均存取时间：`10.5ms + 5ms + 0.83ms = 16.33ms`

## 高速缓冲存储器

### 程序访问的局部性原理

程序访问的局部性原理包括**时间局部性**和**空间局部性**

1. 时间局部性：未来可能会**再次使用现在使用的信息**，因为程序中存在循环
2. 空间局部性：未来可能会**使用现在信息附近的信息**，因为指令通常是顺序存放执行，数据一般也是群聚地存储

高速缓冲技术就是利用局部性原理，把**正在使用的部分**存放在快且小的 Cache 中，使 CPU 的访存操作**大多数针对 Cache 进行**，从而大大提高程序的执行速度

![image-20211015163626715](..\images\image-20211015163626715.png)

- 对于数组 a，程序 A 的访问是 $a[0][0],a[0][1]\cdots$ 空间局部性好，而对于程序 B 的访问是 $a[0][0],a[1][0]\cdots$  空间局部性差
- 对于数据 a，程序 A 和程序 B 里面数组的每一个元素都只访问一次，时间局部性差
- 对于指令的 for 循环体，本身及周围指令一直被访问，因此时间和空间局部性好

选择题：程序访问的局部性原理，是指在程序执行过程中，**程序对主存的访问是不均匀的**，有些会访问比较多

### Cache 的基本工作原理

Cache 位于存储器层次结构的顶层，通常**由 SRAM 构成**，且位于 CPU 内部

![image-20211015165305573](..\images\image-20211015165305573.png)

Cache 的分块：

- Cache 和主存都被划**分为相等的块** Cache 块又称 Cache 行，每块**由若干字节组成**，块的长度称为块长（Cache 行长）
- Cache 中的块数要远少于主存中的块数，它仅**保存主存中最活跃的若干块的副本**
- Cache 按照某种策略，预测 CPU 在**未来一段时间内欲访存的数据**，将其装入 Cache

CPU 的访存过程：

1. 当 CPU 发出读请求时，若命中 Cache，**只对 Cache 进行读操作**，与主存无关
2. 若 Cache 不命中，则仍需访问主存，并**把此字所在的块一次性地从主存调入 Cache**
3. 若此时 Cache 已满，则需根据某种替换算法，用这个块**替换 Cache中原来的某块信息**
4. 值得注意的是，CPU 与 Cache 之间的数据交换**以字为单位**，而 Cache 与主存之间的数据交换则**以 Cache 块为单位**

注意：某些计算机中也**采用同时访问 Cache 和主存的方式**，若 Cache 命中，则主存访问终止；否则访问主存并替换 Cache

- 某道考研题就没说方式，题目**默认使用把内存加入 Cache 再从 Cache 读**，实际应该都可以用，<u>哪个能计算出结果用哪个</u>

设一个程序执行期间，Cache 的总命中次数为 $N_c$，访问主存的总次数为 $N_m$，则**命中率** H 为 $H = N_c/(N_c+ N_m)$

设 $t_c$ 为命中时的 Cache 访问时间，$t_m$ 为未命中时的访问时间，$1-H$ 表示未命中率，则 Cache - 主存系统的**平均访问时间** $T_a$ 为 $T_a=Ht_c+(1-H)t_m$

根据 Cache 的读、写流程，实现 Cache 时需解决以下关键问题：下面来一一说明

1. 数据查找：如何快速判断数据是否在 Cache 中
2. 地址映射：主存块如何存放在 Cache 中，如何将主存地址转换为 Cache 地址
3. 替换策略：Cache 满后，使用何种策略对 Cache 块进行替换或淘汰
4. 写入策略：如何既保证主存块和 Cache 块的数据一致性，又尽量提升效率

### Cache 和主存的映射关系

Cache 行中的信息是主存中某个块的副本，地址映射是指把存放在主存中的信息按照某种规则装入 Cache

主存中只有一部分块的信息可放在 Cache 中，因此在 Cache 中要为每块加一个**标记**，指明**它是主存中哪一块的副本**

该标记的内容相当于主存中块的编号，为了说明 Cache 行中的信息是否有效，**每个 Cache 行需要一个有效位**

#### 直接映射

主存中的**每一块只能装入 Cache 中的唯一位置**，若这个位置已有内容则产生块冲突，**原来的块将<u>无条件</u>地被替换出去**

直接映射**实现简单**，但 Cache 的其他许多地址空着也不能占用，这使得直接映射的**块冲突概率最高，空间利用率最低**

直接映射的关系可定义为 $j = i\ \ mod\ \ 2^c$ 式中，j 是 Cache 的块号，i 是主存的块号，$2^c$ 是 Cache 中的总块数

![image-20211015190532819](..\images\image-20211015190532819.png)

主存地址分成：**标记 tag、Cache 行号、块内地址**，其中标记需要 Cache 额外使用空间来存储

CPU 访存过程：

1. 首先根据访存地址中间的 c 位，**找到对应的 Cache 行**
2. 将对应 Cache 行中的标记和主存地址的高 t 位标记进行比较
3. 若相等且有效位为 1，则访问 Cache 命中，此时**根据**主存地址中**低位的块内地址**，在对应的 Cache 行中**存取信息**
4. 若不相等或有效位为 0，则不命中，CPU 从主存中读出该地址所在的一块信息送到对应的 Cache 行中，将有效位置 1，并**将标记设置为地址中的高 t 位**，**同时**将该地址中的内容送 CPU

注意：很多时候在 Cache 缺失时是**先把内存加载到 Cache**，然后 CPU **再从 Cache 里面拿数据**

#### 全相联映射

主存中的每一块可以装入 Cache 中的**任何位置**，每行的标记用于指出该行取自主存的哪一块，所以 CPU **访存时需要与所有Cache 行的标记进行比较**

优点：比较灵活，Cache 块的冲突概率低，**空间利用率高，命中率也高**

缺点：**标记的比较速度较慢**，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射

![image-20211015192026769](..\images\image-20211015192026769.png)

主存地址分成：**标记 tag、块内地址**，由于少了行号，需要更多的空间来存放标记

#### 组相联映射

将 Cache 空间分成大小相同的组，主存的数据块可以装入组内的任何位置，即**组间采取直接映射，组内采取全相联映射**

它是对**直接映射和全相联映射的一种折中**，假设每组有 r 个 Cache 行，则称之为 **r 路组相联**

组相联映射的关系可以定义为 **`j = i mod Q`** 式中，j 是 Cache 行的组号，i 是主存的块号，Q 是 Cache 的组数

**路数越大**，即每组 Cache 行的数量越大，**发生块冲突的概率越低**，但相联**比较电路也越复杂**

选定适当的数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射

![image-20211015193552644](..\images\image-20211015193552644.png)

主存地址分成：**标记 tag、组号、块内地址**，这里的标记占用空间比直接映射多，但比全相联映射少

CPU 访存过程如下：

1. 先根据访存地址中间的组号**找到对应的 Cache 组**
2. 将对应 Cache 组中每个行的标记**与主存地址的高位标记进行比较**
3. 若有一个相等且有效位为 1，则访问 Cache 命中，此时根据主存地址中的块内地址，**在对应 Cache 行中存取信息**
4. 若都不相等或虽相等但有效位为 0，则不命中，CPU 从主存中读出该地址所在的一块信息送到对应 Cache 组的任意一个空闲行中，将**有效位置 1**，并**设置标记**，**同时**将该地址中的内容送 CPU

额外：现在的 Cache 的组不是随便取的，它是和 CPU 的多线路并发查找数量一样，即可以同时检查多少个 Cache 行数

选择题：还有一种组映射的方式：组号-行号，假设一组 2 行，一共 2 组，使用 1 位组号 1 位行号（无用），`x0x` 映射到第 0 组，`x1x` 映射到第 1 组

#### 总结

直接映射的只能映射到 Cache 中的**某一固定行**；全相联映射可以映射到**所有 Cache 行**；N 路组相联映射可以映射到 **N 行**

当 Cache 大小、主存块大小一定时：

1. 直接映射的**命中率最低**，全相联映射的**命中率最高**
2. 直接映射的**判断开销最小**、所需时间最短，全相联映射的**判断开销最大**、所需时间最长
3. 直接映射标记所占的**额外空间开销最少**，全相联映射标记所占的**额外空间开销最大**

#### 例子

假设某个计算机的主存地址空间大小为 `256MB`，按字节编址，其数据 Cache 有 8 个 Cache 行，行长为 `64B`

1. 若**不考虑**用于 Cache 的**一致维护性和替换算法控制位**，并且采用直接映射方式，则该数据 Cache 的总容量为多少？
2. 若该 Cache 采用直接映射方式，则主存地址为 3200（十进制）的主存块对应的 Cache 行号是多少？采用二路组相联映射时又是多少？

解答：

1. Cache 的总容量是**存储容量 + 标记矩阵容量**，其中**标记矩阵（地址映射表）**包含存储器地址进行跟踪的信息

   `256MB` 有 28 位主存地址，`64B` 是 6 位块内地址，8 是 3 位行号，所以标记长度是 28 - 6 - 3 = 19 位

   **有效位为 1 位**，行长 `64B` 是 512 位，则总容量是 $8\times(1+19+512)=4256$ 位

   注意：每个 Cache 行对应一个标记项，包含**有效位、标记位、一致性维护位（写回法用）、替换算法控制位**

2. 主存的字块号是 `3200B / 64B = 50`，直接映射的行号为 50 mod 8 = 2；二路组相联映射的组号为 `50 mod 4 = 2`，行号为 4 或 5

### Cache 中主存储块的替换算法

主存向 Cache 传送一个新块，但没地方放这个新块时：

1. 全相联映射、组相联映射：**需要使用替换算法置换 Cache 行**
2. 直接映射：只对应一个块位置，莫得选择，直接替换，**不需要替换算法**

常用的替换算法有（近期最少用 LRU 算法最常考）：

1. 随机算法 RANG：**随机地确定替换的 Cache 块**，实现比较简单，但未依据程序访问的局部性原理，可能**命中率较低**

2. 先进先出算法 FIFO：**选择最早调入的行进行替换**，比较容易实现，但未依据程序访问的局部性原理，可能**命中率较低**

3. 近期最少使用算法 LRU：依据程序访问的局部性原理，**选择近期内长久未访问过的 Cache 行作为替换的行**，平均命中率要比 FIFO 的高，是堆栈类算法

   **计数值的位数与 Cache 组大小有关**：2 路时有一位 LRU 位，4 路时有两位 LRU 位（log）

   图中左边阴影的数字是对应 Cache 行的计数值，右边的数字是存放在该行中的主存块号

   ![image-20211015205045837](..\images\image-20211015205045837.png)

   计数器的变化规则：

   1. 命中时，所**命中的行的计数器清零**，比最大值低的计数器加 1，其余不变
   2. 未命中且还有空闲行时，**新装入的行的计数器置 0**，其余全加 1
   3. 未命中且无空闲行时，**计数值为最大值的行的信息块被淘汰**，新装行的块的计数器置 0，其余全加 1

   当**集中访问的存储区超过 Cache 组的大小时，命中率可能变得很低**，如上例的访问序列变为 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …，而 Cache每组只有 4 行，那么命中率为 0，这种现象称为抖动

4. 最不经常使用算法 `LFU`：将一段时间内被访问次数最少的存储行换出

   每行也设置一个计数器，新行建立后从 0 开始计数，每访问一次，被访问的行计数器加 1，需要**替换时比较各特定行的计数值，将计数值最小的行换出**

提示：手算时可以把每个组作为一个队列，优先级高（要换）的元素放在队头，优先级低的在队尾，换块时取出队头元素，把新块按它的优先级插入队列

注意：**当 Cache 为空时，读入数据算未命中**；以及 a[i]++ 时会对 a[i] 读了一次，又写了一次，所以对 Cache 访问了两次

### Cache 写策略

因为 Cache 中的内容是主存块副本，当对 Cache 中的内容进行更新时就需选用写操作策略使 Cache 内容和主存内容保持一致

现代计算机的 Cache 通常设立多级 Cache（通常为 3 级），假定设 3 级 Cache

按离 CPU 的远近可各自命名为 L1 Cache、L2 Cache、L3 Cache，**离 CPU 越远，访问速度越慢，容量越大**

指令 Cache 与数据 Cache 分离一般在 L1 级，此时通常为写分配法与写回法合用

选择题：采用指令 Cache 与数据 Cache 分离的主要目的是**减少指令流水线资源冲突**，取指和取数在不同 Cache 中寻找，不会发生冲突

#### 写命中时

1. 全写法（写直通法 write-through）：

   当 CPU 对 Cache 写命中时，必须**把数据同时写入 Cache 和主存**，**替换时不需要写回内存**

   优点：这种方法实现简单，能随时保持主存数据的正确性；缺点：是增加了访存次数，降低了Cache 的效率

   写缓冲：为减少全写法直接写入主存的时间损耗，在 Cache 和主存之间加一个写缓冲（Write Buffer）

   ![image-20211015212043863](..\images\image-20211015212043863.png)

   CPU **同时写数据到 Cache 和写缓冲中**，写缓冲再控制将内容写入主存

   写缓冲是一个 FIFO 队列，写缓冲可以解决速度不匹配的问题；但若出现**频繁写时，会使写缓冲饱和溢出**

   为了防止写缓存溢出，还可以在 Cache 和 DRAM 中再加一个更大的 L2 Cache，L2 与内存使用写回法

2. 写回法 write-back：

   当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而**不立即写入主存**，只有**当此块被换出时才写回主存**

   这种方法减少了访存次数，但存在不一致的隐患，采用这种策略时，每个 Cache 行**必须设置一个标志位（脏位）**，以反映此块**是否被 CPU 修改过**

#### 写不命中

1. 写分配法 write-allocate：

   先**加载主存中的块到 Cache 中**，然后更新这个 Cache 块

   它试图**利用程序的空间局部性**，但缺点是每次不命中都需要从主存中读取一块

2. 非写分配法 not-write-allocate：**只写入主存，不进行调块**

**非写分配法通常与全写法**合用，**写分配法通常和写回法**合用

### 综合应用题

某 32 位计算机，CPU主频为 `800MHz`，Cache 命中时的 CPI 为 4，Cache 块大小为 `32B`；主存采用 **8 体交叉存储**方式，每个体的存储字长为 32 位、存储周期为 `40ns`；存储器总线宽度为 32 位，总线时钟频率为 `200MHz`，支持突发传送总线事务。**每次读突发传送总线事务的过程包括：送首地址和命令、存储器准备数据、传送数据**。每次突发传送 `32B`，传送地址或 32 位数据均需要一个总线时钟周期。请回答下列问题，要求给出理由或计算过程。

1. CPU 和总线的时钟周期各为多少？总线的带宽（即最大数据传输率）为多少？
2. Cache 缺失时，需要用几个读突发传送总线事务来完成一个主存块的读取？
3. 存储器总线完成一次读突发传送总线事务所需的时间是多少？
4. 若程序 `BP` 执行过程中共执行了 100 条指令，平均每条指令需进行 1.2 次访存，Cache 缺失率为 5%，不考虑替换等开销，则 `BP` 的 CPU 执行时间是多少？

解答：

1. CPU 的时间周期是 `1s / 800MHz = 1.25ns`，总线的时间周期是 `1s / 200MHz = 5ns`；总线带宽为 `4B × 1s / 0.5ns = 800MB/s`

2. Cache 一块是 `32B` 而一次读突发传送总线事务也是 `32B`，所以仅需要一次

3. 题目仅给出存储周期，没有给存储时间，所以存储器**经过存储时间后才把数据发给总线**

   题目给的过程：送首地址和命令 `5ns` + 存储器准备数据 `40ns + (8 - 1)5ns` + 传送数据（最后一次非重叠 `5ns`）= `85ns`

   注意：要看题目给的信息，存储周期分为存储时间和恢复时间，其实在存储时间就可以拿到数据

4. 因为题目没有给出详细的执行时间信息，所以 Cache 不命中时是**先从内存放入 Cache 再访问 Cache 的模式**

   时间是：基本执行时间（`4 × 1.25ns × 100 = 500ns`）+ 内存入 Cache 时间（`100 × 120% × 5% × 85ns = 505ns`）= `1010ns`

## 虚拟存储器

**主存**和联机工作的**辅存**共同**构成了虚拟存储器**，二者在**硬件和系统软件**的共同管理下工作

对于**应用程序员**而言，虚拟存储器是透明的，虚拟存储器具有主存的速度和辅存的容量，提高了存储系统的性价比

### 虚拟存储器的基本概念

虚拟存储器将**主存和辅存的地址空间统一编址**，构造出庞大的地址空间，用户可以自由编程，不必关心实际容量和位置

用户编程允许涉及的地址称为**虚地址或逻辑地址**，虚地址对应的存储空间称为虚拟空间或程序空间

实际的主存单元地址称为**实地址或物理地址**，实地址对应的是主存地址空间，也称实地址空间，**虚地址比实地址要大很多**

![image-20211016191644899](..\images\image-20211016191644899.png)

CPU 使用虚地址：

1. 由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存
2. 若已在主存中，则通过地址变换，CPU 可直接访问主存指示的实际单元
3. 若不在主存中，则把包含这个字的一页或一段调入主存后再由 CPU 访问
4. 若主存已满，则采用替换算法置换主存中的一页或一段

思考：当运行一个很大的程序时，加载需要的部分，其他部分等使用时再加载进内存

### 页式虚拟存储器

#### 页表

**以页为基本单位**的虚拟存储器称为**页式虚拟存储器**，虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页

虚拟地址分为两个字段：**虚页号和页内地址**，虚拟地址到物理地址的转换是由页表实现的

页表是**虚页号和实页号的对照表**，它长久地存放在主存中，记录程序的**虚页调入主存时被安排在主存中的位置**

![image-20211016200155455](..\images\image-20211016200155455.png)

- **有效位**也称装入位，用来表示**对应页面是否在主存**

  若为 1，表示该虚拟页已调入主存，**存放该页的物理页号（页框号）**

  若为 0，表示没有调入主存，可能**存放该页的磁盘地址**

- **脏位**也称修改位，用来表示**页面是否被修改**过，虚存机制中采用回写策略

- **引用位**也称使用位，用来**配合替换策略进行设置**

![image-20211016201215954](..\images\image-20211016201215954.png)

CPU 执行指令时，需要先**将虚拟地址转换为主存物理地址**：

- 每个进程都有一个**页表基址寄存器**，存放该进程的**页表首地址**
- 根据虚拟地址高位部分（虚拟页号）找到对应的页表项
- 若装入位为 1，则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址
- 若装入位为 0，则说明缺页，需要操作系统进行缺页处理

优点：页面的长度固定，页表简单，调入方便；缺点：由于程序不可能正好是页面的整数倍，**最后一页的零头将无法利用而造成浪费**，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便

选择题：把虚拟地址转换为物理地址给 CPU 寻址，找不到对应的内存会发出错误，就知道是缺页了

#### 快表（TLB）

依据程序执行的局部性原理，把常用页对应的**页表项**存放在**高速缓冲器**组成的**快表**（TLB）中，则可以**明显提高效率**；相应地把放在**主存中的页表称为慢表**（Page）

在地址转换时，首先查找快表，若命中，则无须访问主存中的页表，快表通常采用**全相联或组相联方式**

每个 TLB 项由**页表表项内容**加上一个 **TLB 标记字段**组成，TLB 标记用来表示**该表项取自页表中哪个虚页号对应的页表项**

TLB 标记的内容：

- 在全相联方式下就是该**页表项对应的虚页号**
- 组相联方式下则是**对应虚页号的高位部分**，而虚页号的低位部分用于选择 TLB 组的组索引

#### TLB + Cache 的多级存储系统

![image-20211016203535295](..\images\image-20211016203535295.png)

这是两级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项

Cache 采用二路组相联方式，TLB 采用全相联方式，每一项都有一个比较器，下面是地址转换过程：

1. 首先根据虚页号**与每个 TLB 标记字段比较**，若某项相等且有效位为 1，则直接转换成物理地址
2. 若未命中，首先根据高 10 位在页目录**找到页表的地址**，然后根据中 10 位在页表**拿到对应的物理地址**
3. 把虚拟号和物理地址**加入 TLB 表**，如果表满就使用某个替换算法进行替换
4. 拿到物理地址后，要使用之前的 Cache 映射的方法进行获取数据

![image-20211016204929942](..\images\image-20211016204929942.png)

**快表和慢表也可以同步进行**，若快表中有此虚页号，使慢表的查找作废；可以做到**访问主存速度几乎没有下降**

在一个具有 Cache 和 TLB 的虚拟存储系统中，CPU 一次访存操作可能涉及 TLB、页表、Cache、主存和磁盘的访问

CPU 访存过程中存在三种缺失情况：

1. TLB 缺失：要访问的页面对应的**页表项不在 TLB 中**
2. Cache 缺失：要访问的**主存块不在 Cache 中**
3. 缺页 Page：要访问的**页面不在主存中**

![image-20211016210034587](..\images\image-20211016210034587.png)

- 最好的情况是第 1 种组合，此时无须访问主存
- 第 2 种和第 3 种组合都需要访问一次主存
- 第 4 种组合需要访问两次主存
- 第 5 种组合发生缺页异常，需要访问磁盘，并且至少访问两次主存

**Cache 缺失处理由硬件完成**；**缺页处理由软件完成**，操作系统通过**缺页异常处理程序**来实现；而 **TLB 缺失可用硬件或软件处理**，比如操作系统有 TLB 缺失异常处理程序

注意：计算 **TLB 的标记长度等**和**虚拟地址长度**有关，而计算 **Cache 的标记长度等**和**物理地址长度**有关，注意区分

### 段式虚拟存储器

段式虚拟存储器中的段是**按程序的逻辑结构划分**的，各个段的长度因程序而异；**把虚拟地址分为段号和段内地址**

虚拟地址到实地址之间的变换是由段表来实现的，段表是程序的逻辑段和在主存中存放位置的对照表

![image-20211016211845324](..\images\image-20211016211845324.png)

段表的每行记录包含**段号、装入位、段起点、段长**等信息；**段的长度可变**，要给出各段的起始地址与段的长度

CPU 根据虚拟地址访存：

1. 首先根据段号与段表基地址拼接成对应的段表行
2. 根据该段表行的装入位判断该段是否已调入主存（1 在，0 不在）
3. 已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址

优点：段的分界与程序的自然分界相对应，**具有逻辑独立性，易于编译、管理、修改和保护，也便于多道程序的共享**

缺点：因为段长度可变，分配空间不便，**容易在段间留下碎片**，不好利用，造成浪费

### 段页式虚拟存储器

段页式虚拟存储器：把程序按逻辑结构分段，每段再划分为固定大小的页，对主存的调入、调出**仍以页为基本传送单位**

每个程序对应一个段表，每段对应一个页表，**段的长度必须是页长的整数倍**，段的**起点必须是某一页的起点**

**虚地址分为段号、段内页号、页内地址三部分**

CPU 根据虚地址访存：

1. 首先根据段号得到段表地址
2. 从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址
3. 从页表中取出实页号，与页内地址拼接形成主存实地址

优点：**兼具页式和段式虚拟存储器的优点**，可以按段实现共享和保护

缺点：在地址变换过程中需要两次查表，**系统开销较大**

### 虚拟存储器与 Cache 的比较

#### 相同之处

1. 最终目标**都是为了提高系统性能**，两者都有容量、速度、价格的梯度
2. **都把数据划分为小信息块**，并作为基本的传递单位，虚存系统的信息块更大
3. <u>都有地址的映射、替换算法、更新策略等问题</u>
4. 依据程序的局部性原理应用**快速缓存的思想**，将活跃的数据放在相对高速的部件中

#### 不同之处

1. Cache 主要解决**系统速度**，而虚拟存储器却是为了解决**主存容量**
2. Cache 全由硬件实现，是**硬件存储器**；而虚拟存储器由 OS 和硬件共同实现，是**逻辑上的存储器**（OS 程序员可见）
3. 对于不命中性能影响，**虚拟存储器系统不命中时对系统性能影响更大**（Cache/主存 < 主存/硬盘）
4. CPU 与 Cache 和主存都建立了直接访问的通路，而**辅存与 CPU 没有直接通路**（必须先装入主存）

## 易混知识点

1. 在虚拟存储器中，页面是设置得大一些好还是设置得小一些好？

   页面**不能设置得过大，也不能设置得过小**

   页面太小时，平均页内剩余空间较少，但**页表会增大**，且不能**充分利用访存的空间局部性**来提高命中率

   页面太大时，可减少页表空间，但平均**页内剩余空间较大**，页面太大还会使**页面调入/调出的时间较长**

2. 存取时间 $T_a$ 就是存储周期 $T_m$ 吗？

   存取时间 $T_a$ 是执行一次读操作或写操作的时间，分为读出时间和写入时间

   1. 读出时间是从主存接收到有效地址开始到数据稳定为止的时间
   2. 写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间

   存储周期 $T_m$ 是指存储器进行连续两次独立地读或写操作所需的最小时间间隔

   所以**存取时间 $T_a$ 不等于存储周期 $T_m$**，通常**存储周期 $T_m$ 大于存取时间 $T_a$**

3. 发生取指令 Cache 缺失的处理过程是什么？

   1. 程序计数器恢复当前指令的值
   2. 对主存进行读的操作
   3. 将读入的指令写入 Cache 中，更改有效位和标记位
   4. 重新执行当前指令

# 指令系统

## 指令格式

指令（机器指令）是指示计算机执行某种操作的命令

一台计算机的**所有指令的集合**构成该机的**指令系统**，也称指令集

指令系统是计算机的主要属性，位于**硬件和软件的交界面上**

### 指令的基本格式

一条指令就是机器语言的一个语句，一条指令通常包括**操作码字段** + **地址码字段**：

- 操作码：该指令应**该执行什么性质的操作**以及具有何种功能

  操作码是**识别指令、了解指令功能**及**区分操作数地址**内容的组成和使用方法等的关键信息

- 地址码：给出**被操作的信息（指令或数据）的地址**，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等

关于指令的长度有：

- 指令的长度是指一条指令中所包含的**二进制代码的位数**
- 指令字长取决于**操作码的长度、操作数地址码的长度、操作数地址的个数**
- 指令长度与机器字长**没有固定的关系**，它可以等于机器字长，也可以大于或小于机器字长
- 指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令

若所有**指令的长度都是相等的**，则称为**定长指令字结构**，定字长指令的执行速度快，控制简单

若各种**指令的长度随指令功能而异**，则称为**变长指令字结构**

- 注意区分**定长指令字、变长指令字、定长操作码，变长操作码**之间的区别

因为主存一般是按字节编址的，所以**指令字长多为字节的整数倍**

#### 零地址指令

**只给出操作码 OP**，没有显式地址，这种指令有两种可能：

1. **不需要操作数的指令**，如空操作指令、停机指令、关中断指令等
2. **零地址运算类指令**仅用在**堆栈计算机**中，**操作数隐含地从栈弹出**，运算完再**隐含地压入堆栈**

#### 一地址指令

有操作码 OP + 一个操作数地址 $A_1$，同样有两种可能：

1. 只有**目的操作数**的单操作数指令：

   按 $A_1$ 地址读取操作数，进行 OP 操作后，结果存回原地址

   指令含义：$OP(A_1)→A_1$，如操作码含义是加 1、减 1、求反、求补等

2. **隐含约定目的地址**的双操作数指令：

   按指令地址 $A_1$ 可读取源操作数，**另一个操作数由累加器 ACC 提供**，运算**结果存放在 ACC 中**

   指令含义：$(ACC)OP(A_1)→ACC$，若指令字长为 32 位，操作码占 8 位，则 1 个地址码字段占 24 位，寻址 $2^{24}$

#### 二地址指令

有操作码 OP + 两个操作数地址 $A_1,A_2$

指令含义：$(A_1)OP(A_2)→A_1$，给出**目的操作数**和**源操作数**的地址，其中**目的操作数地址**用于**保存运算结果**

若指令字长为 32 位，操作码占 8 位，两个地址码字段各占 12 位，寻址 $2^{12}$

#### 三地址指令

有操作码 OP + 三个操作数地址 $A_1,A_2,A_3$

指令含义：$(A_1)OP(A_2)→A_3$，**第三个操作数地址**用于**保存运算结果**

若指令字长为 32 位，操作码占 8 位，3 个地址码字段各占 8 位，寻址 $2^8$

若地址字段均为主存地址，则完成一条三地址需要 4 次访问存储器，取指令 1、取两操作数 2、放结果 1

#### 四地址指令

指令含义：$(A_1)OP(A_2)→A_3,A_4=下一条将要执行指令的地址$

若指令字长为 32 位，操作码占 8 位，4 个地址码字段各占 6 位，寻址 $2^6$

### 定长操作码指令格式

定长操作码指令在指令字的最高位部分分配**<u>固定</u>的若干位（定长）表示操作码**

一般 n 位操作码字段的指令系统最大**能够表示 $2^n$ 条指令**

定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利

当计算机字长为 32 位或更长时，这是常规用法

### 扩展操作码指令格式

为了在指令字长有限的前提下仍**保持比较丰富的指令种类**，可采取可变长度操作码，即**操作码字段的位数不固定**，且分散地放在指令字的不同位置上，这将增加指令译码和分析的难度，使控制器的设计复杂化

最常见的变长操作码方法是**扩展操作码**，它使操作码的**长度随地址码的减少而增加**，从而在满足需要的前提下，**有效地缩短指令字长**

![image-20211017202900865](..\images\image-20211017202900865.png)

指令字长为 16 位，其中 4 位为操作码 OP，另有 3 个 4 位长的地址，操作码定长则只有 16 条指令

如果使用扩展操作码：

1. 三地址指令为 15 条，1111 留作扩展操作码之用
2. 二地址指令为 15 条，1111 1111 留作扩展操作码之用
3. 一地址指令为 15 条，11111111 1111 留作扩展操作码之用
4. 零地址指令为 16 条
5. 这就<u>从定长指令定长操作的 16 条指令变成定长指令不定长操作的 61 条指令</u>

还有其他多种扩展方法，如 15 条三地址指令、12 条二地址指令、63 条一地址指令和 16 条零地址指令，共 106 条指令

在设计扩展操作码指令格式时，必须注意以下两点:

1. **不允许短码是长码的前缀**，即短操作码不能与长操作码的前面部分的代码相同
2. 各指令的**操作码一定不能重复**

也可以对使用**频率较高的指令分配较短的操作码**，对使用**频率较低的指令分配较长的操作码**，减少指令译码和分析的时间

### 指令的操作类型

1. 数据传送：通常有**寄存器之间的传送**、从**内存单元到 CPU 寄存器**、从 **CPU 寄存器写数据到内存单元**等

2. 算术和逻辑运算：主要有加、减、比较、乘、除、加 1、减 1、与、或、取反、异或等

3. 移位操作：移位指令主要有**算法移位、逻辑移位、循环移位**等

4. 转移操作（程序控制类指令）：

   转移指令主要有**无条件转移、条件转移、调用、返回、陷阱**等

   1. 无条件转移指令：在任何情况下都执行转移操作
   2. 而条件转移指令：在特定条件满足时才执行转移，转移条件一般是某个标志位的值，或两个或两个以上的标志位组合
   3. 调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行

5. 输入输出操作：用于完成 CPU 与**外部设备交换数据**或**传送控制命令及状态信息**

选择题：**中断隐指令**是由硬件实现的，并**不是指令系统中存在的指令**，更不可能属于程序控制类指令

选择题：特权指令是指**仅用于操作系统或其他系统软件的指令**，为确保系统与数据安全起见，这类指令**不提供给用户使用**

### 综合应用题

题目：一处理器中共有 32 个寄存器，使用 16 位立即数，其指令系统结构中共有 142 条指令。**在某个给定的程序中**，20% 的指令带有一个输入寄存器和一个输出寄存器；30% 的指令带有两个输入寄存器和一个输出寄存器；25% 的指令带有一个输入寄存器、一个输出寄存器、一个立即数寄存器；其余 25% 的指令带有一个立即数输入寄存器和一个输出寄存器

1. 对于以上 4 种指令类型中的任意一种指令类型来说，共需要多少位？指令系统结构要求所有指令长度必须是 8 的整数倍
2. 与使用定长指令集编码相比，当采用变长指令集编码时，该程序能够少占用多少存储器空间？

解答：

1. 因为无法计算不定长操作码，所以这里计算定长操作码，142 条指令需要 7 位（答案写 8 位），32 个寄存器需要 5 位，16 位立即数需要 16 位
   1. 一个输入寄存器和一个输出寄存器：7 + 5 + 5 = 17 对齐后为 24
   2. 两个输入寄存器和一个输出寄存器：7 + 5 + 5 + 5 = 22 对齐后为 24
   3. 一个输入寄存器、一个输出寄存器、一个立即数寄存器：7 + 5 + 5 + 16 = 33 对齐后 40
   4. 一个立即数输入寄存器和一个输出寄存器：7 + 16 + 5 = 28 对齐后 32
2. 由于最长是 40 位，所以定长要使用 40 位；变长时 20% × 24 + 30% × 24 + 25% × 40 + 25% × 32 = 30 少用了 25% 的空间

## 指令的寻址方式

### 指令寻址和数据寻址

寻址方式是指**寻找指令或操作数有效地址的方式**，即确定本条指令的数据地址及下一条待执行指令的地址的方法

指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址（A），可以是**寄存器编号**或者**内存地址**

形式地址结合寻址方式，可以计算出**操作数在存储器中的真实地址**，这种地址称为**有效地址**（EA）

寻址方式分为**指令寻址**和**数据寻址**两大类：寻找下一条将要执行的指令地址称为指令寻址；寻找操作数的地址称为数据寻址

- 注意：在做题时，要注意看要求出的是有效地址还是操作数，有效地址是操作数的地址

#### 指令寻址

指令寻址方式有两种：一种是**顺序寻址方式**，另一种是**跳跃寻址方式**

1. 顺序寻址：通过程序计数器（PC）加 1 个指令字长，**自动形成下一条指令的地址**

2. 跳跃寻址通过转移类指令实现：

   所谓跳跃，是指下条指令的地址码不由程序计数器给出，而**由本条指令计算出下条指令地址**

   注意：状态寄存器和操作数可以控制是否跳跃，而跳跃到的地址分为绝对地址和相对地址，跳跃的结果是当前指令修改 PC 值，所以下一条指令仍然通过程序计数器给出

#### 数据寻址

数据寻址是指**如何在指令中表示一个操作数的地址**，如何用这种表示得到操作数或**怎样计算出操作数的地址**

数据寻址的方式较多，通常在指令字中**设一个字段来指明属于哪种寻址方式**，由此可得指令的格式如下所示：

![image-20211018161851931](..\images\image-20211018161851931.png)

选择题：采用不同寻址方式的目的是<u>缩短指令字长，扩大寻址空间，提高编程的灵活性</u>，但也<u>提高了指令译码的复杂度</u>

### 常见的数据寻址方式

#### 隐含寻址

这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址

![image-20211018162301445](..\images\image-20211018162301445.png)

例如，规定累加器（ACC）作为第二操作数地址，，累加器（ACC）对单地址指令格式来说是隐含寻址

隐含寻址的优点是有利于**缩短指令字长**；缺点是**需增加存储操作数或隐含地址的硬件**

#### 立即（数）寻址

这种类型的指令的地址字段指出的是**操作数本身**，又称立即数，数据采用**补码形式存放**

![image-20211018163109172](..\images\image-20211018163109172.png)

立即寻址的优点是指令在**执行阶段不访问主存**，指令执行时间最短；缺点是 **A 的位数限制了立即数的范围**

注意：在定长指令字时，立即数取址执行速度最快；但在变长指令字时，寄存器寻址执行速度最快，因为读代码也要时间

#### 直接寻址

指令字中的形式地址 A 是操作数的真实地址 EA，即 **EA = A**

![image-20211018163554498](..\images\image-20211018163554498.png)

直接寻址的优点是简单，指令在执行阶段仅访问一次主存，**不需要专门计算操作数的地址**；缺点是 **A 的位数决定了该指令操作数的寻址范围**，操作数的地址不易修改

#### 间接寻址

间接寻址是指，指令的地址字段给出的形式地址是**操作数有效地址所在的存储单元的地址**，即 **EA =(A)**

间接寻址可以是一次间接寻址，还可以是多次间接寻址

![image-20211018163908663](..\images\image-20211018163908663.png)

主存字第一位为 1 时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为 0 时，表示取得的是操作数的地址

优点：可**扩大寻址范围**（有效地址 EA 的位数大于形式地址 A 的位数），便于**编制程序**（方便地完成子程序返回）

缺点：指令在执行阶段要**多次访存**，由于访问速度过慢，这种寻址方式并不常用

注意：一般问到**扩大寻址范围**时，通常指的是**寄存器间接寻址**

#### 寄存器寻址

寄存器寻址是指在指令字中直接**给出操作数所在的寄存器编号**，即 $EA=R_i$，其操作数在由 $R_i$ 所指的寄存器内

![image-20211018164727093](..\images\image-20211018164727093.png)

优点：指令在执行阶段不访问主存，只访问寄存器，**指令字短且执行速度快**，支持向量 / 矩阵运算

缺点：寄存器价格昂贵，计算机中的**寄存器个数有限**

#### 寄存器间接寻址

寄存器间接寻址是指在寄存器 $R_i$ 中给出的是**操作数所在主存单元的地址**，即 $EA= (R_i)$

![image-20211018165205933](..\images\image-20211018165205933.png)

寄存器间接寻址的特点：比一般间接寻址**速度更快**，但指令的执行阶段需要访问主存

#### 相对寻址

相对寻址是把程序计数器 PC 的内容加上形式地址 A 而形成操作数的有效地址，即 **EA = (PC) + A**，其中 **A 是相对于当前指令地址的位移量**，可正可负，补码表示

![image-20211018165506048](..\images\image-20211018165506048.png)

操作数的地址**随 PC 值的变化而变化**，且与指令地址之间总是相差一个固定值，因此**便于程序浮动**，广泛应用于**转移指令**

注意：**读完指令后 PC 会增加**，转移时**根据增加后的 PC 来转移**，如 `JMP A` 指令地址为 X 长度 `2B`，则会跳到 X + 2 + A 处；要**注意编址方式**，PC 增加的值和编址方式有关，如一个字 16 位，按字编址，那么去 `2B` 长的指令 PC 才加 1

选择题：在多道程序设计中，各个程序段被加载的内存是浮动的，当程序的存放区域被改变，要求其执行不受影响，使用相对地址可以实现

#### 基址寻址

基址寻址是指将 CPU 中基址寄存器（BR）的内容加上形式地址 A 而形成操作数的有效地址，即 **EA=(BR)+ A**

其中基址寄存器既**可采用专用寄存器**，又**可采用通用寄存器**

![image-20211018182504834](..\images\image-20211018182504834.png)

基址寄存器是面向操作系统的，**内容由操作系统或管理程序确定**，用于解决程序逻辑空间与存储器物理空间的无关性

在程序执行过程中，**基址寄存器的内容不变**（作为基地址），**形式地址可变**（作为偏移量）

采用通用寄存器作为基址寄存器时，可**由用户决定哪个寄存器作为基址寄存器**，但其**内容仍由操作系统确定**

优点：可**扩大寻址范围**；用户不必考虑自己的程序存于主存的哪个空间区域，因此**有利于多道程序设计**，并可用于**编制浮动程序**，但偏移量（形式地址 A）的位数较短

思考：基址就是一个程序的基地址，程序内的每个数据都是根据基地址来寻址的，当程序装入不同内存变了改一下基址就行

思考：基址在自己为主程序上使用，而相对寻址在本程序映射到其他程序时用（如 dll 文件），两者没有冲突可以一起使用

#### 变址寻址

变址寻址是指有效地址 EA 等于**形式地址 A 与变址寄存器 IX 的内容之和**，即 **EA = (IX) + A**，其中 IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器

![image-20211018183938571](..\images\image-20211018183938571.png)

变址寄存器是**面向用户**的，变址寄存器的内容可由用户改变，**形式地址 A 不变**，偏移量的位数足以表示整个存储空间

优点：可**扩大寻址范围**；可令 A 为数组的首地址，变址寄存器 IX 为数组的索引；特别适合编制循环程序

基址寻址**面向系统**，主要用于**为多道程序或数据分配存储空间**，内容通常由操作系统或管理程序确定，**其值不可变**，指令字中的 A 是可变的

变址寻址**立足于用户**，主要用于处理**数组问题**，变址寄存器的内容由用户设定，**其值可变**，而指令字中的 A 是不可变的

#### 堆栈寻址

堆栈是存储器中一块特定的、**按后进先出原则管理的存储区**，读/写单元的地址用一个特定的寄存器给出称为堆栈指针

堆栈可分为硬堆栈与软堆栈两种：

1. **寄存器堆栈**又称硬堆栈，寄存器堆栈的成本较高，不适合做大容量的堆栈
2. **从主存中划出一段区域**来做堆栈是**最合算且最常用**的方法，这种堆栈称为软堆栈

堆栈结构的计算机系统中，大部分指令表现为**无操作数指令**，因为其操作数都通过堆栈寄存器**隐含使用了堆栈**

如 `ADD` 加法指令就是从堆栈中弹出两个操作数，运算完后再把结果压入堆栈

#### 总结

当然这些寻址也可以进行复合，如先间址再变址，把里面的 EA 看成外面的 A，间址 EA = (A) 再变址 EA = (A) + (IX)

![image-20211018185202626](..\images\image-20211018185202626.png)

## 程序的机器级代码表示

### 常用汇编指令介绍

#### 相关寄存器

X86 处理器中有 **8 个 32 位的通用寄存器**，为了向后兼容 `EAX、EBX、ECX、EDX` 的**高低两位字节可以独立使用**，E 为 Extended 表示 32 位的寄存器，寄存器的**名称与大小写无关**，既可以用 `EAX`，又可以用 `eax`

![image-20211018190206522](..\images\image-20211018190206522.png)

除 `EBP` 和 `ESP` 外（用于堆栈不可乱用），其他几个寄存器的用途是比较任意的

#### 汇编指令格式

一般有两种不同的汇编格式 AT&T 格式和 Intel 格式，主要的区别如下：

1. AT&T **只能用小写字母**，而 Intel 对**大小写不敏感**

2. AT&T 第一个为源操作数，第二个为目的操作数，方向**从左到右**

   Intel 第一个为目的操作数，第二个为源操作数，方向**从右向左**

3. AT&T **寄存器前缀 %，立即数前缀 $**；而 Intel 都**不需要加前缀**

4. **内存寻址**时，AT&T 格式使用 ( 和 )，而 Intel 格式使用 [ 和 ]

5. 处理复杂寻址方式时：AT&T 格式 `disp(base, index, scale)` 意义为 **偏移量(基址寄存器, 变址寄存器, 比例因子)**

   如 `8(%edx, %eax, 2)`表示操作数为 `((edx) + (eax) * 2 + 8)`；**Intel 格式的操作数为 `[edx + eax * 2 + 8]`**

6. 指定数据长度方面：AT&T **操作码的后面紧跟一个字符，表明操作数大小**，b 表示字节、w 表示字、l 表示双字

   Intel 在操作码后面**显式地注明** `byte ptr`、`word ptr`、`dword ptr`

![image-20220607154334638](..\images\image-20220607154334638.png)

#### 寻址模式和内存分配

##### 寻址模式

X86 提供了一种灵活的内存寻址方式，如 mov 用于在内存和寄存器之间移动数据，第一个是目的地址，第二个是源地址

注意：最多只能利用**两个** 32 位寄存器和一个 32 位的有符号常数**相加**计算出一个内存地址

```assembly
mov eax, [ebx]  ;将 ebx 值指示的内存地址中的 4 子节传送到 eax
mov [var], ebx  ;将 ebx 值传送到 var 的值指示的内存地址中
mov eax, [esi - 4]  ;将 esi - 4 值指示的内存地址中的 4 字节传送到 eax
mov [esi + eax], cl  ;将 cl 值传送到 esi + eax 值指示的内存地址中
mov edx, [esi + 4 * ebx]  ;将 esi + 4 * ebx 值指示的内存中的 4 字节传送到 edx

mov eax, [ebx - ecx]  ;错误，只能用加法
mov [eax + esi + edi], ebx  ;错误，最多只能有两个寄存器参与运算
```

##### 数据类型长度规定

汇编语言中声明内存大小时，一般显式地使用 `DB（Data Byte)、DW（Word，2Bytes）、DD（Double Word，4Bytes）`分配内存

为了**区分常数 2 的占位**，X86 提供了三个指示规则标记，分别为 `BYTE PTR、WORD PTR、DWORD PTR`

```assembly
a:db 0  ;分配单字节内存
b:dw 0  ;分配双字节内存
c:dd 0  ;分配四字节内存

mov byte ptr [ebx], 2  ;将 2 以单字节形式传送到 ebx 值指示的内存地址中
mov word ptr [eb×], 2  ;将 2 以双字节形式传送到 ebx 值指示的内存地址中
mov dword ptr [ebx], 2  ;将 2 以四字节形式传送到 ebx 值指示的内存地址中
```

#### 常用命令

汇编指令通常可以分为数据传送指令、逻辑计算指令和控制流指令，以下用于操作数的标记分别表示寄存器、内存和常数

1. \<reg>：表示任意寄存器，若其后带有数字，则指定其位数

   \<`reg32`> 表示 32 位寄存器；\<`reg16`> 表示 16 位寄存器；\<`reg8`> 表示 8 位寄存器

2. \<`mem`>：表示内存地址

3. \<con>：表示 8 位、16 位或 32 位常数

   \<`con8`> 表示 8 位常数；\<`con16`> 表示 16 位常数；\<`con32`> 表示 32 位常数

对**同一指令的不同用途有多种编码方式**，比如 mov 指令就有 28 种机内编码，用于不同操作数类型或用于特定寄存器

```assembly
mov ax, <con16>  ;机器码为 B8H
mov al, <con8>  ;机器码为 BOH
```

应用题：可使用**溢出自陷指令**让 CPU 检查溢出标志 OF，如果溢出 OF = 1 就会调用**溢出异常处理程序**

##### 数据传送指令

1. mov 指令：将第二个操作数复制到第一个操作数，但不能用于直接从内存复制到内存

   ```assembly
   mov <reg>, <reg>
   mov <reg>, <mem>
   mov <mem>, <reg>
   mov <reg>, <con>
   mov <mem>, <con>
   
   mov eax, ebx
   mov byte ptr [var], 5  ;将 5 保存到 var 值指示的内存地址的一字节中
   ```

2. lea 指令：将一个内存地址加载到目的寄存器

   ```assembly
   lea eax, [ebx]  ;相当于 mov eax, ebx
   ```
   
2. push 指令：push 指令将操作数压入内存的栈，ESP 是栈顶，压栈前先将 ESP 值减 4，然后将操作数压入 ESP 指示的地址

   ```assembly
   push <reg32>
   push <mem>
   push <con32>
   
   push eax
   push [var]  ;将 var 值指示的内存地址的 4 字节值压栈
   ```

3. pop 指令：pop 指令执行的是出栈工作，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4

   ```assembly
   pop <reg32>
   pop <mem>
   
   pop edi
   pop [ebx]  ;弹出栈顶元素送到 ebx 值指示的内存地址的 4 字节中
   ```

##### 算术和逻辑运算指令

1. add/sub 指令：add 指令将两个操作数相加，相加的结果保存到第一个操作数中；sub 指令用于两个操作数相减，相减的结果保存到第一个操作数中

   ```assembly
   add <reg>, <reg> / sub <reg>, <reg>
   add <reg>, <mem> / sub <reg>, <mem>
   add <mem>, <reg> / sub <mem>, <reg>
   add <reg>, <con> / sub <reg>, <con>
   add <mem>, <con> / sub <mem>, <con>
   
   sub eax, 10
   add byte ptr [var], 10
   ```

2. inc/dec 指令：inc、dec 指令分别表示将操作数自加 1、自减 1

   ```assembly
   inc <reg> / dec <reg>
   inc <mem> / dec <mem>
   
   dec eax
   inc dword ptr [var]
   ```

3. `imul` 指令：带符号整数乘法指令，它有两种格式：

   1. 单操作数：将操作数乘 `eax` 结果放在 `edx:eax` 中
   1. 两个操作数：将两个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器
   2. 三个操作数：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器

   ```assembly
   imul <reg32>, <reg32>
   imul <reg32>, <mem>
   imul <reg32>, <reg32>, <con>
   imul <reg32>, <mem>, <con>
   
   imul eax, [var]  ;eax <- eax * [var]
   imul esi, edi, 25  ;esi <- edi * 25
   ```

   两个 32 位数值相乘，积是 64 位，若其高 33 位不是全为零（正）或全为一（负），就表示溢出，则 OF = 1

4. idiv 指令：带符号整数除法指令，只有一个操作数除数，被除数为 `edx:eax` 中的内容 64 位，商送到 `eax`，余数则送到 `edx`

   ```assembly
   idiv <reg32>
   idiv <mem>
   
   idiv ebx
   idiv dword ptr [var]
   ```

5. and/or/xor 指令：分别是逻辑与、逻辑或、逻辑异或指令，用于位操作，操作结里放在第个操作数中

   ```assembly
   and <reg>, <reg> / or <reg>, <reg> / xor <reg>, <reg>
   and <reg>, <mem> / or <reg>, <mem> / xor <reg>, <mem>
   and <mem>, <reg> / or <mem>, <reg> / xor <mem>, <reg>
   and <reg>, <con> / or <reg>, <con> / xor <reg>, <con>
   and <mem>, <con> / or <mem>, <con> / xor <mem>, <con>
   
   and eax, 0fH  ;eax &= 0x0f
   xor edx, edx  ;置 0
   ```

6. not 指令：位翻转指令，将操作数中的每一位翻转，即 0→1、1→0

   ```assembly
   not <reg>
   not <mem>
   
   not byte ptr [var]  ;将 var 值指示的内存地址的一字节的所有位翻转
   ```

7. neg 指令：取负指令

   ```assembly
   neg <reg>
   neg <men>
   
   neg eax  ;eax <- -eax
   ```

8. `shl/shr` 指令：`shl` 为逻辑左移，`shr` 为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数

   ```assembly
   shl <reg>, <con8> / shr <reg>, <con8>
   shl <mem>, <con8> / shr <mem>, <con8>
   shl <reg>, <cl> / shr <reg>, <cl>
   shl <mem>, <c1> / shr <mem>, <cl>
   
   shl eax, 1
   shr ebx, cl
   sal / sar  ;算术移位
   rol / ror  ;循环移位
   rcl / rcr  ;带CF循环移位
   ```

##### 控制流指令

X86 处理器维持着一个指令指针 IP 它**指向下一条指令的首地址**，当一条指令取出后，此指针自动指向下一条指令

IP 寄存器不能直接操作，但可以用控制流指令更新，通常用标签指示程序中的指令地址，可在任何指令前加入标签

```assembly
mov esi, [ebp + 8]
begin: xor ecx, ecx  ;标记，用于控制流指令的跳转
mov eax, [esi]
```

1. `jmp` 指令：控制 IP 转移到 label 所指示的地址

   ```assembly
   jmp <label>
   jmp begin  ;跳转到 begin 标记的指令执行
   ```

2. `jcondition` 指令：条件转移指令，它**依据处理机状态字中的一系列条件状态转移**（状态寄存器）

   ```assembly
   je <label> (jump when equal)
   jne <label> (jump when not equal)
   jz <label> (jump when last result was zero)
   jg <label> (jump when greater than)
   jge <label> (jump when greater than or equal to)
   jl <label> (jump when less than)
   jle <label> (jump when less than or equal to)
   
   cmp eax, ebx
   jle done ;如果 eax 的值小于等于 ebx 值，跳转到 done
   ```

3. `cmp` 指令：用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码，通常与 `jcondition` 搭配

   ```assembly
   cmp <reg>, <reg>
   cmp <reg>, <mem>
   cmp <mem>, <reg>
   cmp <reg>, <con>
   ```

4. call/ret 指令：用于实现子程序（过程、函数等）的调用及返回

   call 指令首先将当前执行指令地址的**下一个指令地址**入栈，然后无条件转移到由标签指示的指令

   ret 指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行

   ```assembly
   fun:
   mov eax, 0x6021  ;设置返回值
   ret  ;返回，跳转到栈定存放的地址
   
   call fun  ;将下面指令的地址入栈，跳转到 fun
   mov ebx, eax
   ```

### 过程调用的机器级表示

假定过程 P 调用者，调用过程 Q 被调用者，过程调用的执行步骤如下

1. P 将入口参数（实参）放在 Q 能访问到的地方
2. P 将返回地址存到特定的地方，然后将控制转移到 Q，由 call 指令实现
3. Q 保存 P 的现场，通用寄存器的内容，并为自己的非静态局部变量分配空间
4. 执行过程 Q
5. Q 恢复 P 的现场，将返回结果放到 P 能访问到的地方，并释放局部变量所占空间
6. Q 取出返回地址，将控制转移到 P，由 ret 指令返回

用栈来保存入口参数、返回地址、过程 Р 的现场、过程 Q 的局部变量、返回结果

寄存器 **EAX、ECX、EDX 是调用者保存寄存器**，其保存和恢复的任务由过程 Р 负责，Q 可以直接使用这三个寄存器

寄存器 **EBX、ESI、EDI 是被调用者保存寄存器**，Q 要先将它们的值，并在返回 P 之前先恢复它们

每个过程有自己的栈帧 EBP 指示栈帧的起始位置 ESP 指示栈顶，栈从**高地址向低地址增长**，**栈帧的范围在 EBP 和 ESP 之间**

```c
int add(int x, int y) {
	return x + y;
}

int caller(){
	int templ = 125;
	int temp2 = 80;
	int sum=add (templ, temp2);
	return sum;
}
```

caller 其汇编代码为：

```assembly
pushl %ebp
movl %esp, %ebp
subl $24, %esp  # 空去位置放局部变量
movl $125, -12(%ebp)  # temp1 = 125
movl $80, -8(%ebp)  # temp2 = 80
movl -8(%ebp), %eax  # eax = temp2
mov %eax, 4(%esp)  # temp2 入栈
movl -12(%ebp), %eax # eax = temp1
movl %eax, (%esp)  # temp1 入栈
call add  # 调用add,将返回值保存在 EAX 中
movl %eax, -4(%ebp) # sum = eax
movl -4(%ebp), %eax  # eax = sum, 即 return sum
leave  # movl %ebp, esp; popl %ebp
ret
```

当调用到 add 时，栈的信息如下所示

![image-20220607165438585](..\images\image-20220607165438585.png)

在调用中，**eax 保存函数返回的数据**，调用函数时要把**入口参数从右到左依次入栈**

加上 EBP 入栈的 4 字节 caller 的栈帧中用到的空间占 4＋12＋8 + 4 = 28 字节，但是 caller 的栈帧共有4＋24＋4= 32字节，其中浪费了4 字节的空间，这是因为 GCC 为保证数据的严格对齐而规定**每个函数的栈帧大小必须是 16 字节的倍数**

编译器可通过 pop 指令和对 ESP 的内容做加法来进行退栈操作，而不一定要使用 leave 指令，add 的代码如下所示：

```assembly
8048469:55         push %ebp
804846a:89e5       mov  %esp, %ebp
804846c:8b 45 0c   mov  0xC(%ebp) , %eax
804846f:8b 55 08   mov  0x8(%ebp), %edx
8048472:8d 04 02   lea  (%edx, %eax, 1), %eax  # 用 lea 实现加法
8048475:5d         pop  %ebp
8048476:c3         ret
```

通常，一个过程对应的机器级代码都有三个部分：准备阶段、过程体和结束阶段

- 准备阶段：将当前栈指针 ESP 传送到 EBP 来完成将 EBP 指向当前栈帧底部的任务，从而**方便地用 EBP 获取入口参数**

  如 add 的入口参数 x 和 y 对应的值分别在地址为 ebp + 8、ebp + 12 的存储单元中；ebp + 返回地址，刚好 `8B`

- 过程体：执行函数的功能，结束时**将返回值放到 EAX 中**

- 结束阶段：**恢复 ESP，并弹出上一个过程的 EBP**，至此本栈帧已销毁，栈顶就是返回地址，ret 返回回去

思考：因为 add 函数中，没有调用任何函数，所以它不遵守栈帧 16 字节倍数也是可以的

### 选择语句的机器级表示

对于 if-then、if-then-else、case-switch，编译器通过**条件码设置指令**和**各类转移指令**来实现程序中的选择结构语句

#### 条件码（标志位）

CPU 维护一组条件码（标志位）寄存器，它们描述了**最近的算术或逻辑运算操作的属性**

可以检测这些寄存器来执行条件分支指令，最常用的条件码如下，[具体](#补码加减运算部件)：

- CF：进（借）位标志，无符号溢出；ZF：零标志；SF：符号标志；OF：溢出标志，有符号溢出

**OF 和 SF 对无符号数运算来说没有意义，而 CF 对带符号数运算来说没有意义**

常见的算术逻辑运算指令 `add、sub、imul、or、and、shl、inc、dec、not、sal` 等会设置条件码

`cmp` 指令和 sub 指令的行为一样，test 指令与 and 指令的行为一样，但是它们**只设置条件码，而不更新目的寄存器**

应用题：对于 eax × ecx → eax 当高 32 位不全为 0 或不全为 1 时，溢出标志 OF = 1；检查溢出可以使用溢出自陷指令

#### if 语句

```c
int get cont (int *p1,int *p2) {
    if(p1 > p2)
    	return *p2;
    else
	    return *pl;
}
```

这个 C 语言函数对应的汇编为

```assembly
......
movl 8(%ebp), %eax  # eax = p1
movl 12(%ebp), %edx  # edx = p2

cmpl %edx, %eax  # 假装 pl - p2 并设置标志
jbe .L1  # ZF = 1 | CF = 1 无符号小于等于

movl (%edx), %eax  # eax = *p2
jmp .L2  # 无条件跳转到标记L2执行

.L1:
movl (%eax), %eax  # eax = *p1
.L2:
......
```

#### switch 语句

![image-20220608134030817](..\images\image-20220608134030817.png)

用跳转表来实现 a 的取值与跳转标号之间的对应关系，跳转表属于**只读数据**，即数据段属性为 `.rodata`，并且跳转表中的每个跳转地址都必须在 4 字节边界上，**偏移量等于索引值 * 4**，这个偏移量与跳转表的首地址相加就是转移目标地址

1. 将 a 的值减去 10 之后，再与 7 比较（无符号），若比 7 大就转跳到 `L5`
2. 将 a - 10 的值存放到 EAX 中，作为跳转表的索引；无条件间接跳转 `jmp *.L8( ,%eax，4)` 多了个 * 号

对 switch 语句进行编译转换的关键是**构造跳转表**，并正确**设置索引值**

**当 case 的条件值相差较大时**，构建这样的转跳表很不划算，此时编译器会**生成 if-else-if 分段转跳代码**

### 循环语句的机器级表示

while、for、do-while 用**条件测试 + 转跳**来实现循环

一般将这三种循环结构都转换为 do-while 形式来产生机器代码

在循环结构中，通常**使用条件转移指令来判断循环条件的结束**

#### do-while 循环

```c
// 一般形式
do
	body_statement;
while(test_expr);

// 翻译成 goto
loop:
body_statement;
t = test_expr;
if(t)
	goto loop;
```

#### while 循环

```c
// 一般形式
while(test_expr)
	body_statement;

// 翻译成 do-while 形式
t = test_expr;
if（!t)
	goto done;
do
	body_statement;
while(test_expr);
done:

// 翻译成 goto 语句
t = test_expr;
if (!t)
	goto done;
loop:
body_statement;
t = test_expr;
if(t)
	goto loop;
done:
```

#### for 循环

```c
// 一般形式
for(init_expr; test_expr; update_expr)
	body_statement;

// 翻译成 while
init_expr;
while(test_expr) {
	body_statement
    update_expr;
}

// 翻译成 goto
init_expr;
t = test_expr;
if(!t)
	goto done;
loop:
body_statement;
update_expr;
t = test_expr;
if(t)
	goto loop;
done:
```

#### 汇编例子

```c
int nsum_for(int n) {
	int i;
	int result = 0;
    for(i = 1; i <= n; i++)
		result += i;
    return result;
}
```

其汇编的代码为

```assembly
movl 8(%ebp), %ecx  # ecx = n
movl $0, %eax  # eax = 0，即 result = 0
movl $1, %edx  # edx = 1，即 i = 1
cmp %ecx, %edx  # 比较 i 与 n
jg .L2  # 有符号大于
.L1:
addl %edx, %eax  # result += i
addl $1, %edx  # i++
cmpl %ecx, %edx  # 比较 i 和 n
jle .L1  # 有符号小于等于
.L2:
```

n 对应的实参已压入栈帧，存储地址为 (ebp) + 8，局部变量 i 和 result 被分别分配到寄存器 EDX 和 EAX 中

## CISC 和 RISC 的基本概念

指令系统朝两个截然不同的方向的发展：

1. 增强原有指令的功能，**设置更为复杂的新指令实现软件功能的硬化**，称为复杂指令系统计算机 CISC，有 X86 架构
2. **减少指令种类和简化指令功能**，提高指令的执行速度，称为精简指令系统计算机 RISC，有 ARM、MIPS 架构

### 复杂指令系统计算机（CISC）

随着超大规模集成电路（VLSI）技术的发展，硬件成本不断下降，软件成本不断上升，促使人们在指令系统中**增加更多、更复杂的指令**，以适应不同的应用领域（即指令功能尽可能强）

CISC 的主要特点如下：

1. **指令系统复杂庞大**，指令数目一般为 200 条以上
2. **指令的长度不固定，指令格式多，寻址方式多**
3. **可以访存的指令不受限制**
4. 各种**指令使用频度相差很大**
5. 各种**指令执行时间相差很大**，大多数指令需多个时钟周期才能完成
6. **控制器大多数采用微程序控制**，有些指令非常复杂，以至于无法采用硬连线控制
7. **难以用优化编译生成高效的目标代码程序**

命令频率相差悬殊 20% 的简单的指令约占整个程序的 80%；而 80% 的指令约占整个程序的 20%，于是 RISC 随之诞生

### 精简指令系统计算机（RISC）

中心思想是<u>要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致</u>

RISC 的主要特点如下：

1. 选取使用**频率最高的一些简单指令**，<u>复杂指令的功能由简单指令的组合来实现</u>
2. **指令长度固定，指令格式种类少，寻址方式种类少**
3. **只有 Load / Store（取数/存数）指令访存**，其余指令的操作都在寄存器之间进行
4. CPU 中通用**寄存器的数量相当多**
5. RISC **一定采用指令流水线技术**，大部分指令在**一个时钟周期内完成**
6. 以**硬布线控制为主**，不用或少用微程序控制
7. 特别**重视编译优化工作**，以减少程序执行时间

从指令系统兼容性看，**CISC 大多能实现软件兼容**，即高档机包含了低档机的全部指令，并可加以扩充；而大多数 RISC 机不能与老机器兼容，但 **RISC 具有更强的实用性**，是未来处理器的发展方向

<u>现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分</u>，性能差距已经越来越小，CISC 可以提供更多的功能是程序设计需要的

选择题：指令格式规整且长度一致、按边界对齐存放、仅 Load/Store 指令访存，够有效地简化流水线的复杂度

- 指令格式规整且长度一致：格式规整可以<u>预测下一阶段</u>，如每条指令都是取址、分析、执行三个阶段很好流水
- 按边界对齐存放：不按边界对齐存放，可能取址时需要取两次，打乱周期
- 仅 Load/Store 指令访存：可以<u>预知资源占用情况</u>，因为就这两个指令很好分析

### CISC 和 RISC 的比较

和 CISC 相比，RISC 的优点主要体现在以下几点：

1. **RISC 更能充分利用芯片的面积**，CISC 的控制存储器占 CPU 芯片面积达 50% 以上，而 RISC 的硬布线逻辑只占 CPU 芯片面积的 10% 左右
2. RISC **更能提高运算速度**，指令数、寻址方式和指令格式种类少 + 多个通用寄存器 + 流水线技术
3. RISC **便于设计，可降低成本，提高可靠性**，RISC 指令系统简单，因此机器设计周期短；其逻辑简单，因此可靠性高
4. RISC **有利于编译程序代码优化**，编译程序容易选择更有效的指令和寻址方式，适当地调整指令顺序，令代码执行更高效化

![image-20211019164811802](..\images\image-20211019164811802.png)

## 常见问题

1. 简述各常见指令寻址方式的特点和适用情况

   立即寻址操作数获取便捷，通常用于**给寄存器赋初值**

   直接寻址相对于立即寻址，**缩短了指令长度**

   间接寻址**扩大了寻址范围**，便于编制程序，易于完成子程序返回

   寄存器间接寻址**扩大了寻址范围**，寄存器寻址的指令字较短，指令执行速度较快

   基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于**为程序或数据分配存储空间**

   变址寻址主要用于**处理数组问题**，适合编制循环程序

   相对寻址用于**控制程序的执行顺序、转移**等

2. 装入/存储（Load / Store）型指令有什么特点？

   装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格，在 RISC 指令系统中较为常见

   为了规整指令格式，使指令具有相同的长度，规定**只有 Load / Store 指令才能访问内存**

   因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致

   这种装入/存储型风格的指令系统的最大特点是，**指令格式规整，指令长度一致，一般为 32 位**

   与一般通用寄存器型指令风格相比，其**程序长度会更长**，因为会包含许多装入和存储指令

# 中央处理器

## CPU 的功能和基本结构

### CPU 的功能

中央处理器（CPU）由运算器和控制器组成：

1. 控制器负责**协调并控制 计算机各部件执行程序 的指令序列**，包括**取指令、分析指令、执行指令**
2. 运算器的功能是对数据进行加工

CPU 的具体功能包括：

1. 指令控制：完成取指令、分析指令、执行指令的操作，即程序的顺序控制
2. 操作控制：一条指令的功能由**若干控制信号的组合来实现**，控制信号控制这些部件按指令的要求进行动作
3. 时间控制：对各种操作加以时间上的控制，时间控制要为每条指令**按时间顺序提供应有的控制信号**
4. 数据加工：对数据**进行算术和逻辑运算**
5. 中断处理：对计算机运行过程中出现的**异常情况和特殊请求进行处理**

选择题：CPU 的位数是指 CPU 一次能处理数据的位数，即数据总线的位数

应用题：CPU 包含 **PC、IR、MDR、MAR、PSW** 专用寄存器

额外：CPU 的构成（相对于运算器和控制器来说更细）：

1. 组合逻辑电路 ALU：负责数据处理
2. 时序逻辑电路 CU：负责整个系统控制
3. 寄存器：负责存放中间结果
4. 中断系统：负责处理异常情况

### CPU 的基本结构

#### 运算器

运算器接收从控制器送来的命令并执行相应的动作，是**对数据进行加工和处理的中心**

主要有<u>算术逻辑单元 ALU、暂存寄存器、累加寄存器 ACC、通用寄存器组、程序状态字寄存器 `PSW`、移位器、计数器 CT</u> 等

1. 算术逻辑单元：主要功能是进行算术/逻辑运算

2. 暂存寄存器：可以用于**暂存从主存读来的数据**，避免破坏原有寄存器的数据，对应用程序员是透明的

   以及：ALU 的两个输入端连接总线的，一次总线输入会两端都修改，所以需要使用暂存寄存器进行过渡，第一次总线读入暂存寄存器，第二次总线输入 ALU 同时暂存寄存器也输入 ALU 进行计算

   思考：只有寄存器等才有存储的作用，而 ALU 的两个输入端需要同时输入数据才能计算出正确的结果

3. 累加寄存器：一个通用寄存器，用于**暂时存放 ALU 运算的结果信息**，可以作为累加运算的一个输入端

4. 通用寄存器组：如 `AX、BX、CX、DX、SP` 等，**用于存放操作数和各种地址信息等**，SP 是堆栈指针，用于指示栈顶的地址

5. 程序状态字寄存器：根据**算术逻辑运算指令或测试指令的结果**建立的**各种状态信息**

   如溢出标志 OF、符号标志 SF、零标志 ZF、进位标志 CF 等，PSW 中的这些位参与并决定微操作的执行

6. 移位器：**对操作数或运算结果进行移位运算**

7. 计数器：**控制乘除运算的操作步数**

#### 控制器

它是**整个系统的指挥中枢**，在它的控制下运算器、存储器和输入/输出设备等构成一个整体，根据指令，指挥全机协调工作

控制器的基本功能是执行指令，**每条指令的执行是由一组微操作实现的**，控制器有**硬布线控制器和微程序控制器**两种类型

有<u>程序计数器 PC、指令寄存器 IR、指令译码器、存储器地址寄存器 MAR、存储器数据寄存器 MDR、时序系统和微操作信号发生器</u>等

1. 程序计数器：**指出下一条指令在主存中的存放地址**，CPU 根据 PC 的内容去主存中取指令，**PC 有自增功能**
2. 指令寄存器：**保存当前正在执行的那条指令**
3. 指令译码器：仅对**操作码**字段进行译码，**向控制器提供特定的操作信号**
4. 存储器地址寄存器：用于**存放要访问的主存单元的地址**
5. 存储器数据寄存器：用于存放向主存**写入的信息**或从主存**读出的信息**
6. 时序系统：用于**产生各种时序信号**，它们都由统一时钟 CLOCK 分频得到
7. 微操作信号发生器：根据 IR 的内容、PSW 的内容、时序信号，**产生各种控制信号**，有**组合逻辑型**和**存储逻辑型**两种

控制器的工作原理是，根据<u>指令操作码、指令的执行步骤（微命令序列）、条件信号</u>，**形成各部件要用到的控制信号来控制各硬件系统协同运行**，产生预期的执行结果

注意：CPU 内部寄存器大致可分为两类：

1. **用户可见的寄存器**，可对这类寄存器编程，如通用寄存器组、PSW、PC 等
2. **用户不可见的寄存器**，不可对这类寄存器编程，如 MAR、MDR、IR 等

## 指令执行过程

### 指令周期

指令周期：**CPU 从主存中取出并执行一条指令的时间**，常用若干机器周期来表示

机器周期：**通过一次总线事务访问一次主存或 I/O 的时间**，包含若干时钟周期，也称 **CPU 周期**

时钟周期：也称节拍或 T 周期，它是 **CPU 操作的最基本单位**

每个**指令周期可以不等**，指令周期内**机器周期数可以不等**（不定长指令周期），每个机器周期内的**节拍数可以不等**

![image-20211020193433549](..\images\image-20211020193433549.png)

一个完整的指令周期包括**取指、间址、执行、中断** 4 个周期，但不是每一个周期都有操作，如 `JMP` 命令的间址周期没有操作

当 CPU 采用中断方式**实现主机和 I/O 设备的信息交换**时，CPU 在**每条指令执行结束前**，都要发中断查询信号，若有中断请求，则 CPU 进入中断响应阶段，又称**中断周期**

额外：当设置开中断时，才会有中断周期，如果设置了关中断，就没有中断周期

![image-20211020194139822](..\images\image-20211020194139822.png)

上述 **4 个工作周期都有 CPU 访存操作**，只是访存的目的不同：

1. 取指周期是为了取指令
2. 间址周期是为了**取有效地址**
3. 执行周期是为了取操作数
4. 中断周期是为了**保存程序断点**

**为了区别不同的工作周期，在 CPU 内设置 4 个标志触发器** FE、IND、EX、INT 它们分别对应取指、间址、执行、中断周期，并以 1 状态表示有效，如 1,0,0,0 是取址周期，0,1,0,0 是执行周期

注意：若指令字长 = 两个存储字长，则取址周期是机器周期的两倍

- 机器字长：CPU 一次能处理的二进制数据的位数
- 存储字长：一个存储单元存储的一串二进制码的位数
- 指令字长：一个指令字中包含二进制代码的位数，一般是存储字长的整数倍

选择题：采用 DMA 方式传递数据时，每传送一个数据就要占用一个存储周期

### 指令周期的数据流

**数据流**是**根据指令要求依次访问的数据序列**，这里的任务仅指取数据的任务（可能有更多任务），如取址阶段有取址和译址

#### 取址周期

取指周期的任务是**根据 PC 中的内容从主存中取出指令代码并存放在 IR 中**，取指令的同时，PC 加 1

![image-20211020200001136](..\images\image-20211020200001136.png)

取指周期的数据流向如下：

1. PC → MAR → 地址总线 → 主存
2. CU 发出读命令 → 控制总线 → 主存
3. 主存 → 数据总线 → MDR → IR（存放指令）
4. CU 发出控制信号 → PC 内容加 1

#### 间址周期

间址周期的任务是**取操作数有效地址**

将指令中的地址码送到 MAR 并送至地址总线，此后 CU 向存储器发读命令，以获取有效地址并存至 MDR

![image-20211020202902736](..\images\image-20211020202902736.png)

间址周期的数据流向如下：

1. Ad(IR)（或 MDR）→ MAR → 地址总线 → 主存
2. CU 发出读命令 → 控制总线 → 主存
3. 主存 → 数据总线 → MDR（存放有效地址）

其中，Ad(IR) 表示取出 IR 中存放的指令字的地址字段

#### 执行周期

执行周期的任务是**根据 IR 中的指令字的操作码和操作数通过 ALU 操作产生执行结果**

不同指令的执行周期操作不同，因此**没有统一的数据流向**

#### 中断周期

中断周期的任务是**处理中断请求**

假设程序断点存入堆栈中，并用 SP 指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据

![image-20211020203728011](..\images\image-20211020203728011.png)

中断周期的数据流向如下：

1. CU 控制将 SP 减 1，SP → MAR → 地址总线 → 主存
2. CU 发出写命令 → 控制总线 → 主存
3. PC → MDR → 数据总线 → 主存（程序断点存入主存）
4. CU（中断服务程序的入口地址）→ PC

### 指令执行方案

一个指令周期通常要包括几个执行步骤，**每个步骤完成指令的一部分功能**，几个依次执行的步骤 完成这条指令的全部功能

出于性能和硬件成本等考虑，可以选用 3 种不同的方案来安排指令的执行步骤

#### 单指令周期

把**每一个指令都使用相同的执行时间来完成**，称为单指令周期方案，**指令之间串行执行**，前一条执行完后才能执行后一条

**指令周期是执行时间最长的指令的执行时间**，让需要更短时间的指令也要使用这个周期来完成，**降低系统的运行速度**

#### 多指令周期

对**不同类型的指令选用不同的执行步骤来完成**，称为多指令周期方案，**指令之间串行执行**，前一条执行完后才能执行后一条

可选用**不同个数的时钟周期来完成不同指令**的执行过程，而不再要求所有指令占用相同的执行时间，但需要更复杂的硬件

#### 流水线方案

指令之间**可以并行执行**，称为流水线方案，其**追求的目标**是力争在**每个时钟脉冲周期完成一条指令的执行过程**

这种方案通过在**每个时钟周期启动一条指令**，尽量让多条指令同时运行，但**各自处在不同的执行步骤中**

例如：第一条指令在间址操作时，取址机器也别闲着，去对第二条指令进行取址操作，这样每个部件都会在运行

## 数据通路的功能和基本结构

### 数据通路的功能

**数据在功能部件之间传送的路径**称为**数据通路**，**路径上的部件**称为**数据通路部件**，数据通路中**专门进行数据运算的部件**称为**执行部件或功能部件**

数据通路<u>描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器</u>，这些都需要加以控制

数据通路**由控制部件控制**，控制部件根据每条指令功能的不同生成对数据通路的控制信号，并正确控制指令的执行流程

数据通路的功能是实现 **CPU 内部**的**运算器与寄存器及寄存器之间的数据交换**

选择题：**数据通路 = 电路 + 部件（组合 + 时序）**，并由**控制信号**进行控制

- 组合逻辑电路（操作元件）：不能存储输出仅取决于输入，如多路选择器 MUX、ALU、译码器
- 时序逻辑电路（状态元件）：能存储输出与输入和当前状态有关，如寄存器

思考：PC → MAR → M → MDR → IR 以及 Y → ALU, MDR → ALU → ACC 这就是数据通路，包含电路和部件

### 数据通路的基本结构

数据通路的基本结构主要有以下几种：

1. CPU 内部**单总线方式**：将所有寄存器的输入端和输出端都连接到**一条**公共通路上

   这种结构比较简单，但**数据传输存在较多的冲突现象**，性能较低；有两条总线就构成**双总线结构**，更多就是**多总线结构**

2. CPU 内部**三总线方式**：将所有寄存器的输入端和输出端都连接到**多条**公共通路上

   采用多总线方式，**同时在多个总线上传送不同的数据**，提高效率

3. **专用数据通路方式**：根据指令执行过程中的数据和地址的**流动方向连接线路**，**避免使用共享的总线，性能较高，硬件量大**

规定**各部件用大写字母表示**，字母加 in 表示该部件的**允许输入控制信号**；字母加 out 表示该部件的**允许输出控制信号**

注意：内部总线是指**同一部件内部**部件之间的总线；系统总线是指**同一台计算机系统**的各部件之间的总线

![image-20211021181127350](..\images\image-20211021181127350.png)

#### 寄存器之间的数据传送

**寄存器之间的数据传送可通过 CPU 内部总线完成**，寄存器 AX 的输出和输入分别由 `AXout` 和 `AXin` 控制

把 PC 内容送至 MAR，实现传送操作的流程及控制信号为：

- PC → Bus；`PCout` 有效，PC 内容送总线
- Bus → MAR；`MARin` 有效，总线内容送 MAR

#### 主存与 CPU 之间的数据传送

**主存与 CPU 之间的数据传送也要借助 CPU 内部总线完成**

CPU 从主存读取指令为的传送过程，实现传送操作的流程及控制信号为：

- PC → Bus → MAR；`PCout` 和 `MARin` 有效，现行指令地址 → MAR
- 1 → R；CU 发读命令
- `MEM(MAR) → MDR`；`MDRin` 有效
- MDR → Bus → IR；`MDRout` 和 `IRin` 有效，现行指令 → IR

#### 执行算术或逻辑算术

ALU **没有内部存储功能的组合电路**，执行加法运算时，**相加的两个数必须在 ALU 的两个输入端同时有效**

暂存器 Y 即用于该目的，**先把一个操作数读入 Y**，Y 的内容在 ALU 的左输入端**始终有效**

**再读一个操作数到 ALU 的右输入端**，这样两个操作数都送入了 ALU，**运算结果暂存在暂存器 Z 中**

- **Ad(IR)** → Bus → MAR；`MDRout` 和 `MARin` 有效
- 1 → R；CU 发读命令
- `MEM` → 数据线 → MDR；操作数从存储器 → 数据线 → MDR
- MDR → Bus → Y；`MDRout` 和 Yin 有效，操作数 → Y
- **(ACC) + (Y) → Z**；`ACCout` 和 `ALUin` 有效，CU 向 ALU 发加命令，结果 → Z
- Z → ACC；`Zout` 和 `ACCin` 有效，结果 → ACC

**数据通路结构**直接影响 CPU 内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它**关系着微操作信号形成部件的设计**

注意：**形式地址在指令字中给出 Ad(IR)**；控制线用于控制寄存器的输入输出，ALU 等功能部件的工作方式

三态门：用一个控制信号，用于决定数据能否从这里经过，图像是一个三角形，尖头是目的流向

### 综合应用题

某计算机字长 16 位，采用 16 位定长指令字结构，部分数据通路结构如下图所示。图中所有控制信号为 1 时表示有效，为 0 时表示无效。例如，控制信号 `MDRinE` 为 1 表示允许数据从 DB 打入 MDR，`MDRin` 为 1 表示允许数据从总线打入 MDR。假设MAR 的输出一直处于使能状态。加法指令 `ADD (R1), R0` 的功能为 `(R0) + ((R1)) → (R1)`，即将 `R0` 中的数据与 `R1` 的内容所指主存单元的数据相加，并将结果送入 `R1` 的内容所指主存单元中保存

![image-20211021185147136](..\images\image-20211021185147136.png)

下表给出了上述指令取指和译码阶段每个节拍（时钟周期）的功能和有效控制信号，请按表中描述方式用表格列出指令执行阶段每个节拍的功能和有效控制信号

![image-20211021185232450](..\images\image-20211021185232450.png)

解答：

![image-20211021185419810](..\images\image-20211021185419810.png)

思考：**控制信号同时可以给多个**，但是要注意**不要让总线发生冲突**，以及**时间顺序要合适**

思考：寄存器数据不修改就不会变，之前修改的数值以后可以一直用；在访存时可以同时对总线进行数据流动

## 控制器的功能和工作原理

### 控制器的结构和功能

这是计算机硬件系统的五大功能部件及其连接关系，通过数据总线、地址总线、控制总线连接在一起，**框内的是控制器部件**

![image-20211022194718489](..\images\image-20211022194718489.png)

现对其主要连接关系简单说明如下：

1. 运算器部件通过数据总线与内存储器、输入输出设备传送数据
2. 输入输出设备通过接口电路与总线相连接
3. 内存储器、输入输出设备，从地址总线接收地址信息，从控制总线得到控制信号，从数据总线与其他部件传送数据
4. 控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送指令地址到地址总线，还要向系统中的部件提供运行所需要的控制信号

控制器是计算机系统的指挥中心，控制器的主要功能有：

1. 从主存中**取出一条指令**，并**指出下一条指令**在主存中的位置
2. 对指令进行译码或测试，产生相应的**操作控制信号**
3. 指挥并控制 CPU、主存、输入和输出设备之间的**数据流动方向**

根据控制器**产生微操作控制信号的方式的不同**，控制器可分为**硬布线控制器**和**微程序控制器**

选择题：**计算机**可以分为**控制部件和执行部件**，而控制器就是控制部件

### 硬布线控制器

#### 硬布线控制单元图

硬布线控制器的就是根据<u>指令的要求、当前的时序、外部和内部的状态</u>，**按时间的顺序发送一系列微操作控制信号**

硬布线控制器由复杂的组合逻辑门电路和一些触发器构成，因此又称**组合逻辑控制器**

![image-20211022200902165](..\images\image-20211022200902165.png)

CU 的输入信号来源如下：

1. **经指令译码器译码产生的指令信息**：操作码决定 CU **要发送的操作信号集**，与**时钟**配合产生不同的控制信号

2. **时序系统产生的机器周期信号和节拍信号**：让 CU **按一定的顺序发送信号**，一个时钟脉冲 CU 可以发送一个或一组命令

   节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令 $C_i$（控制信号）按时间的先后发出

3. 来自执行单元的反馈信息即标志：CU <u>有时需要根据当前 CPU 状态来产生控制信号</u>，如条件跳转指令

CU 的输入：**操作码译码电路 ID、节拍发生器、状态标志**；输出：CPU 内部或外部控制总线

注意：<u>控制单元还接收来自系统总线（控制总线）的控制信号</u>，如中断请求、DMA 请求

额外：操作码译码器和地址译码器一样，根据操作码选择特定的一条线输出，如操作码有 n 位则输出线有 $2^n$ 条

思考：用一条线表示一个命令，比较容易设计电路，减轻电路的复杂度，反之最后都会转成一根线，不如直接在 CPU 处转

#### 硬布线控制器的时序系统及微操作

##### 硬布线控制器的时序系统

1. 时钟周期：时钟信号控制节拍发生器产生节拍，**每个节拍的宽度对应一个时钟周期**，每个节拍完成**多个并行或一个的操作**

2. 机器周期：机器周期可视为所有**指令执行过程中的一个基准时间**

   通常**以存取周期（存储周期固定）作为基准时间**，在存储字长与指令字长**等长**的前提下，取指周期也可视为机器周期

   在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，用**时钟信号控制产生每个微操作命令**

3. 指令周期：**CPU 从主存中取出并执行一条指令的时间**，详见[这里](#指令周期)

4. 微操作命令分析：控制单元具有发出各种操作命令（控制信号）序列的功能，即根据不同指令发不同操作序列

   这些命令与指令有关，而且**必须按一定次序发出，才能使机器有序地工作**

##### 指令的微操作

一条指令分为 3 个工作周期：取指周期、间址周期、执行周期，下面分析各个子周期的微操作命令：

1. 取指周期的微操作命令，**每个指令取址周期指令一样**：

   PC → MAR；现行指令地址 → MAR

   1 → R；命令存储器读

   M(MAR) → MDR；现行指令从存储器中读至 MDR

   MDR → IR；现行指令 → IR

   OP(IR) → CU；指令的操作码 → CU 译码

   (PC) + 1 → PC；形成下一条指令的地址

2. 间址周期的微操作命令，完成**取操作数地址**的任务，微操作命令通常为：

   Ad(IR) → MAR；将指令字中的地址码（形式地址）→ MAR

   1 → R；命令存储器读

   M(MAR) → MDR；将有效地址从存储器读至 MDR

3. 执行周期的微操作命令，执行周期的微操作命令**视不同指令而定**

   - 非访存指令

     `CLA`；清 ACC；0 → ACC

     COM；取反；$\overline{ACC}$ → ACC

     `SHR`；算术右移；L(ACC)→R(ACC)，$ACC_0→ACC_0$

     `CSL`；循环左移；R(ACC)→L(ACC)，$ACC_0→ACC_n$

     `STP`；停机指令；0 → G

   - 访存指令

     - ADD X；加法指令

       Ad(IR) → MAR

       1 → R

       M(MAR) → MDR

       (ACC) + (MDR) → ACC

     - STA X；存数指令

       Ad(IR) → MAR

       1 → w

       ACC → MDR

       MDR → M(MAR)

     - `LDA` X；取数指令

       Ad(IR) → MAR

       1 → R

       M(MAR) → MDR

       MDR → ACC

   - 转移指令

     JMP X；无条件转移；Ad(IR) → PC

     BAN X；条件转移（负则转)；$A_0\cdot Ad(IR)+\overline{A_0}\cdot(PC)→PC$

#### CPU 的控制方式

控制单元控制一条指令执行的过程，实质上是**依次执行一个确定的微操作序列的过程**

由于不同指令所对应的微操作数及复杂程度不同，因此**每条指令和每个微操作所需的执行时间也不同**

主要有以下 3 种控制方式：

1. 同步控制方式：取**最长的微操作作为节拍**，取**最多的节拍数作为机器周期**

   同步控制方式的优点是控制电路简单，缺点是运行速度慢

2. 异步控制方式：各部件**按自身固有的速度工作，通过应答方式进行联络**

   异步控制方式的优点是运行速度快，缺点是控制电路比较复杂

3. 联合控制方式：联合控制方式是介于**同步、异步之间的一种折中**

   这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法

#### 硬布线控制单元设计步骤

##### 微操作时序的原则

原则一微操作的**先后顺序不得随意更改**，有些微操作会有先后关系

原则二尽量把被控对象**不同的微操作安排在一个节拍内完成**

原则三**占用时间较短的微操作**，尽量**安排在一个节拍内完成**，并**允许有先后顺序**，如连续的存取寄存器数据流

##### 列出微操作命令的操作时间表

根据微操作节拍安排，列出微操作命令的操作时间表；表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号，表中 FE、IND、EX 为 CPU 工作周期标志，$T_0\sim T_2$ 为节拍

- Ⅰ 为间址标志，在取指周期的 $T_2$ 时刻，若测得 **I = l，则 IND 触发器置 1**，标志进入间址周期；若 **I = 0，则 EX 触发器置 1**，标志进入执行周期
- 在间址周期的 $T_2$ 时刻，若测得 **IND = 0 表示一次间接寻址，则 EX 触发器置 1**，进入执行周期；若测得 **IND = 1 表示多次间接寻址**，则继续间接寻址
- 在执行周期的 $T_2$ 时刻，CPU 要向所有中断源发中断查询信号，若**检测到有中断请求并满足响应条件，则 INT 触发器置 1**，标志进入中断周期

表中第一行对应 10 条指令的操作码，代表不同的指令，若<u>某指令有表中所列出的微操作命令，其对应的单元格内为 1</u>

![image-20211022213359481](..\images\image-20211022213359481.png)

##### 进行微操作信号综合

根据微操作时间表可**写出各微操作控制信号的逻辑表达式并进行适当的简化**，简化后就**可以使用电路门实现**

表达式一般包括下列因素：微操作控制信号 = 机器周期 ^ 节拍 ^ 脉冲 ^ 操作码 ^ 机器状态条件

例如，根据表可写出 M(MAR) → MDR 微操作命令的逻辑表达式：

M(MAR) → MDR，根据表得知当什么时会执行这个操作

=$FE·T_1＋IND·T_1(ADD + STA+LDA+JMP+BAN)+EX·T_1(ADD + LDA)$

=$T_1\{FE＋IND(ADD +STA+ LDA＋JMP+BAN)＋EX(ADD+ LDA)\}$

式中 ADD、STA、LDA、JMP、BAN 均来自操作码译码器的输出

##### 画出微操作命令的逻辑图

**根据逻辑表达式可画出对应每个微操作信号的逻辑电路图**

例如，M(MAR) → MDR 的逻辑表达式所对应的逻辑图

![image-20211022213618029](..\images\image-20211022213618029.png)

### 微程序控制器

#### 微程序控制的基本概念

微程序的设计思想是将**每条机械指令转换成一个微程序**，每个微程序**包含若干微指令**，每条微指令**包含一个或多个微操作**

微程序**存放在控制存储器**中，**用寻址方式来拿微命令**，目前，大多数计算机都采用微程序设计技术

微程序设计技术涉及的基本术语如下：

1. 微命令与微操作：

   微命令是**控制部件向执行部件发出的各种控制命令**，它是**构成控制序列的最小单位**

   微命令是微操作的**控制信号**，微操作是微命令的**执行过程**，如 M(MAR) → MDR；微命令的相容性和互斥性：

   - 相容性微命令：**可以同时产生、共同完成某一些微操作的微命令**
   - 互斥性微命令：在机器中**不允许同时出现的微命令**

   注意：在组合逻辑控制器中也存在微命令与微操作这两个概念

2. 微指令与微周期：

   **微指令是若干微命令的集合**，存放微指令的控制存储器的单元地址称为**微地址**

   一条微指令通常至少包含两大部分信息：

   1. 操作控制字段：**产生某一步操作所需的各种操作控制信号**，又称微操作码字段
   2. 顺序控制字段：**控制产生下一条要执行的微指令地址**，又称微地址码字段

   微周期通常指从控制存储器中**读取一条微指令并执行相应的微操作所需的时间**

3. 主存储器与控制存储器：

   主存储器：**存放程序和数据，在 CPU 外部，用 RAM 实现**

   控制存储器 CM：**存放微程序，在 CPU 内部，用 ROM 实现**

4. 程序与微程序：

   程序：**指令的有序集合，用于完成特定的功能**

   微程序：**微指令的有序集合，一条指令的功能由一段微程序来实现**

微程序实际上是**机器指令的实时解释器**，由计算机设计者**事先编制好并存放在控制存储器中**，一般**不提供给用户**（透明）

读者应注意区分以下寄存器：

1. 地址寄存器 MAR：存放主存的读/写地址
2. 微地址寄存器 CMAR：**存放控制存储器的读/写微指令的地址**
3. 指令寄存器 IR：存放从主存中读出的指令
4. 微指令寄存器 CMDR 或 $\mu$IR：**存放从控制存储器中读出的微指令**

选择题：微处理器是相对于一些大型处理器而言的，微程序控制器则是相对于 CPU 控制器而言的，它们之间没有必然关系

#### 微程序控制器组成和工作过程

##### 微程序控制器的基本组成

![image-20211023131912364](..\images\image-20211023131912364.png)

这是一个微程序控制器的基本结构，主要画出比组合逻辑控制器多出的部件，包括：

1. 控制存储器 CM：微程序控制器的核心部件，**存放各指令对应的微程序**，控制存储器可用**只读存储器 ROM 构成**
2. 微指令寄存器 CMDR：存放从 CM 中取出的微指令，它的**位数同微指令字长相等**
3. 微地址形成部件：**产生初始微地址和后继微地址**，以保证微指令的连续执行
4. 微地址寄存器 CMAR：**接收微地址形成部件送来的微地址**，为在 CM 中读取微指令作准备
4. 顺序逻辑：有时微程序不一定会顺序执行，可能会有中断和跳转等，所以需要一个部件来进行这些操作

额外：每条微指令占一个控制存储器单元，**控制存储器 CM 的容量为 2 的 n 次幂**

##### 微程序控制器的工作过程

即在微程序控制器的控制下计算机执行机器指令的过程，描述如下：

1. 执行取微指令公共操作，每个指令的取指操作是一样的（取址是单独一个微程序）：

   机器开始运行时，把**取指微程序首地址放入 CMAR** 一般在 CM 的 0 号单元，运行完后**机械指令就存入 IR 中**

2. 微地址形成部件**根据机器指令的操作码字段产生对应的微程序的入口地址**，并送入 CMAR

3. 执行完一条机器指令对应的一个微程序后，**回到第 1 步，进行下一条指令的取址**，直到整个程序执行完毕

微指令执行过程：根据 CMAR 从 CM 读取微指令到 CMDR 后，**微操作码字段用于发送控制信号**；**地址码字段放入 CMAR 指出下一条指令**，微程序的最后一条微指令的地址码字段存放的是取指微程序首地址

##### 微程序和机器指令

一条机械指令对应**一个微程序**；多个指令**相同的部分**也可以编成一个**微程序**，如取指令操作、间址周期、中断周期微程序

**控制存储器中的微程序个数是机械指令数加上公用的微程序数**

注意：若**指令系统中具有 n 种机器指令**，则控制存储器中的**微程序数至少是 n + 1**（1 为公共的取指微程序）

注意：**指令操作微程序是一定有**，但题目不说明有间址周期、中断周期微程序就不要计算进去，如带中断的计算机指令系统就要把中断周期微程序算进去

#### 微指令的编码方式

微指令的编码方式又称微指令的控制方式，编码的目标是**在保证速度的情况下，尽量缩短微指令字长**

##### 直接编码（直接控制）方式

![image-20211023141434408](..\images\image-20211023141434408.png)

直接编码法无须进行译码，微指令的**微命令字段中每位都代表一个微命令**

设计微指令时，**选用或不选用某个微命令**，只要将表示该微命令的**对应位设置成 1 或 0 即可**

优点：简单、直观，**执行速度快，操作并行性好**；缺点：**微指令字长过长**，造成控制存储器容量极大

##### 字段直接编码方式

将微指令的微命令字段**分成若干小字段，互斥性微命令分在同一段内，相容性微命令分在不同段内，每个字段独立编码**

![image-20211023142139982](..\images\image-20211023142139982.png)

**缩短了微指令字长**，但要**通过译码电路**后再发出微命令，**比直接编码方式慢**

微命令字段分段的原则：

1. 互斥性微命令分在同一段内，相容性微命令分在不同段内

2. 每个小段中包含的**信息位不能太多**，否则将增加译码线路的复杂性和译码时间

3. 一般每个小段还要**留出一个状态，表示本字段不发出任何微命令**

   当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，通常用 000 表示不操作

##### 字段间接编码方式

![image-20211023150405058](..\images\image-20211023150405058.png)

一个字段的某些微命令需由另一个字段中的某些微命令来解释；称为字段间接编码，又称隐式编码

思考：一个字段的的微命令要经过两次译码后才能发出控制信号，这个译码器的输出是下个译码器的输入

优点：可进一步缩短微指令字长；缺点：削弱了微指令的并行控制能力，通常**作为字段直接编码方式的一种辅助手段**

#### 微指令的地址形成方式

后继微地址的形成主要有以下两大基本类型：、

1. 直接由微指令的下地址字段指出：**由微指令的下地址字段直接指出**后继微指令的地址，这种方式又称**断定方式**
2. 根据机器指令的操作码形成：机器指令取至指令寄存器后，微指令的地址**由操作码经微地址形成部件形成**

实际上，微指令序列地址的形成方式还有以下几种（了解）：

1. **增量计数器法**：即 (CMAR) + 1 → CMAR，适用于后继微指令的地址连续的情况
2. 分支转移：地址码字段包含：转移方式，即指明判别条件；转移地址，即转移成功后的去向
3. 通过网络测试（顺序逻辑）形成：也是把地址码字段分成多个字段，然后通过硬件产生下地址的思路
4. 由硬件直接产生微程序入口地址：电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向 CMAR输入微指令的地址，这个地址即为取指周期微程序的入口地址

#### 微指令的格式

##### 水平型微指令

从编码方式看，直接编码、字段直接编码、字段间接编码、混合编码**都属于水平型微指令**

指令字中的一位对应一个控制信号，有输出时为 1，否则为 0，**一条水平型微指令定义并执行几种并行的基本操作**

![image-20211023152819325](..\images\image-20211023152819325.png)

优点：**微程序短，执行速度快**；缺点：**微指令长，编写微程序较麻烦**

应用题：**水平型微指令**由**操作控制字段、判别测试字段、下地址字段**三部分组成

- 当判别字段的判别条件互斥时，可以缩短使用的线，但要注意<u>增加 1 种状态，表示无状态</u>

理解：水平型的微指令比较胖，叫水平型；而下面垂直型的微指令比较廋更高，所以叫垂直型

##### 垂直型微指令

**采用类似机器指令操作码的方式**，在微指令中设置微操作码字段，采用微操作码编译法，由**微操作码规定微指令的功能**

对微操作码编译后就可以发出控制信号（可能要结合那两个地址），**一条垂直型微指令只能定义并执行一种基本操作**

![image-20211023153120438](..\images\image-20211023153120438.png)

优点：微指令短、简单、规整，**便于编写微程序**；缺点：**微程序长，执行速度慢**，工作效率低

##### 混合型微指令

在垂直型的基础上增加一些不太复杂的并行操作，即结合两种类型

微指令较短，仍便于编写；微程序也不长，执行速度加快

##### 水平型和垂直型的比较

1. 水平型微指令**并行操作能力强、效率高、灵活性强**；垂直型微指令则较差
2. 水平型微指令**执行一条指令的时间短**；垂直型微**指令执行的时间长**
3. 水平型微指令解析的程序，**微指令字较长但微程序短**；而垂直型微指令，其**微指令字较短但微程序长**
4. 水平型微指令**用户难以掌握**，而垂直型微指令与指令比较相似，**相对容易掌握**

#### 微程序控制单元的设计步骤

1. 写出对应机器指令的微操作命令及节拍安排：

   微程序控制单元在取指阶段发出的微操作命令及节拍安排如下：

   - $T_0$    PC → MAR，1 → R
   - $T_1$    M(MAR) → MDR，(PC) + 1 → PC
   - $T_2$    MDR → IR，OP(IR) → 微地址形成部件

   微程序控制单元和硬布线控制单元在取址阶段基本一样，但还是有一点区别：

   - 微程序：将**指令的操作码送至微地址形成部件**，以形成该条机器指令的微程序首地址
   - 硬布线：将**指令的操作码送至指令译码器**，以控制 CU 发出相应的微命令

   控制信号来之微指令，而微指令在微存储单元中，要读出微指令前要先把微地址放入 CMAR

   所以除了第一条微指令的 CMAR 是硬件指出外，其余的**微指令执行前要花一个节拍设置微指令所在的 CMAR**

   考虑到**需要形成后继微指令地址**，上面的微操作命令变为：

   - $T_0$    PC → MAR，1 → R
   - $T_1$    Ad(CMDR) → CMAR；CMAR 由上一条微指令的下地址字段写入
   - $T_2$    M(MAR) → MDR，(PC) + 1 → PC
   - $T_3$    Ad(CMDR) → CMAR；CMAR 由上一条微指令的下地址字段写入
   - $T_4$    MDR → IR
   - $T_5$    OP(IR) → 微地址形成部件 → CMAR；传到 IR 后生成微地址并写入 CMAR

   与硬布线控制单元微操作命令的节拍安排相比，仅**多了将下一条微指令地址送至 CMAR 的微操作命令**

2. 确定微指令格式：

   微指令格式包括**微指令的编码方式、后继微指令地址的形成方式、微指令字长**等

   1. 根据**微操作个数**决定编码方式，再确定操作控制字段的位数
   2. 根据**微指令数**决定地址码字段的位数
   3. 把操作控制字段和顺序控制字段**合在一起得出微指令字长**

3. 编写微指令码点：根据操作控制字段每位代表的微操作命令，**编写每条微指令**

#### 动态微程序设计和毫微程序设计

1. 动态微程序设计：

   假如能**根据用户的要求改变微程序**，则这台机器就**具有动态微程序设计功能**

   动态微程序的设计**需要可写控制寄存器的支持**，否则难以改变微程序的内容

   实现动态微程序设计**可采用可擦除可编程只读存储器**（EPROM）

2. 毫微程序设计：

   从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制

   硬件**通过存放在第二级控制存储器中的毫微程序来解释**的，这个第二级控制存储器就称为**毫微存储器**，直接控制硬件的是**毫微微指令**

#### 硬布线和微程序控制器的特点

- 硬布线控制器的特点：

  优点：控制器的速度取决于电路延迟，**速度快**

  缺点：一旦逻辑电路设计完成，就**不能通过其他额外修改添加新功能**

- 微程序控制器的特点：

  优点：同组合逻辑控制器相比，微程序控制器具有**规整性、灵活性、可维护性**等

  缺点：**每条指令都要从控制存储器中取一次，影响速度**

![image-20211023165606640](..\images\image-20211023165606640.png)

### 综合应用题

题目：假设某机器有 80 条指令，平均每条指令由 4 条微指令组成，其中有一条取指微指令是所有指令公用的。已知微指令长度为 32 位，请估算控制存储器 CM 容量

解答：总微命令数 $80\times(4-1)+1=241$，每条微指令占一个控制存储单元，CM 的容量为 $2^n$ 故 CM 容量为 $256\times32=1KB$

------

题目：某微程序控制器中，采用水平型直接控制（编码）方式的微指令格式，后续微指令地址由微指令的下地址字段给出。已知机器共有 28 个微命令，6 个**互斥**的可判定的外部条件，控制存储器的容量为 512×40 位。试设计其微指令的格式，并说明理由

解答：**水平型微指令**由**操作控制字段、判别测试字段、下地址字段**三部分组成。水平直接编码，操作控制字段为 28 位；6 个互斥条件加上无状态就是 7 个，判断测试字段为 $\lceil\log_27\rceil=3$；存储容量为 512，下地址字段为 $\log_2512=9$ 位

注意：**如果判断条件互斥就用 $\lceil\log_2n\rceil$，如果没说明是互斥就用 n**

## 指令流水线

可从两方面提高处理机的并行性：

1. **时间上的并行技术：流水线技术**，把一个任务分成多个阶段，每个阶段在不同的功能部件上并行执行
2. **空间上的并行技术：超标量处理机**，内部设置多个执行相同任务的功能部件，并让这些功能部件并行工作

### 流水线的基本概念

#### 指令流水的定义

采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术

可以把一条指令的执行过程分为取址、分析、执行、访存、写回五个阶段：

- 取指 IF：从指令存储器或 Cache 中**取指令**
- 译码/读寄存器 ID：操作控制器对指令进行**译码**，同时从寄存器堆中**取操作数**；这里取操作数会产生冲突
- 执行/计算地址 EX：执行**运算**操作或**计算地址**
- 访存 MEM：对存储器进行**读写操作**
- 写回 WB：将指令执行结果**写回**寄存器堆

当多条指令在处理器中执行时，可以采用以下两种方式：

1. 顺序执行方式：

   **前一条指令执行完后，才启动下一条指令**；传统冯·诺依曼机采用顺序执行方式，又称串行执行方式

   ![image-20211024141117222](..\images\image-20211024141117222.png)

   假设取指、分析、执行三个阶段的时间都相等，用 t 表示，顺序执行 **n 条指令所用时间 T 为 `T = 3nt`**

   优点：控制简单，硬件代价小；缺点是<u>执行指令的速度较慢，各功能部件的利用率很低</u>

2. 流水线执行方式：

   按流水线的方式来执行命令，即功能部件之间并行运行，如下图

   ![image-20211024141550524](..\images\image-20211024141550524.png)

   **执行 n 条指令所用的时间为 T = 2 + `nt`**，比顺序执行方式的执行时间缩短近 2 / 3，**各功能部件的利用率明显提高**

   但为此**需要付出硬件上较大开销的代价，控制过程也更复杂**

   **在理想情况下**，每个时钟周期都有一条指令完成，每条指令的**时钟周期数都为 1**

为了进一步获得更高的执行速度，**还可以将流水段进一步细分**，细分后指令的时钟周期仍为 1，而**时钟周期变短了**

注意：不是流水线越多，指令执行速度就越快，因为流水线本身也是需要开销的，而且流水线多还加大了冲突的可能

流水线设计的原则是如下：

1. 指令流水段个数以**最复杂指令所用的功能段个数**为准
2. 流水段的长度以**最复杂的操作所花的时间**为准

根据第二条原则，流水线**执行一条命令时间会比顺序执行慢**，但会大大**增加整个程序的指令执行的吞吐率**

例题：若某计算机最复杂指令的执行需要完成 5 个子功能，分别由功能部件 A~E 实现，各功能部件所需时间分别为 **`80ps`**、`50ps、50ps、70ps 、50ps`，采用流水线方式执行指令，流水段寄存器延时为 **`20ps`**，则 CPU 时钟周期至少为 `80ps + 20ps`

为了利于实现指令流水线，指令集应具有如下特征：

1. **指令长度应尽量一致**，有利于简化取指令和指令译码操作
2. **指令格式应尽量规整**，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数
3. **除 Load/Store 指令，其他指令都不能访问存储器**，有利于减少操作步骤
4. **数据和指令在存储器中对齐存放**，有利于减少访存次数

选择题：空间并行：资源重复，有多个相同的功能部件；时间并行：时间重叠，多个功能部件在时间相互错开

#### 流水线的表示方法

通常用**时空图**来直观地描述流水线的工作过程

![image-20211024151710363](..\images\image-20211024151710363.png)

- **横坐标表示时间**，即输入流水线中的**各个任务在流水线中所经过的时间**

  流水线中各个流水段的执行时间都相等时，横坐标就被分割成相等长度的时间段

- **纵坐标表示空间**，即流水线的**每个流水段**（对应各执行部件）

每经过一个 $\Delta t$ 时间，便有一条指令进入流水线，从时刻 $t_4$ 开始有一条指令流出流水线

当 $t_8=8\Delta t$ 时，流水线上便有 5 条指令流出，若是串行方式，只能执行 2 条指令，可见流水线成倍地提高了计算机的速度

#### 流水线方式的特点

与传统的串行执行方式相比，采用流水线方式具有如下特点：

1. 把一个任务分解为几个有联系的子任务并由各个的功能部件来执行，依靠**多个功能部件并行工作来缩短程序的执行时间**

2. 每个功能段部件后面都**要有一个缓冲寄存器**（锁存器），其作用是**保存本流水段的执行结果**，供给下一流水段使用

   可以调和两个功能段执行时间不相等问题，保留结果在锁存器等另一个功能执行完在传内容过去

3. **流水线中各功能段的时间应尽量相等**，否则将引起堵塞、断流

4. 只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在**流水线中处理的必须是连续任务**

5. 流水线需要有装入时间和排空时间：

   装入时间是指<u>第一个任务进入流水线到输出流水线的时间</u>

   排空时间是指<u>最后一个任务进入流水线到输出流水线的时间</u>

### 流水线的基本实现

#### 流水线的数据通路

一个 5 段流水线数据通路如下：

- IF 段：程序计数器 PC、指令存储器、下条指令地址的计算逻辑
- ID 段：操作控制器、取操作数逻辑、立即数符号扩展模块
- EX 段：算术逻辑单元 ALU、分支地址计算模块
- MEM 段：数据存储器读写模块
- WB 段：寄存器写入控制模块

流水段间增加一个流水寄存器，锁存本段处理完成的**数据和控制信号**，把本段的执行结果在**下个时钟周期给下个流水段**

各种寄存器和数据存储器均**采用统一时钟 CLK 进行同步**，每个时钟有一条指令进入 IF 段

同时流水寄存器会**锁存前段加工处理完成的数据和控制信号**，作为下一段的功能部件提供数据输入

![image-20220612152745408](..\images\image-20220612152745408.png)

不同流水寄存器锁存的数据不相同：**把后面可能用到的内容给后面**

- IF/ID：放入指令存储器取出的指令字，以及 PC + 4 的值（可能用于相对跳转）

- ID/EX：放入后段可能用到的操作数，如：

  地址既可以是立即数，也可以是寄存器，不知道是什么就都取了交给后面来判断

  寄存器堆中取出的两个操作数 RS 和 RT

  要写寄存器编号 WriteReg#

  立即数符号扩展的值、PC + 4 等

- EX/MEM：放入数据存储器待写入数据 WriteData、ALU 运算结果、写寄存器编号 WriteReg# 等数据

- MEM/WB：放入数据存储器读出数据、ALU 运算结果、写寄存器编号 WriteReg# 等数据

#### 流水线的控制信号

在某一时刻，每个流水段执行不同指令的某个阶段，每个流水段还需要正在执行指令的对应功能段的控制信号

控制信号的来源并不一致，由 **ID 段的控制器译码生成控制信号**，并分别**在随后的各个时钟周期内使用**

| 控制信号    | 位置 | 来源 | 功能说明                                                     |
| ----------- | ---- | ---- | ------------------------------------------------------------ |
| BranchTaken | IF   | EX   | 分支跳转信号，为 1 表示跳转，由 EX 段的 Branch 信号与 equal 标志进行逻辑与生成 |
| RegDst      | ID   | ID   | 写入目的寄存器选择，为 1 时目的寄存器为 rd 寄存器，为 0 时为 rt 寄存器 |
| RegWrite    | ID   | WB   | 控制寄存器堆写操作，为 1 时数据需要写回寄存器堆中的指定寄存器 |
| AluSre      | EX   | EX   | ALU 的第二输入选择控制，为 0 时输入寄存器 rt，为 1 时输入扩展后的立即数 |
| AluOp       | EX   | EX   | 控制 ALU 进行不同运算，具体取值和位宽与 ALU 的设计有关       |
| MemWrite    | MEM  | MEM  | 控制数据存储器写操作，为 0 时进行读操作，为 1 时进行写操作   |
| MemToReg    | WB   | WB   | 为 1 时将数据存储器读出数据写回寄存器堆，否则将 ALU 运算结果写回 |

每个流水寄存器中保存的信息包括：

1. **后面流水段需要用到的所有数据信息**，也是是前面阶段在数据通路中执行的结果

   包括 PC + 4、指令、立即数、目的寄存器、ALU 运算结果、标志信息等

2. 前面传递过来的**后面各流水段要用到的所有控制信号**

#### 流水线的执行过程

由于流水线的特殊结构，**所有指令都需要完整经过流水线的各功能段**，即使在这些功能段内只进行等待

流水线的执行过程就大致说一下，相信上面的图及表格已经说得很清楚了：

1. 取址：用 PC 的地址取出指令、PC +4 放到 IF/ID 寄存器面前，根据 BranchTaken 来修改 PC
2. 译码/读存储器 ID：根据 RegWrite 来写寄存器，把有效地址的所有可能都读出来（寄存器操作数，被写寄存器号，立即数）、命令编码出的操作信号、上面的 PC + 4 都放入 ID/EX 面前
3. 执行阶段：根据信号进行计算、跳转等操作，把结果、前面来的有用的东西放入 EX/MEM 寄存器前面
4. 访存：根据信号把计算的结果写过写入内存，或读出内存的数据，并把这次或上次有用的东西放入 MEM/WB 寄存器面前
5. 写回：根据信号把数据写回寄存器等

最后这个周期结束，CLK 发出信号，所有流水线寄存器面前的数据放入流水线寄存器，开始新一轮的操作

### 流水线的分类*

按照不同的分类标准，可以把流水线分成多种不同的种类。下面从几个不同的角度介绍流水线的基本分类方法

1. 根据流水线使用级别的不同，分为部件功能级、处理机级、处理机间级流水线：

   - 部件功能级流水：**将复杂的算术逻辑运算组成流水线**，可将浮点加法操作分成求阶差、对阶、尾数相加、结果规格化
   - 处理机级流水：**把一条指令解释过程分成多个子过程**，如取指、译码、执行、访存、写回 5 个子过程
   - 处理机间流水：是一种宏流水，其中**每个处理机完成某一专门任务**，结果需存放在与下一个处理机共享的存储器中

   部件级是把一个部件任务拆分、处理机级是把一个处理机任务拆分、处理机间级是把处理机群任务拆分

2. 按可以完成的功能，分为单功能流水线和多功能流水线：

   - 单功能流水线：只能实现**一种固定的专门功能**的流水线
   - 多功能流水线：通过各段间的**不同连接方式**可以**实现多种功能的流水线**

3. 按同一时间内各段之间的连接方式，分为动态流水线和静态流水线：

   - 静态流水线：在**同一时间内**，流水线的各段只能**按同一种功能的连接方式工作**

   - 动态流水线：在**同一时间内**，当**某些段正在实现某种运算时，另一些段却正在进行另一种运算**

     这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂

     注意：动态流水线是同一时间进行多种功能，多功能流水线是通过不同连接方式实现多功能

4. 按流水线的各个功能段之间是否有反馈信号，分为线性流水线和非线性流水线：

   线性流水线：从输入到输出，每个功能段**只允许经过一次**，**不存在反馈回路**

   非线性流水线：**存在反馈回路**，输入到输出的过程中，某些功能段将**数次通过流水线**，适合于进行线性递归的运算

流水线的每个子过程由专用的功能段实现，**各功能段所需的时间应尽量相等**，否则时间长的功能段将成为流水线的瓶颈

### 影响流水线的因素

如果**指令 2 的执行需要依赖指令 1 的结果**，我们就说这**两条指令是相关的**，指令相关包括**数据相关和控制相关**

#### 资源冲突（结构冒险）

多条指令在同一时刻**争用同一资源而形成的冲突称为资源冲突**，有以下两种解决办法：

1. 前一指令访存时，使后一条相关指令以及其后续指令**暂停一个时钟周期**

2. **单独设置数据存储器和指令存储器**，使取数和取指令操作各自在不同的存储器中进行

   现代计算机都引入了 Cache 机制，而 **Ll Cache 采用数据和指令分离**的方式，避免了资源冲突的发生

#### 数据冲突（数据冒险）

**下一条指令会用到当前指令计算出的结果**，这两条指令即为数据冲突，数据冲突可分为三类：

1. 写后读 Read After Write，RAW 相关：必须等上一条指令写入才能读
2. 读后写 Write After Read，WAR 相关：必须等上一条指令读完才能写
3. 写后写 Write After Write，WAW 相关：必须等上一条指令写入才能写

注意：乱序发射时才会出现 WAR，乱序完成时才会出现 WAW；**按序发射，按序完成时只会出现 RAW**

解决的办法有以下几种：

1. 把数据相关的指令及其后续指令都**暂停一至几个时钟周期**，直到数据相关问题消失后再继续执行

   硬件阻塞 stall（由硬件来实现延迟）和软件插入 `NOP` 指令（由编译器插入 `NOP` 指令）

2. 设置相关专用通路，如**把前一条指令的 ALU 的计算结果作为自己的输入数据**，这称为数据旁路技术

3. 通过**编译器对数据相关的指令编译优化**的方法，**调整指令顺序**来解决数据相关

#### 控制冲突（控制冒险）

当遇到条件转移指令时，无法知道下一个要运行的指令，导致无法取下一个指令，造成断流

解决的办法有以下几种：

1. 对转移指令**进行分支预测**，尽早生成转移目标地址

   静态预测：**总是预测条件不满足**，即继续执行分支指令的后续指令

   动态预测：**根据程序执行的历史情况，进行动态预测调整**，有较高的预测准确率

2. **预取转移成功和不成功两个控制流方向上的目标指令**

3. 加快和**提前形成条件码**

4. 提高转移方向的猜准率

### 流水线的性能指标

#### 流水线的吞吐率

以**线性流水线**为例分析流水线的主要性能指标，其分析方法和有关公式**也适用于非线性流水线**

在指令级流水线中，吞吐率是指在**单位时间内流水线所完成的任务（指令）数量**，或输出结果的数量

计算流水线吞吐率 TP 的**最基本的公式**为 $TP=\dfrac{n}{T_k}$ 其中 n 是任务数，$T_k$ 是处理完 n 个任务所用的时间

![image-20211024164618601](..\images\image-20211024164618601.png)

这是**各段执行时间均相等**的流水线时空图，在输入流水线中的**任务连续的理想情况**下，一条 k 段线性流水线能够在 k + n - 1 个时钟周期内完成 n 个任务，$\Delta t$ 为时钟周期，得出**流水线的实际吞吐率**为 $TP=\dfrac{n}{(k+n-1)\Delta t}$

连续输入的任务数 $n\to\infty$ 时，得最大吞吐率为 $TP_{max} = 1/\Delta t$

#### 流水线的加速比

完成同样一批任务，**不使用流水线所用的时间与使用流水线所用的时间之比**，称为流水线的加速比

设 $T_0$ 表示不使用流水线时的执行时间；$T_k$ 表示使用流水线时的执行时间，则**计算流水线加速比 S 的基本公式**为 $S=\dfrac{T_0}{T_k}$

若**继续使用上面的时空图**，则一条 k 段流水线完成 n 个任务所需的时间为 $T_k=(k + n -1)\Delta t$；而不使用流水线，即顺序执行 n 个任务时，所需的时间为 $T_0= kn\Delta t$，代入上式，得**实际加速比**为 $S=\dfrac{kn\Delta t}{(k+n-1)\Delta t}=\dfrac{kn}{k+n-1}$

连续输入的任务数 $n\to\infty$ 时，**最大加速比**为 $S_{max}= k$

#### 流水线的效率

**流水线的设备利用率**称为流水线的效率

![image-20211024182744747](..\images\image-20211024182744747.png)

在时空图上，流水线的效率定义为完成 n 个任务占用的**时空区有效面积**，与 n 个任务所用的时间及 k 个流水段所围成的**时空区总面积之比**，即红色的框除以蓝色的框

时空区有效面积就是顺序执行的总时间 $T_0$，时空区总面积为 $kT_k$，其中 $T_k$ 是流水线的总时间，因此**计算流水线效率的一般公式**为 $E=\dfrac{n个任务占用的时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}=\dfrac{T_0}{kT_k}$ 若各段执行时间相等 $E=\dfrac{n}{k+n-1}$

流水线的各段执行时间均相等，当连续输入的任务数 $n\to\infty$ 时，**最高效率**为 $E_{max} = 1$

### 高级流水线技术

有两种增加指令级并行的策略：

1. 多发射技术：采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理机一次可以发射多条指令到流水线执行
2. 超流水线技术：增加流水线级数来使更多的指令同时在流水线中重叠执行

#### 超标量流水线技术

**每个时钟周期内可并发多条独立指令**，即以并行操作方式将两条或多条指令编译并执行，为此**需配置多个功能部件**

超标量计算机**不能调整指令的执行顺序**，因此**通过编译优化技术**，把可并行执行的指令搭配起来，挖掘更多的指令并行性

![image-20211024183103430](..\images\image-20211024183103430.png)

不能调整指令的执行顺序是指无法把零散的可以并行的指令放在一起

但已经放一起的指令，以集合为单位，是可以使用流水线的动态调度

静态调度：让编译器决定执行什么命令；动态调度：让硬件决定执行什么命令，按什么顺序执行

#### 超流水线技术

**在一个时钟周期内再分段**，在一个时钟周期内**一个功能部件使用多次**

**不能调整指令的执行顺序**，靠编译程序解决优化问题

![image-20211024184719694](..\images\image-20211024184719694.png)

#### 超长指令字

由编译程序挖掘出指令间潜在的并行性，将**多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字**（可达几百位），为此**需要采用多个处理部件**

![image-20211024184852275](..\images\image-20211024184852275.png)

选择题：与超标量流水线相比，超长指令对 Cache 的容量要求更大，以便能实现同时执行多个操作

## 多处理器的基本概念

### SISD、SIMD、MIMD 的基本概念

基于**指令流的数量和数据流的数量**，将计算机体系结构分为 SISD、SIMD、MISD 和 MIMD 四类

常规的**单处理器属于 SISD**，而常规的**多处理器属于 MIMD**

#### 单指令流单数据流 SISD 结构

SISD 是串行计算机结构，仅包含一个处理器和一个存储器，一段时间内**仅执行一条指令**，且**顺序串行地执行指令**

有些 SISD 采用流水线的方式，设置多个功能部件，并且采用多模块交叉方式组织存储器来提高速度

前面的内容多属于 SISD 结构

#### 单指令流多数据流 SIMD 结构

SIMD 指**一个指令流同时对多个数据流进行处理**，称为数据级并行技术，通常由**一个指令控制部件、多个处理单元组成**

每个单元都有**自己的地址寄存器**，这样不同处理单元虽然执行的**同一条指令**但所处理的**数据是不同的**

一个顺序应用程序被编译后，可能按 SISD 组织并运行于串行硬件上，也可能按 SIMD 组织并运行于并行硬件上

在**使用 for 循环处理数组时最有效**，如 for 循环对 16 个数据进行乘 2，则可以转换为 SIMD 指令在 **16 个 ALU 中同时运算**，则一次运算就完成（**相同操作**）

在**使用 case 或 switch 语句时最低效**，此时每个执行单元必须根据不同的数据执行**不同操作**

#### 多指令流单数据流 MISD 结构

MISD 是指同时执行多条指令，处理同一个数据，实际上**不存在**这样的计算机

#### 多指令流多数据流 MIMD 结构

MIMD 指同时执行多条指令分别处理多个不同的数据，MIMD 分为多计算机系统和多处理器系统

- 多计算机系统：每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，通过**消息传递进行数据传送**，也称消息传递 MIMD
- 多处理器系统，共享存储多处理器系统 SMP：共享的单一地址空间，通过**存取指令来访问系统中的所有存储器**，也称共享存储 MIMD

---

向量处理器是 SIMD 的变体，是实现了直接操作一维数组（向量）指令集的 CPU

- 将从存储器中收集的一组数据按顺序放到一组向量寄存器中
- 以流水化的方式对它们依次操作，最后将结果写回寄存器
- 向量处理器在特定工作环境中极大地提升了性能，尤其是在数值模拟或者相似的领域中

SIMD 和 MIMD 是两种并行计算模式，SIMD 是**数据级并行**模式，MIMD 是更好的**线程级并行**或线程级以上并行计算模式

### 硬件多线程的基本概念

为了减少线程切换过程中的开销，便诞生了硬件多线程，线程的切换只需激活选中的寄存器，不需要跟存储器交换数据

在支持硬件多线程的 CPU 中，要为每个线程提供单独的**通用寄存器组、程序计数器**等，实现由下面三种方式：

#### 细粒度多线程

多个线程之间轮流交叉执行指令，多线程间的**指令是不相关的，可以乱序并行执行**，则处理器能在每个时钟周期切换线程

思考：多个进程之间的指令没有关系，这样流水线就没有冲突了，只需多用一套寄存器保存现场

![image-20220614161132852](..\images\image-20220614161132852.png)

#### 粗粒度多线程

仅在一个线程**出现了较大开销的阻塞**时，才切换线程，如 Cache 缺失

在这种方式下，当发生流水线阻塞时，要清除流水线，并加载新线程的流水线，**线程切换的开销比细粒度多线程更大**

![image-20220614161149615](..\images\image-20220614161149615.png)

#### 同时多线程

同时多线程 SMT 是上述两种多线程技术的变体，它在实现指令级并行的同时，实现**线程级并行**

也就是说，它**在同一个时钟周期中，发射多个不同线程中的多条指令执行**

![image-20220614161728588](..\images\image-20220614161728588.png)

Intel 处理器中的超线程 Hyper-threading 是 SMT，即单核中有两套线程状态部件，共享高速缓存和功能部件，它是**模拟双核，单不是真正的双核**

注意：细粒是一周期 A 一周期 B，而 SMT 是单周期中若 A 没任务但还有时间就执行 B

选择题：超线程技术的 CPU 需要芯片组、操作系统和应用软件的支持，才能发挥该项技术的优势

选择题：超线程技术仅具有线程必要的资源，当都使用处理器同一资源时另一线程必须等待

### 多核处理器的基本概念

多核处理器是指**将多个处理单元集成到单个 CPU 中**，每个处理单元称为一个核 core

每个核可以有自己的 Cache，或共享同一个 Cache

所有核一般都是对称的，且**共享主存储器**，因此多核属于共享存储的对称多处理器

![image-20220614161822245](..\images\image-20220614161822245.png)

在多核计算机系统中，如要充分发挥硬件的性能，必须采用多线程或多进程执行，使得每个核在同一时刻都有线程在执行

在同一时刻，多核上的多线程有多个线程在**并行执行**，而单核上的多线程却**只有一个线程在执行**

假设要将四堆数据进行处理，处理一堆要花费 1 分钟：

- 串行处理器 SISD 会逐一处理数据，花费 4 分钟
- 双核处理器 MIMD 让两个核共同处理数据，花费 2 分钟
- 向量处理器 SIMD 在向量寄存器上放四堆数据（同操作时），用 4 个 ALU 共同处理，只需要 1 分钟

选择题：双核 CPU 可以降低计算机系统的功耗和体积，同样性能单核功耗和体积会更高

### 共享内存多处理器的基本概念

共享内存多处理器 SMP：**共享的单一物理地址**，通过存储器中的**共享变量互相通信**，通过存取指令**访问任何存储器的位置**

注意：在进程中看到的内存地址是一样的，是虚拟地址，它们会映射到不同的物理地址

单一地址空间的多处理器有两种类型：

1. 统一存储访问 UMA 多处理器：每个处理器对所有存储单元的**访问时间是大致相同**的，与处理器及访问位置无关

   根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络、基于多级交换网络连接等处理器

2. 非统一存储访问 NUMA 多处理器：**某些访存请求要比其他的快**，取决于哪个处理器以及访问位置

   处理器中不带高速缓存时，被称为 NC-NUMA；处理器中带有一致性高速缓存时，被称为 CC-NUMA

早期的 CPU，通过前端总线和北桥芯片相连，访存时经过北桥芯片来访存，这就是统一存储访问 UMA 构架

- 北桥芯片：集成了内存控制器，并与内存相连

随着 CPU 数量的增加，为了消除 UMA 架构争用前端总线的时间瓶颈，非统一存储访问 NUMA 构架诞生

- 每个 CPU **内部拥有独立的内存控制器**，独立连接到一部分内存，这部分内存被称为**本地内存**
- CPU 之间通过 QPI 总线相连。CPU 可以通过 QPI 总线访问其他 CPU 的远程内存

与 UMA 架构不同的是，在 NUMA 架构下，**访问本地内存明显要快于访问远程内存**

对于多个处理器同时访问同一共享变量的情况，在操作共享变量时需要进行同步

常用方法是通过**对共享变量加锁**的方式来控制对共享变量互斥访问

一个时刻只能有一个处理器获得锁，其他要操作该共享变量的处理器，须等待到该变量被解锁为止

# 总线

## 总线概述

I/O 设备的种类和数量也越来越多，为了解决 I/O **设备和主机之间连接的灵活性问题**，从分散连接发展为总线连接

选择题：3 通道的存储器，它每次会输出 3 倍总线宽度的数据

选择题：`PCI-Express` 总线都采用串行数据包传输数据

### 总线基本概念

#### 总线的定义

总线是**一组能为多个部件分时共享的公共信息传送线路**，**分时和共享**是总线的两个特点

- 分时：**同一时刻只允许有一个部件向总线发送信息**，系统中有多个部件只能分时地向总线发送信息
- 共享：总线上可以挂接多个部件，**各个部件之间互相交换的信息都可通过这组线路分时共享**
- 在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接收相同的信息

#### 总线设备

总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种

- 主设备：**获得总线控制权的设备**
- 从设备：被主设备访问的设备，它**只能响应从主设备发来的各种总线命令**

#### 总线特性

1. 机械特性：尺寸、形状、管脚数、排列顺序
2. 电气特性：传输方向和有效的电平范围
3. 功能特性：每根传输线的功能（地址、数据、控制）
4. 时间特性：信号的时序关系

#### 总线的猝发传输方式

若使用猝发传输方式在一个总线周期内传输**一次存储地址**就可以**连续读多个数据数据字**，否则**取一个数据字要先传一个地址**

例题：某同步总线的时钟频率为 `100MHz`，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线**支持突发（猝发）**传输方式，则一次“主存写”总线事务传输 128 位数据所需要的时间至少是 `50ns`

解释：总线时钟周期是 `1s/100MHz=10ns`，猝发所以地址只需要传一次，而数据需要传 `128/32=4` 次，所以需要 `50ns`

### 总线的分类

#### 按功能分类

- 片内总线：**片内总线是芯片内部的总线**，它是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线

- 系统总线：系统总线是计算机系统内**各功能部件之间相互连接的总线**，按系统总线传输信息内容的不同分为：

  1. 数据总线：**传输各功能部件之间的数据信息**，它是**双向传输总线**，**位数与机器字长、存储字长有关**
  
  2. 地址总线：指出数据所在的主存或 I/O 端口的地址，它是**单向传输总线**，地址总线的**位数与主存地址空间的大小有关**
  
    3. 控制总线：传输控制信息，包括 CPU 送出的**控制命令**和主存（或外设）返回 CPU 的**反馈信号**
  

  	注意区分数据通路和数据总线：**数据通路是数据流经过的路径**，而**数据总线是承载的媒介**
		
  	选择题：**握手（应答）信号**属于通信联络信号，应在**控制总线**上传输；而**中断信号**会在 CPU 响应后发回**数据总线**

- I/O 总线：**连接中低速的 I/O 设备**，目的是将**低速设备与高速总线分离**，以提升总线的系统性能，常见的有 USB、PCI 总线
- 通信总线：通信总线是在**计算机系统之间**或**计算机系统与其他系统**（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称**外部总线**

#### 按数据传输格式分类

- 串行总线：设备间的数据流动是**一位一位地流动**，只需要一条传输线

  优点：适合长距离传输，节省布线空间；缺点：但数据收发时要进行拆卸和装配

- 并行总线：设备间的数据流动是**多位并行地流动**，逻辑时序简单，实现方便，但信号线多

速度比较：总线带宽 = 总线宽度 × 总线频率

- 并行总线频率较高时，信号线间产生严重干扰，电子速度是光速级别，信号线不够等长，**无法持续提升工作频率**
- 而串行总线可以通过不断**提高工作频率来提高传输速度**，最终**超过并行总线**

#### 按时序控制方式分类*

分为**同步总线、异步总线**，用于总线的同步定时和异步定时

### 系统总线的结构

#### 单总线结构

**将 CPU、主存、I/O 设备都挂在一组总线上**，允许 I/O 设备之间、I/O 设备与主存之间直接交换信息，CPU 与主存、CPU 与外设之间可直接进行信息交换，而无须经过中间设备的干预

![image-20211025191546092](..\images\image-20211025191546092.png)

注意：单总线并**不是指只有一根信号线**，系统总线按传送信息的不同可细分为地址总线、数据总线、控制总线

优点：结构简单，成本低，**易于接入新的设备**；缺点：带宽低、负载重，**多个部件争用唯一的总线，不支持并发传送操作**

#### 双总线结构

一条是主存总线，用于在 **CPU、主存和通道之间传送数据**；另一条是 I/O 总线，用于在**多个外部设备与通道之间传送数据**

![image-20211025192113465](..\images\image-20211025192113465.png)

优点：将低速 I/O 设备从单总线上分离出来，实现了**存储器总线和 I/O 总线分离**；缺点：需要**增加通道等硬件设备**

#### 三总线结构

采用 3 条各自独立的总线来构成信息通路：主存总线、I/O总线、直接内存访问（DMA）总线

![image-20211025192403413](..\images\image-20211025192403413.png)

- 主存总线：CPU 和内存之间传送地址、数据和控制信息
- I/O 总线：CPU 和各类外设之间通信
- DMA 总线：内存和高速外设之间直接传送数据，低速外设是打印机、显示器

优点：**提高了 I/O 设备的性能**，使其更快地响应命令，提高系统吞吐量；缺点：**系统工作效率较低**，三套总线每个时刻只有一套总线在工作

### 总线的性能指标

1. 总线的传输周期（总线周期）：指**一次总线操作所需的时间**，[由数个阶段组成](#总线事务)，通常**由若干总线时钟周期构成**

2. 总线时钟周期：即**机器的时钟周期**，总线也要受计算机的统一的时钟的控制

3. **总线的工作频率**：总线上各种操作的频率，为**总线周期的倒数**，实际上指 1 秒内传送几次数据

4. 总线的时钟频率：即机器的时钟频率，它为**时钟周期的倒数**

5. **总线宽度**：又称总线位宽，它是**总线上同时能够传输的数据位数**，通常指数据总线的根数，如 32 根称为 32 位总线

6. **总线带宽**：**总线的数据传输率**，即单位时间内总线上可传输数据的位数

   通常用**每秒传送信息的字节数**来衡量，总线带宽 = 总线工作频率 × (总线宽度 / 8)

   总线带宽是指总线本身所能达到的**最高传输速率**，它是衡量总线性能的**重要指标**

7. 总线复用：指**一种信号线在不同的时间传输不同的信息**，从而使用更少的线达到节省空间和成本

8. 信号线数：地址总线、数据总线、控制总线 **3 种总线线数的总和称为信号线数**

总线的最主要性能指标为**总线宽度、总线工作频率、总线带宽**；三者关系：总线带宽 = 总线宽度 × 总线频率

### 综合应用题

题目：某总线支持二级 Cache 块传输方式，若每块 6 个字，每个字长 4 字节，时钟频率为 `100MHz`

1. 读操作时，第一个时钟周期接收地址，第二、三个为延时周期，另用 4 个周期传送一个块。求读操作的总线传输速率？
2. 写操作时，第一个时钟周期接收地址，第二个为延时周期，另用4个周期传送一个块，写操作的总线传输速率是多少？
3. 设在全部的传输中，70%用于读，30%用于写，该总线在本次传输中的平均传输速率是多少？

解答：

1. 周期数：1 + 2 + 4 = 7；对应频率：`100MHz / 7`；总线宽度：`6 × 4B = 24B`；数据传输速率：`24 × (100MHz / 7) = 343MB/s`

2. 周期数：1 + 2 + 4 = 6；对应频率：`100MHz / 6`；总线宽度：`6 × 4B = 24B`；数据传输速率：`24 × (100MHz / 6) = 400MB/s`

3. 平均传输速率：`1 / (0.7 × 1 / 343 + 0.3 × 1 / 400) = 358MB/s`，这里的 70% 是表示 70% 的数据

   0.7 × 1 / 343 读 0.7 MB 的时间，0.3 × 1 / 400 写 0.3 MB 的时间，0.7 × 1 / 343 + 0.3 × 1 / 400 处理 `1MB` 数据的时间

## 总线仲裁*

采用**总线仲裁部件**解决**多个主设备同时竞争总线控制权**的问题，选择一个主设备优先获得总线控制权，只有获得了总线控制权的设备，才能开始传送数据

### 集中仲裁方式

集中仲裁方式指**总线控制逻辑集中于一个设备中**，将所有的总线请求集中起来，**用一个特定的裁决算法进行裁决**

#### 链式查询方式

总线上所有部件**共用一根总线请求线、总线忙线**，以及**串联总线允许线**

当一个部件要使用总线（下面两种方式和这里差不多，就只写一次细节）：

1. 对总线请求线发出信号
2. 总线控制部件检查总线忙线是否有效
3. 如果有效，则延迟到失效再发出总线允许信号
4. 总线允许信号从第一个部件一次向后传递，直到被要使用总线的部件截断
5. 这个部件将总线忙线置为有效，开始使用总线，使用完后将总线忙置为无效

![image-20211025215030153](..\images\image-20211025215030153.png)

部件离总线控制器**越近，其优先级越高**；部件离总线控制器**越远，其优先级越低**

优点：链式查询方式优先级固定，结构简单，扩充容易

缺点：对**硬件电路的故障敏感**，且**优先级不能改变**，可能会使优先级低的部件长期不能使用总线

#### 计算器定时查询方式

采用一个计数器控制总线使用权，相对链式查询方式**多了一组设备地址线，少了一根总线响应线 `BG`**

1. 把计算器的数放入设备地址线，每个请求的部件比较自己的地址与设备地址线的地址，相等就置总线忙有效

2. 总线控制部件检查总线忙线，如果有效就终止；无效就把计数器加 1，回到第 1 步

![image-20211026134408697](..\images\image-20211026134408697.png)

优点：计数**从 0 开始**，则优先级**和链式查询一样**；计数**从上一次的终点开始**，此时设备使用总线的**优先级相等**；计数器的初值**由程序设置**，**优先次序可以改变**，且这种方式对**电路的故障没有链式查询方式敏感**

缺点：**增加了控制线数**，需要 $\lceil\log_2n\rceil+2$ 条控制线，控制也比相对链式查询要**复杂**

#### 独立请求方式

每个设备均有一对总线请求线 $BR_i$ 和总线允许线 $BG_i$，也共用一个总线忙线（没画出来）

1. 当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在**总线控制器中排队**（按一定的优先次序）
2. 当总线控制器批准某个部件的请求时，给该部件发送总线响应信号，接到此信号后就获得了总线使用权，开始传送数据

![image-20211026140238579](..\images\image-20211026140238579.png)

优点：响应速度快，总线允许信号 `BG` **直接从控制器发送到有关设备**，而且**对优先次序的控制相当灵活**

缺点：**控制线数量多**，需要 `2n + 1` 条控制线，总线控制逻辑更复杂

#### 三种方式的联系与区别

![image-20211026140330442](..\images\image-20211026140330442.png)

### 分布仲裁方式

分布仲裁方式**不需要中央仲裁器**，每个潜在的主模块**都有自己的仲裁号和仲裁器**

当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较

若仲裁总线上的仲裁号优先级高，则它的总线请求不予响应，并撤销它的仲裁号，**最后获胜者的仲裁号保留在仲裁总线上**

## 总线操作和定时

### 总线事务

从**请求总线到完成总线**使用的操作序列称为总线事务，它是在**一个总线周期中**发生的一系列活动

一个总线事务通常可分为以下阶段，有的书是 5 个阶段：

1. 申请分配阶段：由主模块（CPU 或 DMA）**提出申请**，然后**仲裁**出下总线使用者，可分为**请求阶段**和**仲裁阶段**
2. 寻址阶段：主模块通过总线**发出本次要访问的从模块的地址及有关命令**，启动从模块
3. 传输阶段：主模块和从模块**进行数据交换**，可单向或双向进行数据传送，一般只能传输**一个字长**的数据
4. 结束阶段：主模块的有关信息均从系统总线上撤除，**让出总线使用权**

突发（猝发）传送方式：进行连续成组数据的传送

- 寻址阶段：发送连续数据单元的**首地址**
- 传输阶段：**传送多个连续单元的数据**，每个时钟周期传送一个字
- 结束阶段：当一组数据**全部传送完毕**后，释放总线

总线定时是指**总线在双方交换数据的过程中需要<u>时间上配合</u>关系的控制**，其实质是一种协议或规则

### 同步定时方式

指使用**统一的时钟信号**和**统一的总线周期**，在一个总线周期中，发送方和接收方可以进行一次数据传送

每个部件或设备发送或接收信息都在固定的总线传送周期中，**一个总线的传送周期结束，下一个总线的传送周期开始**

优点：**传送速度快**，具有较高的传输速率；总线控制逻辑简单

缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，**可靠性较差**，如从模块突然不能按时完成传输

同步通信适用于**总线长度较短**及总线**所接部件的存取时间比较接近**的系统

额外：串行同步通信使用多个字符组成信息组，在传输数据的同时还需要传输时钟信号，根据时钟信号来同步

### 异步定时方式

没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的**握手信号来实现定时控制**

**主设备提出交换信息的请求信号**，经接口传送到从设备；**从设备**接到主设备的请求后，通过接口向主设备**发出回答信号**

优点：**总线周期长度可变**，能保证两个**工作速度相差很大的部件或设备之间可靠地进行信息交换**，自动适应时间的配合

缺点：比同步控制方式稍复杂一些，**速度比同步定时方式慢**

根据请求和回答信号的撤销是否互锁，分为以下 3 种类型：

1. 不互锁方式：双方会自动撤销信号；可靠性最差，速度最块
   - 主设备发出请求信号后，经过一段时间**自动撤销请求信号**
   - 从设备在接到请求信号后，发出回答信号，经过一段时间后**自动撤销回答信号**
2. 半互锁方式：只有一方自动撤销信号
   - 主设备发出请求信号后，必须**在从设备回答后才撤销请求信号**
   - 从设备在接到请求信号后，发出回答信号，经过一段时间后**自动撤销回答信号**
3. 全互锁方式：必须等响应后才能撤销信号；可靠性最好，速度最慢
   - 主设备发出请求信号后，必须**在从设备回答后才撤销请求信号**
   - 从设备发出回答信号后，必须在获知**主设备请求信号已撤销后，再撤销其回答信号**

![image-20211026165026428](..\images\image-20211026165026428.png)

额外：串行异步通信，收发双方取得同步是通过在字符格式中设置**起始位和停止位**的方法来实现的，[完整内容](https://cloud.tencent.com/developer/news/564920)

- 一定会包含起始位和停止位，即使题目没有说明，在计算时也要包含进去

额外：同步定时方式传输一般是以**多个字符组成的块**为单位，而异步定时方式以**字符**为单位

### 半同步通信

**半同步通信是同步定时方式和异步定时方式的结合**，会采用统一的时钟周期，在传数时会等待（异步），因此总线周期不同

![image-20220615205518237](..\images\image-20220615205518237.png)

1. 主设备发送地址
2. 主设备发送读命令
3. 主设备检查 $\overline{WAIF}$ 若为 0 表示从设备还没准备好
4. 主设备发现 $\overline{WAIF}$ 为 1 就读从设备的数据，然后取消读命令，然后放开地址

### 分离式通信

在主设备发送地址到从设备准备好地址这段时间里，总线是空闲的，为了利用这段时间，让从设备也可以发出总线申请

主设备发送完地址后就把总线释放掉，等从设备准备好数据，再把总线申请回来

特点：

1. 各模块均有权申请占用总线
2. 采用同步方式通信，不等对方回答
3. 各模块准备数据时，不占用总线
4. 总线利用率提高

## 总线标准

### 总线标准的基本概念

总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范

按总线标准设计的接口可视为通用接口，在接口的两端，任何一方**只需根据总线标准的要求完成自身方面的功能要求**

即插即用 Plug-and-Play：**把设备插入总线上就可以用**，配置是自动的，需要总线提供一定的硬件支持

热插拔 hot-plugging 或 Hot Swap：即**带电插拔**，需要总线提供一定的硬件支持

思考：使用总线系统有一部分原因是为了降低成本，高速的总线成本高，而低速的硬件配高速总线没什么用，所以直接给他配了成本低的低速总线；还有一部分原因是为了把计算机分成多个模块等

### 常见的总线标准

![image-20211026200156541](..\images\image-20211026200156541.png)

#### 系统总线标准

系统总线指连接计算机系统各个部件的总线

1. **ISA，Industry Standard Architecture，工业标准体系结构**：是最早出现的微型计算机的系统总线，也叫 PC/AT 总线

   **数据传输需要 CPU 或 DMA 接口来管理，不支持总线仲裁**

2. **`EISA`，Extended Industry Standard Architecture，扩展的 ISA**：是为配合 32 位 CPU 而设计的扩展总线

   **`EISA` 对 ISA 完全兼容**，从 CPU 分离出了总线控制权，**支持多个总线主控制器和突发传输**

#### 局部总线标准

为了解决系统总线太慢的问题，引用局部总线把高速设备单独连接到 CPU，有**节省系统总带宽**的作用

1. **`PCI`，Peripheral Component Interconnect，外部设备互连**：32 或 64 位数据线，比 `EISA` 更高的工作频率

   不依附于某个具体的处理器，**支持突发传送**；**支持即插即用**；可扩充性好，**可采用多层结构提高驱动能力**

   `PCI` 总线是**独立于 CPU 的局部总线**，可将高速的外围设直接挂在 CPU 总线上如网卡、声卡等；半同步总线

2. `AGP，Accclerated Graphics Port`，加速图形接口：解决 `PCI` 对 3D 显卡力不从心的问题，是**显卡专用**的局部总线

3. **`PCI-Express(PCI-E)`：最新标准，它取代了 `PCI` 和 `AGP` 统一总线标准**；**点对点串行连接方式**；**支持热插拔**

4. `VESA`，Video Electronics Standards Association，视频电子标准协会：**针对视频的 32 位局部总线**

   由 CPU 总线演化而来，是针对多媒体 PC 要求**高速传送活动图像的大量数据**应运而生的

#### 设备总线标准

设备总线主要用于把外设接入计算机系统

1. **`USB`，Universal Serial Bus，通用串行总线**：`USB` 属于设备总线，是**设备和设备控制器之间的接口**

   **可以热插拔、即插即用；具有很强的连接能力和很好的可扩充性；标准统一；高速传输；可为低压外设供电**

2. `RS-232C`，Recommended Standard，RS：是由美国电子工业协会（`EIA`）推荐的一种**串行通信总线**，是应用于**串行二进制交换的数据终端设备**（`DTE`）和**数据通信设备**`(DCE`）之间的标准接口

3. `IDE`，Integrated Drive Electronics，集成设备电路：也称 `ATA`，**硬盘和光驱**通过 `IDE` 接口与主板连接

4. `SATA`，Serial Advanced Technology Attachment，串行高级技术附件：是一种基于行业标准的**串行硬盘接口**

5. SCSI，Small Computer System Interface，小型计算机系统接口：是一种用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）系统级接口的独立处理器标准，SCSI 是一种智能的通用接口标准

6. `PCMCIA`，Personal Computer Memory Card International Association：是广泛应用于笔记本电脑的一种接口标准，是一个用于扩展功能的小型插槽。`PCMCIA` 具有即插即用功能

#### *视频线的标准

1. VGA，Video Graphics Array，也称为 D-sub 端口，传输模拟信号 CRT 显示器
2. `DVI`，Digital Visual Interface，传输数字信号
3. `HDMI，High Definition MultimediaInterface` 理论最大传输速度可达 `Gb/s` 影像数据 + 8 声道的音讯信号源于 `DVI` 技术

# 输入输出系统

## I/O 系统基本概念*

### 输入/输出系统

输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出

输入/输出系统解决的主要问题是**对各种形式的信息进行输入和输出的控制**

I/O 系统中的几个基本概念如下：

- 外部设备：包括<u>输入/输出设备</u>及<u>通过输入/输出接口才能访问的外存储设备</u>
- 接口：在各个外设与主机之间传输数据时进行各种<u>协调工作的逻辑部件</u>，包括传输过程中速度的匹配、电平和格式转换等
- 输入设备：用于向计算机系统输入命令和文本、数据等信息的部件
- 输出设备：用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件
- 外存设备：指<u>除计算机内存及 CPU 缓存等外的存储器</u>

### I/O 系统的构成

一般来说，I/O 系统由 I/O 软件和 I/O 硬件两部分构成：

- I/O 软件：包括驱动程序、用户程序、管理程序、升级补丁等

  通常采用 I/O 指令和通道指令实现 CPU 与 I/O 设备的信息交换

  - I/O 指令：一条指令包括**操作码、命令码、设备码**，是 **CPU 的指令**，但**和通用指令格式不一样**

    操作码：说明要进行 I/O 操作；命令码：做什么操作；设备码：对谁操作

  - 通道指令：指出数据的首地址、传送字数、操作命令；**通道指令放在内存中**，由通道取出执行

    **CPU 执行启动 I/O 设备指令**，启动**通道代替 CPU 对 I/O 设备进行管理**
    
    注意：**在具有通道结构的机器中**，I/O 指令**不实现 I/O 数据传送**，主要完成 I/O 设备的和通道的查询与控制

- I/O 硬件：包括外部设备、设备控制器和接口、I/O 总线等

  <u>通过设备控制器来控制 I/O 设备的具体动作</u>；<u>通过 I/O 接口与主机（总线）相连</u>

  在操作系统中，通常把 <u>I/O 接口和设备控制器</u>合在一起叫做设备控制器，通常是一块插入主板扩充槽的印刷电路板

思考：I/O 接口和设备控制器一起构成了计算机的接口，左边是 I/O 接口右边是设备控制器（复杂的 I/O 设备才有）

注意：I/O 端口是可以被 CPU 访问的寄存器，而 I/O 端口 + 控制逻辑 = I/O 接口

### I/O 控制方式

在输入/输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的 I/O 控制方式：

1. 程序查询方式：CPU 启动 I/O 工作后**查询等待并传输 I/O 数据**
2. 程序中断方式：启动 I/O 工作后，**数据就绪时向 CPU 发出中断请求**，CPU 保存状态后传输 I/O 数据
3. DMA 方式：启动 I/O 工作后，**数据就绪时向 CPU 发出 DMA 请求**，数据由 DMA 传输，但**传输时 CPU 不能访存**
4. 通道方式：CPU 要进行 I/O 操作时，只需启动有关通道，通道将执行通道程序，从而完成 I/O 操作（超多 I/O 时用）

方式 1 和方式 2 主要用于**数据传输率较低的外部设备**（会影响 CPU 执行）；方式 3 和方式 4 主要用于**数据传输率较高的设备**

选择题：在 1, 2, 4 方式中运输数据都是程序控制方式即软件方式（使用指令），只有 DMA 是通过硬件来运输数据

## 外部设备*

### 输入设备

#### 键盘

键盘是最常用的输入设备，通过它可发出命令或输入数据

键盘通常以矩阵的形式排列按键，每个键用符号标明其含义和作用

每个键相当于一个开关，<u>按下键时，电信号连通；松开键时，弹簧弹起键，电信号断开</u>

键盘输入信息可分为 3 个步骤：

1. 查出按下的是哪个键
2. 将该键翻译成能被主机接收的编码，如 ASCII 码
3. 将编码传送给主机

#### 鼠标

鼠标是常用的定位输入设备，它<u>把用户的操作与计算机屏幕上的位置信息相联系</u>，常用的鼠标有机械式和光电式两种

工作原理：鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动

### 输出设备

#### 显示器

按显示设备所用的显示器件分类，有阴极射线管显示器、液晶显示器、发光二极管显示器等

按显示信息内容不同，分为字符显示器、图形显示器和图像显示器；按扫描方式不同，分为光栅扫描和随机扫描两种显示器

##### 常用参数

屏幕大小：以**对角线长度**表示，常用的有 12～29 英寸等

分辨率：所能表示的**像素个数**，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示

灰度级：指显示器颜色的个数，**n 位可以表示 $2^n$ 种不同的亮度或颜色**，如黑白图是 8 位表示 256 种颜色

刷新：光点在保持极短的时间后消失，必须**在光点消失前再重新扫描显示一遍**，这个过程称为刷新

刷新频率：指**单位时间内扫描整个屏幕内容的次数**；通常刷新频率为 `60～120Hz`，大于 `30Hz` 时才不会感到闪烁

显示存储器 `VRAM`：也称刷新存储器，为了不断提高刷新图像的信号，必须**把一帧图像信息存储在刷新存储器中**

存储容量**由图像分辨率和灰度级决定**，**`VRAM 容量 = 分辨率 × 灰度级位数`**；**`VRAM 带宽 = 分辨率 × 灰度级位数 × 帧频`**

##### 阴极射线管 CRT 显示器

CRT 显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极、荧光粉涂层和玻璃外壳 5 部分组成

具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短等目前 LCD 难以超过的优点

- 字符显示器：显示字符的方法以点阵为基础，**点阵是指由 m × n 个点组成的阵列**

  将**点阵存入由 ROM 构成的字符发生器中**，在 CRT 进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中 0 和 1 代码的不同控制扫描电子束的开或关，从而在屏幕上显示字符

  对应于每个字符窗口，**所需显示字符的 ASCII 代码被存放在视频存储器 `VRAM` 中**，以备刷新

  注意：**字符显示器的 `VRAM` 是屏幕可显示字符的个数 × 用于表示字符的位数**

- 图形显示器：将所<u>显示图形的一组坐标点和绘图命令组成显示文件</u>存放在缓冲存储器中

  缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接<u>控制电子束在屏幕上的移动</u>

  目前高质量的图形显示器采用<u>随机扫描方式</u>，优点是分辨率高且显示的曲线平滑；缺点是当显示复杂图形时，会有闪烁感

- 图像显示器：用于显示图像，比上面两个复杂很多

<u>光栅扫描：指一行一行的刷新；随机扫描：只对要显示的区域扫描</u>

##### 液晶显示器 LCD

原理：利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示

特点：体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼等

##### LED 发光二极管显示器

原理：通过控制半导体发光二极管来显示文字、图形、图像等各种信息

LCD 是由液态晶体组成的显示屏，而 LED 则是由发光二极管组成的显示屏

与 LCD 相比，LED 显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势

#### 打印机

打印机是计算机的输出设备之一，<u>用于将计算机的处理结果打印在相关介质上</u>

按工作原理，分为击打式和非击打式；按工作方式，分为点阵打印机、针式打印机、喷墨式打印机、激光打印机等

##### 针式打印机

原理：在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需的内容

特点：针式打印机擅长多层复写打印，<u>实现各种票据或蜡纸等的打印</u>，其工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高

##### 喷墨式打印机

原理：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形，彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色的墨滴，按一定的比例混合出所要求的颜色

特点：<u>打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快</u>；但防水性差，高质量打印需要专用打印纸

##### 激光打印机

原理：计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像

特点：<u>打印质量高、速度快、噪声小、处理能力强</u>；但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高

激光打印机是将激光技术和电子显像技术相结合的产物，感光鼓（也称硒鼓）是激光打印机的核心部件

## I/O 接口

I/O 接口（I/O 控制器）是**主机和外设之间的交接界面**，通过接口可以实现**主机和外设之间的信息交换**

主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了解决这些差异而设置的

### I/O 接口的功能

I/O 接口的主要功能如下：

1. 实现主机和外设的通信联络控制：**解决主机与外设时序配合问题**，协调不同工作速度的外设和主机之间交换信息

2. 进行地址译码和设备选择：CPU 送来选择外设的地址码后，接口**告诉主机自己是否被选中**

3. 实现数据缓冲：**解决 CPU 与外设之间的速度不匹配问题**，以避免因速度不一致而丢失数据

4. 信号格式的转换：外设与主机两者的电平、数据格式都会有差异，接口应提供**计算机与外设的信号格式的转换功能**

5. 传送控制命令和状态信息：

   CPU 要启动某一外设时：

   - 通过接口中的命令寄存器向外设**发出启动命令**

   - 外设准备就绪时，则将**“准备好”状态信息送回接口中的状态寄存器**，并反馈给 CPU

   外设向 CPU 提出**中断请求**时，CPU 也应有相应的**响应信号**反馈给外设

思考：I/O 设备执行完命令（准备就绪）后**向 I/O 数据线上发送中断信息**，CPU 执行完一条指令后检查 I/O 数据线信号，如果发生中断就进入中断周期，然后根据中断码执行相应的程序把 I/O 设备的数据进行处理

### I/O 接口的基本结构

I/O 接口在主机侧通过 I/O 总线与内存、CPU 相连

![image-20220617151111680](..\images\image-20220617151111680.png)

通过**数据总线**，在**数据缓冲寄存器**与**内存或 CPU 的寄存器**之间进行**数据传送**

同时**接口和设备的状态信息**被记录在状态寄存器中，通过**数据线将状态信息送到 CPU**

CPU 对外设的**控制命令也通过数据线传送**，一般将其送到 **I\O 接口的控制寄存器**

状态寄存器和控制寄存器在传送方向上是相反的，它们**可以是两个寄存器，也可以是一个寄存器**

![image-20211028190040751](..\images\image-20211028190040751.png)

数据总线、地址总线、控制总线的作用：

- 数据线用于传输**外设的数据、命令字（控制字）、状态字、中断类型号**
- 接口中的地址线用于给出**要访问的 I/O 接口中的寄存器的地址**（<u>地址码</u>），用以选择和主机交换信息的寄存器
- 同时控制线传送来读/写信号**确认是读还是写寄存器**，此外控制线还会传送一些**仲裁信号、握手信号、中断请求信息**

接口对命令的处理：

- 将命令写入控制寄存器后，接口中的 I/O 控制逻辑会**对其内的命令字进行译码**
- **将译码得到的控制信号**通过外设界面控制逻辑**送到外设**
- 同时**将数据缓冲寄存器的数据发送到外设**，或**从外设接收数据到数据缓冲寄存器**
- 另外，它还会**收集外设状态到状态寄存器**

对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为 **I/O 指令**

I/O 指令只能在操作系统内核的底层 I/O 软件中使用，它们是一种**特权指令**

思考：CPU 根据端口对接口的寄存器进行读写，然后接口根据寄存器的内容进行解析并给外设发出命令

额外：一个 I/O 接口可以连多个外设，所以在 I/O 接口中准备多套寄存器与外设一一对应，从而进行区分

### I/O 接口的类型

从不同的角度看，I/O接口可以分为不同的类型：

1. 按数据传送方式可分为**并行接口和串行接口**，接口要完成数据格式的转换

   注意：这里指的是**外设和接口一侧的传送方式**，而在**主机和接口一侧，数据总是并行传送的**（现在是串行的）

2. 按主机访问 I/O 设备的控制方式可分为**程序查询接口、中断接口和 DMA 接口**等

3. 按功能选择的灵活性可分为**可编程接口和不可编程接口**

### I/O 端口及其编址

I/O 端口是指**接口电路中可被 CPU 直接访问的寄存器**，主要有**数据端口、状态端口和控制端口**，若干**端口加上相应的控制逻辑电路组成接口**

CPU 能**对数据端口执行读写操作**，但**对状态端口<u>只能执行读操作</u>**，对**控制端口<u>只能执行写操作</u>**

I/O 端口要想能够被 CPU 访问，就必须要**对各个端口进行编号，每个端口对应一个端口地址**：

- 统一编址，存储器映射方式：是指把 I/O 端口**当作存储器的单元进行地址分配**，用访存指令就可以访问 I/O 端口

  其对应的 **I/O 地址要求固定在地址的某个部分**，可以前面、中间、后面，但是要固定

  优点：**不需要专门的 I/O 指令**，可使 CPU 访问 I/O 的操作更灵活、更方便，还可**使端口有较大的编址空间**

  缺点：**端口占用存储器地址**，使内存容量变小而且利用存储器编址的 I/O 设备进行数据输入/输出操作，**执行速度较慢**

- 独立编址，I/O 映射方式：I/O 端口的地址空间与主存地址空间是两个独立的地址空间

  无法从地址码的形式上区分，**需要设置专门的 I/O 指令来访问 I/O 端口**

  优点：**输入/输出指令与存储器指令有明显区别**，程序编制清晰，便于理解

  缺点：I/O 指令功能少，一般只能对端口进行传送操作；<u>需要 CPU 提供存储器读/写、I/O 设备读/写**两组控制信号**</u>，增加了**控制的复杂性**

## I/O 方式

### 程序查询方式

信息交换的控制**完全由主机执行程序实现**，主机进行 I/O 操作时，根据**读取设备的状态**决定进行**数据传送还是等待**

程序查询方式的工作流程如下：

1. CPU 执行初始化程序，并**预置传送参数**
2. 向 I/O 接口发出命令字，**启动 I/O 设备**
3. 从外设接口**读取其状态信息**
4. CPU **不断查询 I/O 设备状态，直到外设准备就绪**
5. **传送一次数据**
6. **修改地址和计数器参数**
7. **判断传送是否结束**，若未结束转第 3 步，直到计数器为 0

![image-20211029145846405](..\images\image-20211029145846405.png)

在这种控制方式下，CPU 一旦启动 I/O，就**必须停止现行程序的运行，并在现行程序中插入一段程序**

程序查询方式的主要特点是 CPU 有踏步等待现象，**CPU 与 I/O 串行工作**

优点：接口设计简单、设备量少；缺点：CPU **花费时间来查询和等待**，**一段时间内只能和一台外设交换信息**，效率大大降低

### 程序中断方式

现代计算机系统中都配有完善的异常和中断处理系统，CPU 的**数据通路**中有相应的**异常和中断的检测和响应逻辑**

<u>在外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序</u>

#### 异常和中断

##### 异常

异常是指**由 CPU 内部（包括内存）异常引起的意外事件**，分为硬故障中断和程序性异常

- 硬故障中断：**由硬连线出现异常引起的**；如电源掉电、存储器线路错等
- 程序性异常：也称软中断，是指在 CPU 内部因**执行指令而引起的**异常事件

按发生异常的报告方式和返回方式不同，**内部异常**可分为故障、自陷、终止三类：

###### 故障 Fault

**指在引起故障等指令启动后、执行结束前，被检测到的异常事件**，分为可恢复异常和不可恢复异常

- 对于缺段、缺页等异常：将所需的段或页面调入主存后，**可回到发生故障的指令继续执行**，断点为当前发生故障的指令
- 对于非法操作码、除数为 0 等异常：无法通过异常处理程序恢复故障，因此**不能回到原断点执行，必须终止进程的执行**

###### 自陷 Trap

自陷也称陷阱或陷入，它是**预先安排的一种异常事件**，就像预先设定的陷阱一样

自陷可以看作是**为程序员提供的程序**，并提供特定的指令去调用，执行完返回自陷指令的下一条指令执行

注意：当自陷指令是转移指令时，并不是返回到下一条指令执行，而是<u>返回到转移目标指令执行</u>

<u>程序调试的断点设置、系统调用指令、条件自陷指令</u>等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动**调出操作系统内核程序进行执行**

###### 终止 Abort

如果在执行指令的过程中发生了使**计算机无法继续执行的硬件故障**，如电源掉电、线路故障等

那么程序将无法继续执行，只能终止，此时，**调出中断服务程序来重启系统**

这种异常与故障和自陷不同，**不是由特定指令产生的**，而是随机发生的

##### 外部中断

外中断是指**来自 CPU 外部**、与 CPU 执行**指令无关的事件引起的中断**，包括 <u>I/O 设备发出的 I/O 中断，外部信号中断，以及各种定时器引起的时钟中断</u>等；外中断在狭义上一般称为中断，**若未说明，一般是指外中断**

外中断和内部异常在本质上是一样的，但它们之间有以下两个重要的不同点：

1. 缺页或溢出等**异常事件是由特定指令在执行过程中产生的**；外中断**不和任何指令相关联，也不阻止任何指令的完成**
2. **异常的检测是由 CPU 自身完成**的，不必通过外部的某个信号通知 CPU；对于中断，CPU 必须**通过总线获取中断源的标识信息**，才能获知哪个设备发生了何种中断

有些教材也将异常和中断统称为中断，将由 **CPU 内部产生的异常称为内中断**，将**通过中断请求线 `INTR` 和 `NMI` 从 CPU 外部发出的中断请求称为外中断**

注意：异常事件在**当前指令执行过程中**进行检测，中断请求则在**当前指令执行后**进行检测

选择题：Cache 缺失是使用 CPU 内部硬件进行处理的，不使用异常处理程序

#### 中断的基本概念

程序中断：在执行程序工程中，出现急需处理的异常或特殊请求，就**暂停程序处理请求，处理完后再返回断点执行原程序**

程序中断的作用如下：

1. 实现 **CPU 与 I/O 设备的并行工作**
2. **处理硬件故障和软件错误**
3. 实现人机交互，**用户干预机器需要用到中断系统**
4. 实现多道程序、分时操作，**多道程序的切换需借助于中断系统**
5. 实时处理需要借助中断系统来**实现快速响应**
6. 实现**应用程序和操作系统（管态程序）的切换**，称为软中断
7. 多处理器系统中**各处理器之间的信息交流和任务切换**

程序中断方式的思想：

1. CPU 在程序中安排好于某个时刻**启动某台外设后<u>继续执行</u>原来的程序**，不用一直等待外设准备就绪
2. 一旦外设**完成数据传送的准备工作**，就主动向 CPU **发出中断请求**，请求 CPU 为自己服务
3. 在可以响应中断的条件下，CPU **暂时中止正在执行的程序**，转去执行中断服务程序为外设服务
4. 在中断服务程序中**完成一次主机与外设之间的数据传送**，传送完成后，CPU **返回原来的程序**

![image-20211029165250647](..\images\image-20211029165250647.png)

思考：外设把数据准备好后，放到接口的数据寄存器中，然后发中断通知 CPU 取数据，可能为：

- 自己继续准备数据，如果自己再次准备好数据后 CPU 还没有取走数据，那么会把接口的数据寄存器的原数据覆盖了
- 等 CPU 响应中断了，自己再继续准备数据，与 CPU 执行中断服务程序并行，这样不会覆盖原数据，但会比上面慢

#### 中断分类与判优

##### 中断分类

1. 重新启动中断：这是为**操作人员重新启动一个程序**用的，在一般情况下，处理机不能禁止这类中断

2. 机器检验错中断：当**发生硬件或软件故障时**发生机器校验错中断

   包括有<u>电源故障、运算器误动作、主存储器校验错、输入输出通道硬件故障、处理机的其它各种故障</u>等

3. 程序性错误引起的中断：**执行指令中出现错误**

   主要包括指令或数据格式错误，在程序执行过程中出现<u>非法指令、主存保护错误、地址越界、运算溢出、除数为零、有效位为零、用户态下使用管态指令、断点、单步跟踪、栈溢出、缺页、分时系统中的时间片中断、用户态到核心态的切换</u>等

4. 访问管理程序中断：当**用户程序要调用管理程序**时，执行访管指令引起的中断，处理机一般不能禁止这类中断

5. 外部事件中断：**与 CPU 执行指令无关的事件引起的中断**，包括各种用于记时、记费、控制的定时器中断

6. 输入输出中断：用于**处理机管理各种外围设备**，管理通道处理机等

选择题：机器检验错中断 > 访管指令中断 > 程序性中断 > 外部中断 > 重新启动中断

选择题：用户程序需要输入/输出时，需要调用操作系统提供的接口，此时会引起访管中断

##### 中断判优

中断系统在**一瞬间只能响应一个中断源的请求**，多个中断源同时提出请求时，通过**中断判优逻辑确定响应哪个中断源的请求**

中断判优**既可以用硬件实现，又可用软件实现**：

- 硬件实现是通过硬件排队器实现的，它既可以设置在 CPU 中，又可以分散在各个中断源中
- 软件实现是通过查询程序实现的

一般来说，**优先级的划分为**：

1. 不可屏蔽中断 > 内部异常 > 可屏蔽中断
2. 内部异常中，硬件故障 > 软件中断
3. DMA 中断请求 >  I/O 设备传送的中断请求
4. 在 I/O 传送类中断请求中，高速设备 > 低速设备，输入设备 > 输出设备，实时设备 > 普通设备

中断优先级包括**响应优先级和处理优先级**，响应优先级在硬件线路上是**固定的**；处理优先级可利用中断屏蔽技术**动态调整**

#### 程序中断方式工作流程

##### 中断请求

**中断源是请求 CPU 中断的设备或事件**，一台计算机允许有多个中断源，每个中断源向 CPU 发出中断请求的时间是随机的

中断系统需对**每个中断源设置中断请求标记触发器 `INTR`**，当其状态为 1 时，表示中断源有请求

这些触发器可**组成中断请求标记寄存器**，该寄存器可**集中在 CPU 中**，也可分散在各个中断源中

**内中断皆为不可屏蔽中断**，而外中段要根据发出的信号线而定：

- 通过 `INTR` 信号线发出的外中断是**可屏蔽中断**，在关中断 **(IF=1) 的情况下才会被响应**，若**没有特别说明，就是指本中断**

- 通过 `NMI` 信号发出的外中断是**不可屏蔽中断**，即使在关中断 **(IF=0) 的情况下也会被响应**

  仅**处理紧急和重要的事件**，如时钟中断、电源掉电等，其优先级最高；而**外部设备不能发出这个中断**

**不可屏蔽中断的处理优先级最高**，任何时候发生不可屏蔽中断，都要中止现行程序的执行，转到不可屏蔽中断处理程序执行

##### CPU 响应中断的条件

CPU 响应中断必须满足：

1. 中断源**有中断请求**，即有中断请求触发器处于 1 状态

   外设发送了中断请求且被外设接口中断允许触发器允许（允许触发器置 1）

2. **CPU 允许中断**即开中断，即 CPU 内的中断屏蔽触发器是开放的

3. **一条指令执行完毕**，且没有更紧迫的任务

注意：对于**外中断**，CPU 在每条**指令执行阶段的结束时刻**向接口发出中断查询信号，以获取 I/O 的中断请求

##### 中断响应

CPU 响应中断后，经过某些由**硬件直接实现**的操作，转去执行中断服务程序，称这些操作为**中断隐指令**，它**无法被用户使用**

它所完成的操作如下：

1. 关中断：为了在保护程序的断点和现场信息的过程中，**不能被其他中断打扰**，导致信息没保存好，必须先关闭中断
2. 保存断点：为保证在中断服务程序执行完毕后能**正确地返回到原来的程序**，必须将原来程序的断点保存起来
3. 引出中断服务程序：实质是**取出中断服务程序的入口地址并传送给程序计数器 PC**

其中**断点信息**为：**程序计算器 PC 和状态标志寄存器 `PSWR`** 的内容，因为指令无法访问它们

##### 中断向量

每个中断都有一个类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址

使用存储器某个空间**存放系统的全部中断向量**，这个空间叫做**中断向量表**，可以**根据中断类型号在中断向量表找到中断向量**

中断向量法：CPU 响应中断后，<u>中断硬件会自动将中断向量地址传送给 CPU</u> 来实现程序的切换

向量中断：**采用中断向量法的中断**，要使用中断向量法得有中断向量表等一系列的东西

注意：**中断向量**是**中断服务程序的入口地址**；**中断向量地址**是指**中断服务程序的入口地址的地址**

##### 中断处理过程

大部分计算机，中断处理流程如下：

1. 关中断：在**保护断点和现场期间不能被新的中断所打断**，必须关中断，通过设置 IF 实现

   否则若断点或现场保存不完整，就不能正确地恢复并继续执行现行程序

2. 保存断点：断点可以**压入堆栈**，也可以**存入主存的特定单元中**，断点信息无法由软件访问，故**由硬件实现**

   被中断时的程序状态字寄存器 **PSWR 的内容也需要保存在栈或特定寄存器中**，在异常和中断返回时恢复到 PSWR 中

3. 引出中断服务程序：中断服务程序的入口地址的获得方式，硬件向量法和软件查询法

   异常大多采用软件识别方式，而中断可以采用软件识别方式或硬件识别方式

   - 硬件向量法：**通过硬件产生中断向量地址（中断类型），再由中断向量地址找到中断服务程序的入口地址**
   - 软件查询法：CPU 设置一个异常状态寄存器，记录异常原因。操作系统用统一的异常或中断查询程序，按优先级顺序查询异常状态寄存器，检测**异常和中断类型**，先查询到的先被处理；显然软件灵活但效率底

   注意：硬件产生的实际上是**中断类型号**，而中断类型号**指出了中断向量存放的地址**，因此能产生中断向量地址

4. 保存现场和屏蔽字：进入中断服务程序后首先要保存**现场和中断屏蔽字**，现场信息是指**用户可见的工作寄存器的内容**

   注意：现场和断点，这两类信息都**不能被中断服务程序破坏**，现场信息可以**直接用指令保存到栈中**，由软件实现

5. 开中断：**允许更高级中断请求得到响应**，实现中断嵌套

6. 执行中断服务程序：这是中断请求的目的

7. 关中断：**保证在恢复现场和屏蔽字时不被中断**

8. 恢复现场和屏蔽字：**将现场和屏蔽字恢复到原来的状态**

9. **开中断**、中断返回：中断服务程序的最后一条指令通常是一条**中断返回指令**，返回到原程序的断点处，继续执行原程序

1~3 在 CPU 进入中断周期后，由**中断隐指令（硬件自动）完成**；4~9 由中断服务程序完成

注意：对于单重中断系统，中断只会在最后才开回来，中间不会开的，因为不能嵌套中断

#### 多重中断和中断屏蔽技术

在 CPU 在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求：

- 单重中断：**CPU 对新的中断请求不予响应**
- 多重中断，中断嵌套：**CPU 暂停现行的中断服务程序，转去处理新的中断请求**

![image-20211029201233691](..\images\image-20211029201233691.png)

**中断屏蔽技术主要用于多重中断**，CPU 要具备多重中断的功能，必须满足下列条件：

1. 在中断服务程序中提前**设置开中断指令**
2. **优先级别高的中断源有权中断优先级别低的中断源**

<u>每个中断源都有一个屏蔽触发器</u>，**1 表示屏蔽该中断源的请求，0 表示可以正常申请**，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字；在中断程序中会设置屏蔽字；下面给个例题说明如何求屏蔽字

注意：优先次序是**排队器**实现的，是多个中断一起发送时**谁先响应**；处理次序是屏蔽字实现的，是多个中断**谁先执行完**

![image-20220617155354774](..\images\image-20220617155354774.png)

------

题目：设某机有 4 个中断源 A、B、C、D 其硬件排队优先次序为 A>B>C>D 现要求将中断处理次序改为 D>A>C>B

1. 写出每个中断源对应的屏蔽字

2. 时间轴给出的 4 个中断源的请求时刻，画出 CPU 执行程序的轨迹。设每个中断源的中断服务程序时间均为 `20us`

   ![image-20211029201911505](..\images\image-20211029201911505.png)

解答：

1. 在中断处理次序改为 D>A>C>B 后，D 具有最高优先级，可以屏蔽其他所有中断，且不能中断自身，因此 D 对应的屏蔽字为 1111；A 具有次高优先级，只能被 D 中断，因此 A 对应的屏蔽字为 1110，以此类推，得到 4 个中断源的屏蔽字

   ![image-20211029202453160](..\images\image-20211029202453160.png)

2. 根据处理次序，在时刻 5，B 发中断请求，获得 CPU；在时刻 10，D 发中断请求，此时 B 虽还未执行完毕，但 D 的优先级高于 B，于是 D 中断 B 而获得 CPU；在时刻 30，D 执行完毕，B 继续获得 CPU；在时刻 35，A 发中断请求，此时 B 虽还未执行完毕，但 A 的优先级高于 B，于是 A 中断 B 而获得 CPU，如此继续下去

   ![image-20211029202647551](..\images\image-20211029202647551.png)

#### 扩展*

![image-20220617155542969](..\images\image-20220617155542969.png)

1. `IR0 ~ IR7` 连接外设，当有外设要中断时，对应的一条会有信号
2. 外设发送中断请求时，中断请求寄存器通过总线向 CPU 的 INTR 发送信号
3. CPU 检查 PSW 里的 IF 若可以响应就通过 INTA 发送中断响应信号
4. 中断请求寄存器接收后，根据优先权电路计算要响应的外设，并生成中断向量地址发给 CPU

### DMA 方式

DMA 方式是一种**完全由硬件进行成组信息传送的控制方式**，它**具有程序中断方式的优点**

这种方式<u>适用于磁盘机、磁带机等高速设备大批量数据的传送</u>，它的硬件开销比较大

在 DMA 方式中，中断的作用仅限于<u>故障和本次的正常传送结束时的处理</u>

#### DMA 方式的特点

主存和 DMA 接口之间有一条**直接数据通路**（逻辑通路），**传送数据不需要经过 CPU**，不必中断现行程序

**I/O 与主机并行工作，程序和传送并行工作**，DMA 方式具有下列特点：

1. 它使主存与 CPU 的固定联系脱钩，**主存既可被 CPU 访问，又可被外设访问**
2. 在数据块传送时，主存地址的确定、传送数据的计数等都由**硬件电路直接实现**
3. 主存中要**开辟专用缓冲区**，及时**供给和接收外设的数据**
4. DMA 传送速度快，CPU 和外设并行工作，**提高了系统效率**
5. DMA 在**传送开始前要通过<u>程序进行预处理</u>**，**结束后要通过<u>中断方式进行后处理</u>**

#### DMA 控制器的组成

在 DMA 方式中，对数据传送过程**进行控制的硬件称为 DMA 控制器（DMA 接口）**

当 I/O 设备需要进行数据传送时，**通过** DMA 控制器向 CPU 提出 DMA 传送请求，CPU 响应之后将**让出系统总线**，由 **DMA 控制器接管总线进行数据传送**

其主要功能如下：

1. 接受**外设发出的 DMA 请求**，并**向 CPU 发出总线请求**
2. CPU 响应此总线请求，发出总线响应信号，**代替 CPU 接管总线控制权，进入 DMA操作周期**
3. 确定传送数据的主存单元地址及长度，并**自动修改主存地址计数和传送长度计数**
4. 规定数据在主存和外设间的**传送方向**，发出读写等控制信号，**执行数据传送操作**
5. **向 CPU 报告 DMA 操作的结束**

![image-20211029205148881](..\images\image-20211029205148881.png)

- 主存地址计数器：存放**要交换数据的主存地址**
- 传送长度计数器：**记录传送数据的长度**，计数**溢出时**，数据即传送完毕，自动**发中断请求信号**
- 数据缓冲寄存器：**暂存每次传送的数据**
- DMA 请求触发器：每当 I/O 设备**准备好数据后**，给出一个控制信号，**使 DMA 请求触发器置位**
- 控制/状态逻辑：由控制和时序电路及状态标志组成，用于**指定传送方向，修改传送参数**，并<u>对 DMA 请求信号和 CPU 响应信号进行协调和同步</u>
- 中断机构：当**一个数据块传送完毕后触发中断机构**，向 CPU 提出中断请求

在 DMA 传送过程中，DMA 控制器将<u>接管 CPU 的地址总线、数据总线和控制总线</u>，**CPU 的主存控制信号被禁止使用**

而当 DMA 传送结束后，将**恢复 CPU 的一切权利并开始执行其操作**

#### DMA 的传送方式

主存和 I/O 设备之间交换信息时，不通过 CPU，但当 I/O 设备和 CPU **同时访问主存**时，可能**发生冲突**（三总线方式）

为了有效地使用主存，DMA 控制器与 CPU 采用以下方式使用主存：

- 停止 CPU 访存：当 I/O 设备有 DMA 请求时，由 DMA 控制器向 CPU 发送一个停止信号，**使 CPU 脱离总线，停止访问主存，直到 DMA 传送一块数据结束**，数据传送结束后，DMA 控制器**通知 CPU 可以使用主存**，并**把总线控制权交还给 CPU**

- 周期挪用（周期窃取）：当 I/O 设备有 DMA 请求时，会遇到 3 种情况：

  1. 此时 CPU 不在访存（如 CPU 正在执行乘法指令），因此 I/O 的访存请求与 CPU **未发生冲突**
  2. CPU 正在访存，此时必须待**存取周期结束后，CPU 再将总线占有权让出**
  3. I/O 和 CPU 同时请求访存，出现访存冲突，此时 **CPU 要暂时放弃总线占有权**

  **I/O 访存优先级高于 CPU 访存**，因为 I/O 不立即访存就可能丢失数据

  由 I/O 设备挪用一个或几个存取周期，**传送完一个数据后立即释放总线，是一种<u>单字传送方式</u>**

- DMA 与 CPU 交替访存：这种方式适用于 **CPU 周期比主存存取周期长的情况**

  若 CPU 周期是 `1.2us`，主存的存取周期小于 `0.6us`，则可将一个 CPU 周期分为 $C_1$ 和 $C_2$ 两个周期，其中 $C_1$ 专供 DMA 访存，$C_2$ 专供 CPU 访存

  这种方式**不需要总线使用权的申请、建立和归还**过程，总线使用权是通过 $C_1$ 和 $C_2$ 分时控制的

注意：停止 CPU 访存是以块为单位，而周期挪用是以字为单位，在运输块的过程中 CPU 仍可访存

#### DMA 的传送过程

DMA 的数据传送过程分为预处理、数据传送、后处理：

1. 预处理：由 CPU 完成一些必要的准备工作

   1. CPU 执行几条 I/O 指令，用以**测试 I/O 设备状态**
   2. **向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备**等
   3. CPU 继续执行原来的程序，直到 I/O 设备**准备好发送的数据或接收的数据**
   4. **I/O 设备向 DMA 控制器发送 DMA 请求**，再由 **DMA 控制器向 CPU 发送总线请求**，用以传输数据

2. 数据传送：DMA 的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位

   对于**以数据块为单位的传送**（如硬盘），DMA 占用总线后的**数据输入和输出操作都是通过循环来实现的**

   循环也是由 DMA 控制器实现的，即**数据传送阶段完全由 DMA（硬件）控制**

3. 后处理：**DMA 控制器向 CPU 发送中断请求，CPU 执行中断服务程序做 DMA 结束处理**

   包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用 DMA 传送其他数据块等

![image-20211029212623495](..\images\image-20211029212623495.png)

#### DMA方式和中断方式的区别

DMA 方式和中断方式的**重要**区别如下：

1. 中断方式是程序的切换，**需要保护和恢复现场**；DMA 方式除了**预处理和后处理**，其他时候不占用 CPU 的任何资源

2. 对中断请求的响应**只能发生在每条指令执行完毕时**（即指令的执行周期后）

   对 DMA请求的响应可以**发生在每个机器周期结束时**，只要 CPU 不占用总线就可被响应

3. 中断传送过程**需要 CPU 的干预**；而 DMA 传送过程**不需要 CPU 的干预**，数据传输率非常高，适合高速设备和块设备

4. **DMA 请求的优先级高于中断请求**，高于非屏蔽可屏蔽外中断，高于程序性中断

5. 中断方式**具有对异常事件的处理能力**；DMA 方式仅**局限于传送数据块的 I/O 操作**，不能用于鼠标键盘

6. 从数据传送来看，中断方式**靠程序传送**，DMA 方式**靠硬件传送**

