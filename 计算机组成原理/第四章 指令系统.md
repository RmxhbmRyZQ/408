# 指令格式

指令（机器指令）是指示计算机执行某种操作的命令

一台计算机的**所有指令的集合**构成该机的**指令系统**，也称指令集

指令系统是计算机的主要属性，位于**硬件和软件的交界面上**

## 指令的基本格式

一条指令就是机器语言的一个语句，一条指令通常包括**操作码字段** + **地址码字段**：

- 操作码：该指令应**该执行什么性质的操作**以及具有何种功能

  操作码是**识别指令、了解指令功能**及**区分操作数地址**内容的组成和使用方法等的关键信息

- 地址码：给出**被操作的信息（指令或数据）的地址**，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等

关于指令的长度有：

- 指令的长度是指一条指令中所包含的**二进制代码的位数**
- 指令字长取决于**操作码的长度、操作数地址码的长度、操作数地址的个数**
- 指令长度与机器字长**没有固定的关系**，它可以等于机器字长，也可以大于或小于机器字长
- 指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令

若所有**指令的长度都是相等的**，则称为**定长指令字结构**，定字长指令的执行速度快，控制简单

若各种**指令的长度随指令功能而异**，则称为**变长指令字结构**

因为主存一般是按字节编址的，所以**指令字长多为字节的整数倍**

### 零地址指令

**只给出操作码 OP**，没有显式地址，这种指令有两种可能：

1. **不需要操作数的指令**，如空操作指令、停机指令、关中断指令等
2. **零地址运算类指令**仅用在**堆栈计算机**中，**操作数隐含地从栈弹出**，运算完再**隐含地压入堆栈**

### 一地址指令

有操作码 OP + 一个操作数地址，同样有两种可能：

1. 只有**目的操作数**的单操作数指令：

   按 $A_1$ 地址读取操作数，进行 OP 操作后，结果存回原地址

   指令含义：$OP(A_1)→A_1$，如操作码含义是加 1、减 1、求反、求补等

2. **隐含约定目的地址**的双操作数指令：

   按指令地址 $A_1$ 可读取源操作数，**另一个操作数由累加器 ACC 提供**，运算**结果存放在 ACC 中**

   指令含义：$(ACC)OP(A_1)→ACC$，若指令字长为 32 位，操作码占 8 位，则 1 个地址码字段占 24 位，寻址 $2^{24}$

### 二地址指令

有操作码 OP + 两个操作数地址

指令含义：$(A_1)OP(A_2)→A_1$，给出**目的操作数**和**源操作数**的地址，其中**目的操作数地址**用于**保存运算结果**

若指令字长为 32 位，操作码占 8 位，两个地址码字段各占 12 位，寻址 $2^{12}$

### 三地址指令

有操作码 OP + 三个操作数地址

指令含义：$(A_1)OP(A_2)→A_3$，**第三个操作数地址**用于**保存运算结果**

若指令字长为 32 位，操作码占 8 位，3 个地址码字段各占 8 位，寻址 $2^8$

若地址字段均为主存地址，则完成一条三地址需要 4 次访问存储器，取指 1、取数 2、放结果 1

### 四地址指令

指令含义：$(A_1)OP(A_2)→A_3,A_4=下一条将要执行指令的地址$

若指令字长为 32 位，操作码占 8 位，4 个地址码字段各占 6 位，寻址 $2^6$

## 定长操作码指令格式

定长操作码指令在指令字的最高位部分分配**<u>固定</u>的若干位（定长）表示操作码**

一般 n 位操作码字段的指令系统最大**能够表示 $2^n$ 条指令**

定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利

当计算机字长为 32 位或更长时，这是常规用法

## 扩展操作码指令格式

为了在指令字长有限的前提下仍**保持比较丰富的指令种类**，可采取可变长度操作码，即**操作码字段的位数不固定**，且分散地放在指令字的不同位置上，这将增加指令译码和分析的难度，使控制器的设计复杂化

最常见的变长操作码方法是**扩展操作码**，它使操作码的**长度随地址码的减少而增加**，从而在满足需要的前提下，**有效地缩短指令字长**

![image-20211017202900865](..\images\image-20211017202900865.png)

指令字长为 16 位，其中 4 位为操作码 OP，另有 3 个 4 位长的地址，操作码定长则只有 16 条指令

如果使用扩展操作码：

1. 三地址指令为 15 条，1111 留作扩展操作码之用
2. 二地址指令为 15 条，1111 1111 留作扩展操作码之用
3. 一地址指令为 15 条，11111111 1111 留作扩展操作码之用
4. 零地址指令为 16 条
5. 这就<u>从定长指令定长操作的 16 条指令变成定长指令不定长操作的 61 条指令</u>

还有其他多种扩展方法，如 15 条三地址指令、12 条二地址指令、63 条一地址指令和 16 条零地址指令，共 106 条指令

在设计扩展操作码指令格式时，必须注意以下两点:

1. **不允许短码是长码的前缀**，即短操作码不能与长操作码的前面部分的代码相同
2. 各指令的**操作码一定不能重复**

也可以对使用**频率较高的指令分配较短的操作码**，对使用**频率较低的指令分配较长的操作码**，减少指令译码和分析的时间

## 指令的操作类型

1. 数据传送：通常有**寄存器之间的传送**、从**内存单元到 CPU 寄存器**、从 **CPU 寄存器写数据到内存单元**等

2. 算术和逻辑运算：主要有加、减、比较、乘、除、加 1、减 1、与、或、取反、异或等

3. 移位操作：移位指令主要有**算法移位、逻辑移位、循环移位**等

4. 转移操作（程序控制类指令）：

   转移指令主要有**无条件转移、条件转移、调用、返回、陷阱**等

   1. 无条件转移指令：在任何情况下都执行转移操作
   2. 而条件转移指令：在特定条件满足时才执行转移，转移条件一般是某个标志位的值，或两个或两个以上的标志位组合
   3. 调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行

5. 输入输出操作：用于完成 CPU 与**外部设备交换数据**或**传送控制命令及状态信息**

选择题：中断隐指令是由硬件实现的，并**不是指令系统中存在的指令**，更不可能属于程序控制类指令

选择题：特权指令是指**仅用于操作系统或其他系统软件的指令**，为确保系统与数据安全起见，这类指令**不提供给用户使用**

## 综合应用题

题目：一处理器中共有 32 个寄存器，使用 16 位立即数，其指令系统结构中共有 142 条指令。**在某个给定的程序中**，20% 的指令带有一个输入寄存器和一个输出寄存器；30% 的指令带有两个输入寄存器和一个输出寄存器；25% 的指令带有一个输入寄存器、一个输出寄存器、一个立即数寄存器；其余 25% 的指令带有一个立即数输入寄存器和一个输出寄存器

1. 对于以上 4 种指令类型中的任意一种指令类型来说，共需要多少位？指令系统结构要求所有指令长度必须是 8 的整数倍
2. 与使用定长指令集编码相比，当采用变长指令集编码时，该程序能够少占用多少存储器空间？

解答：

1. 因为无法计算不定长操作码，所以这里计算定长操作码，142 条指令需要 7 位（答案写 8 位），32 个寄存器需要 5 位，16 位立即数需要 16 位
   1. 一个输入寄存器和一个输出寄存器：7 + 5 + 5 = 17 对齐后为 24
   2. 两个输入寄存器和一个输出寄存器：7 + 5 + 5 + 5 = 22 对齐后为 24
   3. 一个输入寄存器、一个输出寄存器、一个立即数寄存器：7 + 5 + 5 + 16 = 33 对齐后 40
   4. 一个立即数输入寄存器和一个输出寄存器：7 + 16 + 5 = 28 对齐后 32
2. 由于最长是 40 位，所以定长要使用 40 位；变长时 20% × 24 + 30% × 24 + 25% × 40 + 25% × 32 = 30 少用了 25% 的空间

# 指令的寻址方式

## 指令寻址和数据寻址

寻址方式是指**寻找指令或操作数有效地址的方式**，即确定本条指令的数据地址及下一条待执行指令的地址的方法

指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址（A），可以是**寄存器编号**或者**内存地址**

形式地址结合寻址方式，可以计算出**操作数在存储器中的真实地址**，这种地址称为**有效地址**（EA）

寻址方式分为**指令寻址**和**数据寻址**两大类：寻找下一条将要执行的指令地址称为指令寻址；寻找操作数的地址称为数据寻址

### 指令寻址

指令寻址方式有两种：一种是**顺序寻址方式**，另一种是**跳跃寻址方式**

1. 顺序寻址：通过程序计数器（PC）加 1 个指令字长，**自动形成下一条指令的地址**

2. 跳跃寻址通过转移类指令实现：

   所谓跳跃，是指下条指令的地址码不由程序计数器给出，而**由本条指令计算出下条指令地址**

   注意：状态寄存器和操作数的控制是否跳跃，而跳跃到的地址分为绝对地址和相对地址，跳跃的结果是当前指令修改 PC 值，所以下一条指令仍然通过程序计数器给出

### 数据寻址

数据寻址是指**如何在指令中表示一个操作数的地址**，如何用这种表示得到操作数或**怎样计算出操作数的地址**

数据寻址的方式较多，通常在指令字中**设一个字段来指明属于哪种寻址方式**，由此可得指令的格式如下所示：

![image-20211018161851931](..\images\image-20211018161851931.png)

选择题：采用不同寻址方式的目的是<u>缩短指令字长，扩大寻址空间，提高编程的灵活性</u>，但也<u>提高了指令译码的复杂度</u>

## 常见的数据寻址方式

### 隐含寻址

这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址

![image-20211018162301445](..\images\image-20211018162301445.png)

例如，规定累加器（ACC）作为第二操作数地址，，累加器（ACC）对单地址指令格式来说是隐含寻址

隐含寻址的优点是有利于**缩短指令字长**；缺点是**需增加存储操作数或隐含地址的硬件**

### 立即（数）寻址

这种类型的指令的地址字段指出的是**操作数本身**，又称立即数，数据采用**补码形式存放**

![image-20211018163109172](..\images\image-20211018163109172.png)

立即寻址的优点是指令在**执行阶段不访问主存**，指令执行时间最短；缺点是 **A 的位数限制了立即数的范围**

注意：在定长指令字时，立即数取址执行速度最快；但在变长指令字时，寄存器寻址执行速度最快，因为读代码也要时间

### 直接寻址

指令字中的形式地址 A 是操作数的真实地址 EA，即 **EA = A**

![image-20211018163554498](..\images\image-20211018163554498.png)

直接寻址的优点是简单，指令在执行阶段仅访问一次主存，**不需要专门计算操作数的地址**；缺点是 **A 的位数决定了该指令操作数的寻址范围**，操作数的地址不易修改

### 间接寻址

间接寻址是指，指令的地址字段给出的形式地址是**操作数有效地址所在的存储单元的地址**，即 **EA =(A)**

间接寻址可以是一次间接寻址，还可以是多次间接寻址

![image-20211018163908663](..\images\image-20211018163908663.png)

主存字第一位为 1 时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为 0 时，表示取得的是操作数的地址

优点：可**扩大寻址范围**（有效地址 EA 的位数大于形式地址 A 的位数），便于**编制程序**（方便地完成子程序返回）

缺点：指令在执行阶段要**多次访存**，由于访问速度过慢，这种寻址方式并不常用

注意：一般问到**扩大寻址范围**时，通常指的是**寄存器间接寻址**

### 寄存器寻址

寄存器寻址是指在指令字中直接**给出操作数所在的寄存器编号**，即 $EA=R_i$，其操作数在由 $R_i$ 所指的寄存器内

![image-20211018164727093](..\images\image-20211018164727093.png)

优点：指令在执行阶段不访问主存，只访问寄存器，**指令字短且执行速度快**，支持向量 / 矩阵运算

缺点：寄存器价格昂贵，计算机中的**寄存器个数有限**

### 寄存器间接寻址

寄存器间接寻址是指在寄存器 $R_i$ 中给出的是**操作数所在主存单元的地址**，即 $EA= (R_i)$

![image-20211018165205933](..\images\image-20211018165205933.png)

寄存器间接寻址的特点：比一般间接寻址**速度更快**，但指令的执行阶段需要访问主存

### 相对寻址

相对寻址是把程序计数器 PC 的内容加上形式地址 A 而形成操作数的有效地址，即 **EA = (PC) + A**，其中 **A 是相对于当前指令地址的位移量**，可正可负，补码表示

![image-20211018165506048](..\images\image-20211018165506048.png)

操作数的地址**随 PC 值的变化而变化**，且与指令地址之间总是相差一个固定值，因此**便于程序浮动**，广泛应用于**转移指令**

注意：**读完指令后 PC 会增加**，转移时**根据增加后的 PC 来转移**，如 `JMP A` 指令地址为 X 长度 `2B`，则会跳到 X + 2 + A 处

选择题：在多道程序设计中，各个程序段被加载的内存是浮动的，当程序的存放区域被改变，要求其执行不受影响，使用相对地址可以实现

### 基址寻址

基址寻址是指将 CPU 中基址寄存器（BR）的内容加上形式地址 A 而形成操作数的有效地址，即 **EA=(BR)+ A**

其中基址寄存器既**可采用专用寄存器**，又**可采用通用寄存器**

![image-20211018182504834](..\images\image-20211018182504834.png)

基址寄存器是面向操作系统的，**内容由操作系统或管理程序确定**，用于解决程序逻辑空间与存储器物理空间的无关性

在程序执行过程中，**基址寄存器的内容不变**（作为基地址），**形式地址可变**（作为偏移量）

采用通用寄存器作为基址寄存器时，可**由用户决定哪个寄存器作为基址寄存器**，但其**内容仍由操作系统确定**

优点：可**扩大寻址范围**；用户不必考虑自己的程序存于主存的哪个空间区域，因此**有利于多道程序设计**，并可用于**编制浮动程序**，但偏移量（形式地址 A）的位数较短

思考：基址就是一个程序的基地址，程序内的每个数据都是根据基地址来寻址的，当程序装入不同内存变了改一下基址就行

### 变址寻址

变址寻址是指有效地址 EA 等于**形式地址 A 与变址寄存器 IX 的内容之和**，即 **EA = (IX) + A**，其中 IX 为变址寄存器（专用），也可用通用寄存器作为变址寄存器

![image-20211018183938571](..\images\image-20211018183938571.png)

变址寄存器是**面向用户**的，变址寄存器的内容可由用户改变，**形式地址 A 不变**，偏移量的位数足以表示整个存储空间

优点：可**扩大寻址范围**；可令 A 为数组的首地址，变址寄存器 IX 为数组的索引；特别适合编制循环程序

基址寻址**面向系统**，主要用于**为多道程序或数据分配存储空间**，内容通常由操作系统或管理程序确定，**其值不可变**，指令字中的 A 是可变的

变址寻址**立足于用户**，主要用于处理**数组问题**，变址寄存器的内容由用户设定，**其值可变**，而指令字中的 A 是不可变的

### 堆栈寻址

堆栈是存储器中一块特定的、**按后进先出原则管理的存储区**，读/写单元的地址用一个特定的寄存器给出称为堆栈指针

堆栈可分为硬堆栈与软堆栈两种：

1. **寄存器堆栈**又称硬堆栈，寄存器堆栈的成本较高，不适合做大容量的堆栈
2. **从主存中划出一段区域**来做堆栈是**最合算且最常用**的方法，这种堆栈称为软堆栈

堆栈结构的计算机系统中，大部分指令表现为**无操作数指令**，因为其操作数都通过堆栈寄存器**隐含使用了堆栈**

如 `ADD` 加法指令就是从堆栈中弹出两个操作数，运算完后再把结果压入堆栈

### 总结

![image-20211018185202626](..\images\image-20211018185202626.png)

## X86 汇编指令入门

### 相关寄存器

X86 处理器中有 **8 个 32 位的通用寄存器**，为了向后兼容 `EAX、EBX、ECX、EDX` 的**高低两位字节可以独立使用**，E 为 Extended 表示 32 位的寄存器，寄存器的**名称与大小写无关**，既可以用 `EAX`，又可以用 `eax`

![image-20211018190206522](..\images\image-20211018190206522.png)

除 `EBP` 和 `ESP` 外（用于堆栈不可乱用），其他几个寄存器的用途是比较任意的

### 寻址模式和内存分配

#### 寻址模式

X86 提供了一种灵活的内存寻址方式，如 mov 用于在内存和寄存器之间移动数据，第一个是目的地址，第二个是源地址

注意：最多只能利用**两个** 32 位寄存器和一个 32 位的有符号常数**相加**计算出一个内存地址

```assembly
mov eax, [ebx]  ;将 ebx 值指示的内存地址中的 4 子节传送到 eax
mov [var], ebx  ;将 ebx 值传送到 var 的值指示的内存地址中
mov eax, [esi - 4]  ;将 esi - 4 值指示的内存地址中的 4 字节传送到 eax
mov [esi + eax], cl  ;将 cl 值传送到 esi + eax 值指示的内存地址中
mov edx, [esi + 4 * ebx]  ;将 esi + 4 * ebx 值指示的内存中的 4 字节传送到 edx

mov eax, [ebx - ecx]  ;错误，只能用加法
mov [eax + esi + edi], ebx  ;错误，最多只能有两个寄存器参与运算
```

#### 数据类型长度规定

汇编语言中声明内存大小时，一般显式地使用 `DB（Data Byte)、DW（Word，2Bytes）、DD（Double Word，4Bytes）`分配内存

为了**区分常数 2 的占位**，X86 提供了三个指示规则标记，分别为 `BYTE PTR、WORD PTR、DWORD PTR`

```assembly
a:db 0  ;分配单字节内存
b:dw 0  ;分配双字节内存
c:dd 0  ;分配四字节内存

mov byte ptr [ebx], 2  ;将 2 以单字节形式传送到 ebx 值指示的内存地址中
mov word ptr [eb×], 2  ;将 2 以双字节形式传送到 ebx 值指示的内存地址中
mov dword ptr [ebx], 2  ;将 2 以四字节形式传送到 ebx 值指示的内存地址中
```

### 常用命令

汇编指令通常可以分为数据传送指令、逻辑计算指令和控制流指令，以下用于操作数的标记分别表示寄存器、内存和常数

1. \<reg>：表示任意寄存器，若其后带有数字，则指定其位数

   \<`reg32`> 表示 32 位寄存器；\<`reg16`> 表示 16 位寄存器；\<`reg8`> 表示 8 位寄存器

2. \<`mem`>：表示内存地址

3. \<con>：表示 8 位、16 位或 32 位常数

   \<`con8`> 表示 8 位常数；\<`con16`> 表示 16 位常数；\<`con32`> 表示 32 位常数

对**同一指令的不同用途有多种编码方式**，比如 mov 指令就有 28 种机内编码，用于不同操作数类型或用于特定寄存器

```assembly
mov ax, <con16>  ;机器码为 B8H
mov al, <con8>  ;机器码为 BOH
```

应用题：可使用**溢出自陷指令**让 CPU 检查溢出标志 OF，如果溢出 OF = 1 就会调用**溢出异常处理程序**

#### 数据传送指令

1. mov 指令：将第二个操作数复制到第一个操作数，但不能用于直接从内存复制到内存

   ```assembly
   mov <reg>, <reg>
   mov <reg>, <mem>
   mov <mem>, <reg>
   mov <reg>, <con>
   mov <mem>, <con>
   
   mov eax, ebx
   mov byte ptr [var], 5  ;将 5 保存到 var 值指示的内存地址的一字节中
   ```

2. push 指令：push 指令将操作数压入内存的栈，ESP 是栈顶，压栈前先将 ESP 值减 4，然后将操作数压入 ESP 指示的地址

   ```assembly
   push <reg32>
   push <mem>
   push <con32>
   
   push eax
   push [var]  ;将 var 值指示的内存地址的 4 字节值压栈
   ```

3. pop 指令：pop 指令执行的是出栈工作，出栈前先将 ESP 指示的地址中的内容出栈，然后将 ESP 值加 4

   ```assembly
   pop <reg32>
   pop <mem>
   
   pop edi
   pop [ebx]  ;弹出栈顶元素送到 ebx 值指示的内存地址的 4 字节中
   ```

#### 算术和逻辑运算指令

1. add/sub 指令：add 指令将两个操作数相加，相加的结果保存到第一个操作数中；sub 指令用于两个操作数相减，相减的结果保存到第一个操作数中

   ```assembly
   add <reg>, <reg> / sub <reg>, <reg>
   add <reg>, <mem> / sub <reg>, <mem>
   add <mem>, <reg> / sub <mem>, <reg>
   add <reg>, <con> / sub <reg>, <con>
   add <mem>, <con> / sub <mem>, <con>
   
   sub eax, 10
   add byte ptr [var], 10
   ```

2. inc/dec 指令：inc、dec 指令分别表示将操作数自加 1、自减 1

   ```assembly
   inc <reg> / dec <reg>
   inc <mem> / dec <mem>
   
   dec eax
   inc dword ptr [var]
   ```

3. `imul` 指令：带符号整数乘法指令，它有两种格式：

   1. 两个操作数：将两个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器
   2. 三个操作数：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器

   ```assembly
   imul <reg32>, <reg32>
   imul <reg32>, <mem>
   imul <reg32>, <reg32>, <con>
   imul <reg32>, <mem>, <con>
   
   imul eax, [var]  ;eax <- eax * [var]
   imul esi, edi, 25  ;esi <- edi * 25
   ```

   两个 32 位数值相乘，积是 64 位，若其高 33 位不是全为零（正）或全为一（负），就表示溢出，则 OF = 1

4. idiv 指令：带符号整数除法指令，只有一个操作数除数，被除数为 `edx:eax` 中的内容 64 位，商送到 `eax`，余数则送到 `edx`

   ```assembly
   idiv <reg32>
   idiv <mem>
   
   idiv ebx
   idiv dword ptr [var]
   ```

5. and/or/xor 指令：分别是逻辑与、逻辑或、逻辑异或指令，用于位操作，操作结里放在第个操作数中

   ```assembly
   and <reg>, <reg> / or <reg>, <reg> / xor <reg>, <reg>
   and <reg>, <mem> / or <reg>, <mem> / xor <reg>, <mem>
   and <mem>, <reg> / or <mem>, <reg> / xor <mem>, <reg>
   and <reg>, <con> / or <reg>, <con> / xor <reg>, <con>
   and <mem>, <con> / or <mem>, <con> / xor <mem>, <con>
   
   and eax, 0fH  ;eax &= 0x0f
   xor edx, edx  ;置 0
   ```

6. not 指令：位翻转指令，将操作数中的每一位翻转，即 0→1、1→0

   ```assembly
   not <reg>
   not <mem>
   
   not byte ptr [var]  ;将 var 值指示的内存地址的一字节的所有位翻转
   ```

7. neg 指令：取负指令

   ```assembly
   neg <reg>
   neg <men>
   
   neg eax  ;eax <- -eax
   ```

8. `shl/shr` 指令：`shl` 为逻辑左移，`shr` 为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数

   ```assembly
   shl <reg>, <con8> / shr <reg>, <con8>
   shl <mem>, <con8> / shr <mem>, <con8>
   shl <reg>, <cl> / shr <reg>, <cl>
   shl <mem>, <c1> / shr <mem>, <cl>
   
   shl eax, 1
   shr ebx, cl
   ```

#### 控制流指令

X86 处理器维持着一个指令指针 IP 它**指向下一条指令的首地址**，当一条指令取出后，此指针自动指向下一条指令

IP 寄存器不能直接操作，但可以用控制流指令更新，通常用标签指示程序中的指令地址，可在任何指令前加入标签

```assembly
mov esi, [ebp + 8]
begin: xor ecx, ecx  ;标记，用于控制流指令的跳转
mov eax, [esi]
```

1. `jmp` 指令：控制 IP 转移到 label 所指示的地址

   ```assembly
   jmp <label>
   jmp begin  ;跳转到 begin 标记的指令执行
   ```

2. `jcondition` 指令：条件转移指令，它**依据处理机状态字中的一系列条件状态转移**（状态寄存器）

   ```assembly
   je <label> (jump when equal)
   jne <label> (jump when not equal)
   jz <label> (jump when last result was zero)
   jg <label> (jump when greater than)
   jge <label> (jump when greater than or equal to)
   jl <label> (jump when less than)
   jle <label> (jump when less than or equal to)
   
   cmp eax, ebx
   jle done ;如果 eax 的值小于等于 ebx 值，跳转到 done
   ```

3. `cmp` 指令：用于比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码，通常与 `jcondition` 搭配

   ```assembly
   cmp <reg>, <reg>
   cmp <reg>, <mem>
   cmp <mem>, <reg>
   cmp <reg>, <con>
   ```

4. call/ret 指令：用于实现子程序（过程、函数等）的调用及返回

   call 指令首先将当前执行指令地址的下一个指令地址入栈，然后无条件转移到由标签指示的指令

   ret 指令实现子程序的返回机制，ret 指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行

   ```assembly
   fun:
   mov eax, 0x6021  ;设置返回值
   ret  ;返回，跳转到栈定存放的地址
   
   call fun  ;将下面指令的地址入栈，跳转到 fun
   mov ebx, eax
   ```

# CISC 和 RISC 的基本概念

指令系统朝两个截然不同的方向的发展：

1. 增强原有指令的功能，**设置更为复杂的新指令实现软件功能的硬化**，称为复杂指令系统计算机 CISC，有 X86 架构
2. **减少指令种类和简化指令功能**，提高指令的执行速度，称为精简指令系统计算机 RISC，有 ARM、MIPS 架构

## 复杂指令系统计算机（CISC）

随着超大规模集成电路（VLSI）技术的发展，硬件成本不断下降，软件成本不断上升，促使人们在指令系统中**增加更多、更复杂的指令**，以适应不同的应用领域（即指令功能尽可能强）

CISC 的主要特点如下：

1. **指令系统复杂庞大**，指令数目一般为 200 条以上
2. **指令的长度不固定，指令格式多，寻址方式多**
3. **可以访存的指令不受限制**
4. 各种**指令使用频度相差很大**
5. 各种**指令执行时间相差很大**，大多数指令需多个时钟周期才能完成
6. **控制器大多数采用微程序控制**，有些指令非常复杂，以至于无法采用硬连线控制
7. **难以用优化编译生成高效的目标代码程序**

命令频率相差悬殊 20% 的简单的指令约占整个程序的 80%；而 80% 的指令约占整个程序的 20%，于是 RISC 随之诞生

## 精简指令系统计算机（RISC）

中心思想是<u>要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致</u>

RISC 的主要特点如下：

1. 选取使用**频率最高的一些简单指令**，<u>复杂指令的功能由简单指令的组合来实现</u>
2. **指令长度固定，指令格式种类少，寻址方式种类少**
3. **只有 Load / Store（取数/存数）指令访存**，其余指令的操作都在寄存器之间进行
4. CPU 中通用**寄存器的数量相当多**
5. RISC **一定采用指令流水线技术**，大部分指令在**一个时钟周期内完成**
6. 以**硬布线控制为主**，不用或少用微程序控制
7. 特别**重视编译优化工作**，以减少程序执行时间

从指令系统兼容性看，**CISC 大多能实现软件兼容**，即高档机包含了低档机的全部指令，并可加以扩充；而大多数 RISC 机不能与老机器兼容，但 **RISC 具有更强的实用性**，是未来处理器的发展方向

<u>现代 CISC 结构的 CPU 已经融合了很多 RISC 的成分</u>，性能差距已经越来越小，CISC 可以提供更多的功能是程序设计需要的

## CISC 和 RISC 的比较

和 CISC 相比，RISC 的优点主要体现在以下几点：

1. **RISC 更能充分利用芯片的面积**，CISC 的控制存储器占 CPU 芯片面积达 50% 以上，而 RISC 的硬布线逻辑只占 CPU 芯片面积的 10% 左右
2. RISC **更能提高运算速度**，指令数、寻址方式和指令格式种类少 + 多个通用寄存器 + 流水线技术
3. RISC **便于设计，可降低成本，提高可靠性**，RISC 指令系统简单，因此机器设计周期短；其逻辑简单，因此可靠性高
4. RISC **有利于编译程序代码优化**，编译程序容易选择更有效的指令和寻址方式，适当地调整指令顺序，令代码执行更高效化

![image-20211019164811802](..\images\image-20211019164811802.png)

# 常见问题

1. 简述各常见指令寻址方式的特点和适用情况

   立即寻址操作数获取便捷，通常用于**给寄存器赋初值**

   直接寻址相对于立即寻址，**缩短了指令长度**

   间接寻址**扩大了寻址范围**，便于编制程序，易于完成子程序返回

   寄存器间接寻址**扩大了寻址范围**，寄存器寻址的指令字较短，指令执行速度较快

   基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于**为程序或数据分配存储空间**

   变址寻址主要用于**处理数组问题**，适合编制循环程序

   相对寻址用于**控制程序的执行顺序、转移**等

2. 装入/存储（Load / Store）型指令有什么特点？

   装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格，在 RISC 指令系统中较为常见

   为了规整指令格式，使指令具有相同的长度，规定**只有 Load / Store 指令才能访问内存**

   因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致

   这种装入/存储型风格的指令系统的最大特点是，**指令格式规整，指令长度一致，一般为 32 位**

   与一般通用寄存器型指令风格相比，其**程序长度会更长**，因为会包含许多装入和存储指令

