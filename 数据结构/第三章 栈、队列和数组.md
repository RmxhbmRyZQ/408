# 栈

## 栈的基本概念

### 栈的定义

栈是只允许**在一端进行插入或删除操作**的线性表，即栈是一种操作受限的线性表

**栈顶**是线性表**允许进行插入**的那一端；**栈底**是固定的**不允许进行插入**的另一端；**空栈**是**不含任何元素**的空表

由于栈只能在栈顶进行插入和删除操作，所以栈的操作可以明显的概括为**后进先出**

**栈满还存为上溢，栈空再取即下溢**。上溢和下溢都修改了**栈之外的内存**，因此有可能导致程序崩溃

n 个不同元素进栈，出栈元素**不同排列的个数**为 $\dfrac{1}{n+1}C(2n, n)=\dfrac{1}{n+1}C^{n}_{2n}=\dfrac{1}{n+1}\dfrac{2n!}{n!\cdot n!}$，这是卡特兰数

### 出栈排列个数思考

把 n 个元素的出栈个数的记为 f(n)，显然有 f(1) = 1、f(2) = 2

第一个元素在出栈时可能会在位置 1、位置 2......一直到位置 n

如 1234 出栈的话会是 1234, 2134, 3214, 4321 其中 1 的位置分别是 1, 2, 3, 4

1. 假设第一个元素在位置 1，那么就和后面 n - 1 个元素的排序，即 f(n - 1)
2. 假设第一个元素在位置 2，那么有前面 1 个元素的排列和后面 n - 2 的元素排列，排列个数为 f(1) * f(n - 2)
3. 那么第一个元素在位置 i，那么有前面 i - 1 个元素的排列和后面  n - i 个元素的排列，排列个数为 f(i - 1) * f(n - i)
4. 把上面的都加起来就是 $f(n)=f(n-1)+f(1)*f(n-2)+\cdots+f(i-1)*f(n-i)+\cdots+f(n-1)$
5. 令 f(0) = 1，就有 $f(n)=\displaystyle\sum^n_{i=1}f(i-1)*f(n-i)$

### 栈的基本操作

```c
InitStack(&S);  // 初始化空栈
StackEmpty(S);  // 判断一个栈是否为空
Push(&S, x);  // 入栈
Pop(&S, &x);  // 出栈
GetTop(S, &x);  // 读取栈顶元素
DestroyStack(&s);  // 销毁栈
```

在解答算法题时，若题干未做出限制，则可直接使用这些基本的操作函数

## 栈的顺序存储结构

### 顺序栈的实现

采用顺序存储的栈称为顺序栈，它利用**数组**存放栈的数据元素，并附上一个**指针**指示当前栈顶元素的位置

```c
#define MaxSize 50
typedef struct DNode{
    ElemType data[MaxSize];  // 存放栈中元素
    int top;  // 栈顶指针
}SqStack;
```

栈顶指针：`S.top`，出事时设置 `S.top = -1`

栈顶元素：`S.data[S.top]`

进栈操作：栈不满时，栈顶指针先加 1，再送值到栈顶元素

出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减 1

栈空条件：`S.top == -1`

栈满条件：`S.top == MaxSize - 1`

栈长：`S.top + 1`

### 顺序栈的基本操作

#### 初始化

```c
void InitStack(SqStack &S){
	S.top = -1;
}
```

#### 栈判空

```c
bool StackEmpty(SqStack &S){
    // 为什么不 return S.top == -1;
	if(S.top == -1)
		return true;
	else
		return false;
}
```

#### 进栈

```c
bool Push(SqStack &S, ElemType x){
	if(S.top == MaxSize-1)  // 栈满
		return false;
	S.data[++S.top] = x;  // 指针加 1 再入栈
	return true;
}
```

#### 出栈

```c
bool Pop(SqStack &S, ElemType &x){
	if(-1 == S.top)  // 栈空
		return false;
	x = S.data[S.top--];  // 先出栈，指针再减 1
	return true;
}
```

#### 读取栈顶元素

```c
bool GetTop(SqStack &S, ElemType &x){
	if(-1 == S.top)  // 栈空
		return false;
	x = S.data[S.top];  // 记录栈顶元素
	return true;
}
```

注意：若栈初始化为 `S.top = 0` 那么入栈就变成了 `S.data[S.top++] = x` 出栈就变成了 `x = S.data[--S.top]`

### 共享栈

利用栈第位置相对不变的特性，可让**两个顺序栈共享一个以为数组空间**

将两个栈的栈底分别设置在**共享空间的两端**，两个栈顶**向共享空间的中间延伸**

![src=http___images2017.cnblogs.com_blog_858860_201708_858860-20170828180651437-1593004191.png&refer=http___images2017.cnblogs](..\images\src=http___images2017.cnblogs.com_blog_858860_201708_858860-20170828180651437-1593004191.png&refer=http___images2017.cnblogs.jpg)

`top0 == -1` 时 0 号栈为空，`top1 == MaxSize` 时 1 号栈为空；当**两个栈顶指针相邻**（`top1 - top0 = 1`）时，栈满

当 0 号栈进栈时先**加 1 再赋值**，1 号栈进栈时先**减 1 再赋值**；**出栈时相反**

共享栈是为了**更有效地利用存储空间**，两个栈地空间相互调节，只有在**整个存储空间被占满时才发生上溢**

原本一个栈用得多一个栈用的少，两个分配同样的内存，用的多的容易上溢，现在共享栈自己用完了会用另外一个栈的空间，没那么容易上溢

## 栈的链式存储结构

采用链式存储的栈称为链栈，链栈的优点是便于**多个栈共享空间**和**提高其效率**，且**不存在栈满上溢的情况**（这里的共享空间是指更方便多个栈共享内存空间）

链栈通常使用**单链表**来实现，并规定所有操作都是在**单链表的表头进行的**，通常链栈**没有头结点**

```c
typedef struct Linknode {
    ElemType data;  // 数据域
    struct Linknode *next;  // 指针域
} *LiStack;
```

链栈的操作和链表相似，只是入栈和出栈的操作都在链表的**表头进行**

# 队列

## 队列的基本概念

### 队列的定义

队列也是一种**操作受限**的**线性表**，只允许在表的**一端进行插入**，而在表的**另一端进行删除**

向队列插入元素称为**入队或进队**；删除元素称为**出队或离队**，其操作的特性是**先进先出**

### 队列常见的基本操作

```c
InitQueue(&Q);  // 初始化队列
QueueEmpty(Q);  // 判队列是否为空
EnQueue(&Q, x);  // 入队
DeQueue(&Q, &x);  // 出队
GetHead(Q, &x);  // 读取头元素
```

## 队列的顺序存储结构

### 队列的顺序存储

队列的顺序是指**分配一块连续的存储单元**存放队列中的元素，并附有**队头指针**和**队尾指针**

```c
#define MaxSize 5
typedef int ElemType;
typedef struct {
	ElemType data[MaxSize];  // 存放队列元素
	int front, rear;  // 对头指针和队尾指针
} SqQueue;
```

初始条件：`Q.front = Q.rear = 0`

队空条件：`Q.front == Q.rear`

进队操作：对不满时，先送值到队尾元素，再将队尾指针加 1

出队操作：队不空时，先取队头元素，再将队头指针加 1

顺序队列缺点：没用重复利用使用过的空间，造成空间上的浪费

### 循环队列

环形队列即把存储队列元素的表**从逻辑上视为一个环**，当队首指针 `Q.front = MaxSize - 1` 后，**再前进就变成 0**，这就利用到了之前顺序队列所没用利用的空间

初始时：`Q.front = Q.rear = 0`

队首指针进 1：`Q.front = (Q.front + 1) % MaxSize`

队尾指针进 1：`Q.rear = (Q.rear + 1) % MaxSize`

队列长度：`(Q.rear + MaxSize - Q.front) % MaxSize`

出队入队时：指针都按顺时针复习进 1

为了防止队空队满判断都是 `Q.front == Q.rear`，有三种方法：

1. **牺牲一个单元**来区分队空和堆满，以<u>队头指针在队尾指针的下一位置作为队满的标志</u>，这是一种**较为普遍的做法**，**队满条件**为 `(Q.rear + 1) % MaxSize == Q.front`
2. 类型中**增加表示元素个数的数据成员**，这时**队空条件**为 `Q.size == 0`；**队满条件**为 `Q.size == MaxSize`
3. 类型中**增加标志 tag 成员**。**队空条件**为 `Q.front == Q.rear && tag == 0`；**队满条件**为 `Q.front == Q.rear && tag == 1`

### 循环队列的操作

#### 初始化

```c
void InitQueue(SqQueue &Q) {
	Q.rear = Q.front = 0;
}
```

#### 判队空

```c
bool isEmpty(SqQueue &Q) {
	if(Q.rear == Q.front)
		return true;
	else	
		return false;
} 
```

#### 入队

```c
bool EnQueue(SqQueue &Q, ElemType x) {
	if((Q.rear + 1) % MaxSize == Q.front)  // 队满
		return false;
	Q.data[Q.rear] = x;
	Q.rear = (Q.rear + 1) % MaxSize;  // 表尾向前进 1
	return true;
}
```

#### 出队

```c
bool DeQueue(SqQueue &Q, ElemType &x){
	if(Q.rear == Q.front)  // 队空
		return false;
	x = Q.data[Q.front];
	Q.front = (Q.front + 1) % MaxSize;  // 表头向前进 1
	return true;
}
```

## 队列的链式存储结构

### 队列的链式存储

队列的**链式表示**称为链队列，实际上就是一个带**队头指针**和**队尾指针**的单链表

<u>头指针指队头结点，尾指针指队尾结点</u>，队列的链式存储结构为：

```c
typedef struct LinkNode {  // 链式队列结点
	ElemType data;
	struct LinkNode *next;
} LinkNode;

typedef struct {
	LinkNode *front, *rear;  // 队头和队尾指针
} LinkQueue;
```

当 `Q.front == NULL && Q.rear == NULL` 时，**链式队列为空**

入队时，若**队列不为空**，从**队头弹出一个元素**；出队时，直接**把新元素插入队尾**

由于不带头结点的链式队列在操作上往往比较麻烦，因此通常会把链接队列设计成带头结点的单链表

单链表表示的链式队列适合**数据元素变动比较大**的情形，且不存在队列满且产生**溢出问题**

当程序中要使用**多个队列**，域多个栈的情形一样，最好**使用链式队列**，这样就不会出现存储分配不合理和溢出

### 链式队列的基本操作

#### 初始化

```c
void InitQueue(LinkQueue &Q){
    // 这里是带头结点单链表实现的链式队列
	Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
	Q.front -> next = NULL; 
}
```

#### 判队空

```c
bool IsEmpty(LinkQueue &Q){
	if(Q.front == Q.rear)
		return true;
	else
		return false;
}
```

#### 入队

```c
void EnQueue(LinkQueue &Q, ElemType x){
	LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
	s -> data = x;
	s -> next = NULL;
	Q.rear -> next = s;  // 插入到队尾
	Q.rear = s;
}
```

#### 出队

```c
bool DeQueue(LinkQueue &Q, ElemType &x){
	if(Q.front == Q.rear) return false;
	LinkNode *p = Q.front -> next;  // 弹出一个头结点
	x = p -> data;
	Q.front -> next = p -> next;
	if (Q.rear == p)  // 弹出后队列为空，设置一下 Q.rear 位置
		Q.rear = Q.front;
	free(p);
	return true;
}
```

## 双端队列

双端队列是指允许**两端都可以进行入队和出队操作的队列**，其元素的**逻辑结构**仍是**线性结构**，将队列的两端分别称为**前端**和**后端**，两端都可以**入队**和**出队**

![u=3737484954,683032264&fm=26&fmt=auto&gp=0](..\images\u=3737484954,683032264&fm=26&fmt=auto&gp=0.webp)

在两端队列进队时，前端进的元素会在后端进的元素**前面**，后端进的元素会在前端进的元素**后面**；出队时**先出的元素排在后出的元素的前面**

例如：前端入 a 队中是 a，后端入 b 队中是 ab，前端入 c 队中是 cab；后端出队队中 ca 队外 b，后端再出队中 c 队外 `ba`，前端出队队外 `bac`

输出受限的双端队列：允许**在一端进行插入和删除**，但在**另一端只允许插入**的双端队列

输入受限的双端队列：允许**在一端进行插入和删除**，但在**另一端只允许删除**的双端队列

<img src="..\images\u=2992605034,2358148482&fm=26&fmt=auto&gp=0.webp" alt="u=2992605034,2358148482&fm=26&fmt=auto&gp=0" style="zoom:200%;" />

例子：如果有 1，2，3，4 四个数字，要令他输出 2，4，1，3 那么双向队列操作为：

1. 左入，内部 1，外部
2. 左入，内部 21，外部
3. 左出，内部 1，外部 2
4. 右入，内部 13，外部 2
5. 左入，内部 413，外部 2
6. 左出，内部 13，外部 24
7. 左出，内部 3，外部 241
8. 右出，内部，外部 2413

## 元素复用且空间可增的队列

请设计一个队列，要求满足（会做）：

1. 初始时队列为空
2. 入队时，允许增加队列占用空间
3. 出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减
4. 入队操作和出队操作的时间复杂度始终保持为 O(1)

设计出的队列：循环单链表，最好带头结点

因为队列是循环的，所以弹出元素不需要释放掉，等下次入队时重复利用，当队满时入队也可以分配结点链上去

队空条件：`front == rear`；队满条件：`front == rear -> next`

```c
// 入队
if (front == rear -> next)
    在 rear 后面插入一个新空结点;
入队元素保持到 rear 所致结点中;
rear = rear -> next;

// 出队
if (front == rear)
    则出队失败，return false;
取 front 所指结点中的元素 e;
front = front -> next;
return e;
```

# 栈和队列的应用

## 栈在括号匹配中的应用

假设表达式中允许包括两种括号：圆括号和方括号，其嵌套的顺序任意即 (\[\]\(\)) 或 [\([]\[]\)] 等均为正确格式，[(]) 或 ([()) 等均为不正确的格式，先需要设计一个算法来检验表达式是否是正确格式

分析如下：

检测所有括号是否匹配，就是检查每一个局部的括号是否匹配

只要我们匹配好每一个局部的括号，并把匹配好的括号去掉，继续向外匹配，那么就可以了

那么我们只需要用一个空间放左括号，然后那它与右括号匹配，匹配上了就可以了

而左括号很明显是最后看见的最先匹配，所以要用到栈，后进先出

算法思想：

1. 初始化设置一个栈
2. 如果是左括号压入栈，如果是右括号就和栈顶的括号匹配，匹配成功出栈继续，失败退出

## 栈在表达式求值中的应用

中序表达式 `A + B * (C - D) - E / F` 所对应的后缀表达式为 `ABCD-*+EF/-`，后缀表达式**没有括号**，它已经考虑了运算符的优先级，后缀表达式的**运算符在操作数后面**

通过后缀表示计算表达式值得过程为：

扫描表达式得每一项，根据它的类型做如下操作

1. 若是操作数，那么压入栈
2. 若是操作符 \<op> 则连续从栈弹出两个操作数 Y 和 X，做运算 X \<op> Y，并将运算结果压入栈中
3. 当表达式扫描完时，栈顶存放的就是最终结果

### 中缀转后缀的过程

| 操作符 | #    | (    | *, / | +, - | )    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| `isp`  | 0    | 1    | 5    | 3    | 6    |
| `icp`  | 0    | 6    | 4    | 2    | 1    |

其中 `isp` 是栈内优先数，`icp` 是栈外优先数，在表达式后面加上符号 '#' 表示表达式结束

扫描中缀表达式的没一项做以下操作：

1. 先把 '#' 入栈然后继续下面操作
2. 如果是操作数直接输出
3. 如果是操作符 op 分下面三种情况
   1. `isp(栈顶) < icp(op)` 把 op 进栈，下一个
   2. `isp(栈顶) == icp(op)` 把栈顶出栈输出，废弃 op，下一个
   3. `isp(栈顶) > icp(op)`，把栈顶出栈输出，重新判断 op
4. 读取到结束标识 '#' 结束

### 手工转缀（括号法）

示例表达式 `a / b + (c * d - e * f) / g`

1. 按照运算符优先级队所有的运算单位加括号，`((a / b) + (((c * d) - (e * f)) / g))`
2. 如果把每个操作符提到自己的括号前面就是前缀表达式：`+(/(ab)/(-(*(cd)*(ef))g))`=`+/ab/-*cd*efg`
3. 如果把每个操作符提到自己的括号后面就是后缀表达式：`((ab)/(((cd)*(ef)*)-g)/)+`=`ab/cd*ef*-g/+`

## 栈在递归中的应用

若在一个函数、过程或数据结构的定义中又**应用了它自身**，则这个函数、过程或数据结构称为是**递归定义的**

递归策略只需要少了的代码就可以描述出解题过程所需要的多次重复运算，大大**减少了程序的代码量**，但通常情况下，递归的**效率不是很高**

注意递归模型不能是死循环，必须满足两个条件：

* 队规表达式（**递归体**）
* 边界条件（**递归出口**）

递归过程中，系统会使**用栈**来存储返回点、局部变量、传参等，递归次数过多会造成**栈溢出**

有序递归过程中可能会包含很多**重复的运算**，这是其效率不高的原因

将递归算法转换为非递归算法，通常需要**借助栈来实现**

## 队列在层次遍历中的应用

在信息处理中有一大类问题需要**逐层**或**逐行处理**，需要等到**当前层或当前行处理完成**才会处理下一层或下一行

这时需要**使用队列保存下一步处理的顺序**，例如层次遍历二叉树过程：

1. 根节点入队
2. 队空即遍历完成，则结束遍历，否则进行第三步
3. 队列中第一个结点出队，若有左儿子，则左儿子入队；右儿子也一样，返回第二部

## 队列在计算机系统中的应用

队列在计算机系统中的应用非常广泛，下面仅从两个方面来简述队列在计算机系统中的作用：

* 解决主机与外部设备之间速度不匹配的问题

  主机输出数据的速度比打印机快很多，直接把数据全塞给打印机是不行的

  使用我们会在打印机设置一个**数据缓存区**，而这个缓存区是队列确保<u>输入和输出的数据位置一样</u>

  主机把数据写入这个缓冲区，写满就暂停做其他时，等打印机消化完数据再通知主机继续发送

* CPU 资源竞争问题

  再带多终端的计算机系统上，右多个用户需要 CPU 运行主机的程序，它们向操作系统提出占用 CPU 的请求

  操作系统按照每个请求的时间拍成一个队列，然后弹出运行相应的时间后再塞回队列，直到程序运行完

  这样既能满足每个用户的请求，又使 CPU 能够正常运行

# 数组和特殊矩阵

## 数组的定义

数组是由 n 个**相同类型**的数据元素构成的有限序列，每个数据元素称为一个数组元素，元素在 n 个线性关系中的**序号**称为该元素的**下标**，下标的**取值范围**称为数组的**维界**

**数组是线性表的推广**，一维数组可视为一个线性表；二位数组是视为元素是定长线性表的线性表

数组一旦被定义，其维数和维界就**不再改变**，除结构的初始化和销毁外，数组只会有**存取元素和修改元素**的操作

## 数组的存储结构

一个数组在内存中占用一段**连续的空间**，以一维数组 A[0...n - 1] 为例，存储结构关系为 $LOC(a_i)=LOC(a_0)+i\times L(0\leq i<n)$，其中 L 是每个数组元素所占的存储单元

对于多维数组，有两种映射方法：**按行优先和按列优先**，以二维数组为例：

* 按行优先：先行后列，先存储**行号较小的元素**，再**存储列较小的元素**，设行标和列标范围为 $[0,h_1]$ 和 $[0,h_2]$

  则它的存储结构关系式为 $LOC(a_{i,j})=LOC(a_{0,0})+[i\times(h_2+1)+j]\times L$

  ![image-20210914192829080](..\images\image-20210914192829080.png)

* 按列优先：先列后行，先存储**列号较小的元素**，再**存储行较小的元素**，设行标和列标范围为 $[0,h_1]$ 和 $[0,h_2]$

  则它的存储结构关系式为 $LOC(a_{i,j})=LOC(a_{0,0})+[j\times(h_1+1)+i]\times L$

  ![image-20210914192918205](..\images\image-20210914192918205.png)

## 矩阵的压缩存储

压缩存储：指**多个值相同的元素只分配一个存储空间**，**队零元素不分配存储空间**

特殊矩阵：指具有**许多相同矩阵元素或零元素**，并且这些矩阵元素分布有**一定的规律性**，通常有：对称矩阵、上（下）三角矩阵、对角矩阵等

特殊矩阵的压缩方法：找出特殊矩阵的分布规律，把那些规律性分布、值相同的**多个矩阵元素**压缩**存储到一个存储空间**

### 对称矩阵

对称矩阵是指对于任意一个矩阵内元素 $a_{i,j}$ 都有 $a_{i,j}=a_{j,i}$，其中元素可以分成 3 个部分，上三角区、主对角线、下三角区

对于 n 阶对称矩阵，上三角的元素和下三角的元素相同，如果使用二维数据存储会浪费空间，所有应该采用一维数组存储，**舍弃上三角的元素**，仅存储下三角的元素和主对角线元素

![image-20210914195830707](..\images\image-20210914195830707.png)

一维数组的大小应该是除主对角元素个数的一半再加上主对角元素的个数 $n(n-1)/2+n=n(n+1)/2$

在一维数组中，元素 $a_{i,j}(i\geq j)$ 前面元素的个数为：

1. 第 1 行：1 个元素
2. 第 i - 1 行：i - 1 个元素
3. 第 i 行：j - 1 个元素

所以元素 $a_{i,j}$ 在一维数组中的下标 $k = 1 + ... + (i - 1) + j - 1 = i(i - 1) / 2 + j - 1$（数组从 0 开始时）

而对称矩阵元素是对称的，对于 $a_{i,j}(i<j)$ 就是计算 $a_{j,i}$ 的位置

那么就得出**元素下标之间的对应关系**：$k=\left\{\begin{matrix}\dfrac{i(i-1)}{2}+j-1,&i\geq j（下三角区和主对角线元素）\\\dfrac{j(j-1)}{2}+i-1,&i<j（上三角区元素）\end{matrix}\right.$

注意：**如果数组下标从 1 开始的话，运算出来的结果要加 1**

注意：这里使用的是**行优先**来计算，如果是**列优先**的话可以**对称过来**当作行优先计算

### 三角矩阵

<img src="..\images\image-20210914201508777.png" alt="image-20210914201508777" style="zoom:200%;" />

#### 下三角矩阵

下三角矩阵中，**上三角区域**的所有元素均为**同一常量**，使用**一个位置**来存储就好了，设置在**数组最后**

因此我们只需要存储下**三角元素**和**主对角元素**以及**额外常量**，大小为 $n(n+1)/2+1$

当 i < j 时，取上三角元素，就访问数组的最后一个元素 $n(n+1)/2$ 拿到常量就好了

当 $i\geq j$ 时，取下三角元素，这里的计算思路和对称矩阵的一样，结果是 $i(i-1)/2+j-1$

#### 上三角矩阵

上三角矩阵中，**下三角区域**的所有元素均为**同一常量**，也是使用数组最后的元素来存储，数组大小和上三角矩阵一样

与下三角不同这里第 1 行是有 n 个元素的，所以不能套用对称矩阵的公式

在一维数组中，元素 $a_{i,j}(i\leq j)$ 前面元素的个数为：

1. 第 1 行：1 个元素
2. 第 i - 1 行：n - i + 2 个元素
3. 第 i 行：j - i 个元素

所以元素 $a_{i,j}$ 在一维数组中的下标 $k=n+(n-1)+\cdots+(n-i+2)+j-i=(i-1)(2n-i+2)/2+(j-i)$

那么就得出**元素下标之间的对应关系**：$k=\left\{\begin{matrix}\dfrac{(i-1)(2n-i+2)}{2}+(j-i),&i\leq j（上三角区和主对角线元素）\\\dfrac{n(n+1)}{2},&i>j（下三角区元素）\end{matrix}\right.$

注意：**如果数组下标从 1 开始的话，运算出来的结果要加 1**

注意：这里使用的是**行优先**来计算。<u>上三角的列优先和下三角的行优先类似</u>；<u>下三角的列优先于上三角行优先类似</u>

### 三对角矩阵

三对角矩阵也称带状矩阵，对于 n 阶矩阵的任意元素 $a_{i,j}$ 当 |i - j| > 1时，有 $a_{i,j}=0$

三对角矩阵的所有**非零元素**都集中在以主对角线为中心的 3 条对角线区域，**其余区域元素都为零**

![image-20210914202417969](..\images\image-20210914202417969.png)

对三角矩阵采用压缩存储，按行优先方式存储放在一维数组中，数组长度为 `3n - 2`

元素在一维数组的下标计算为：第一行的个数 + 前面三个元素的行数 + 当前行前面的元素

即元素 $a_{i,j}$ 的下标 $k=2+3(i-2)+(j-i+1)=2i+j-3$

注意：**如果数组下标从 1 开始的话，运算出来的结果要加 1**

注意：这里使用的是**行优先**来计算。不过列优先和行优先差不多

## 稀疏矩阵

矩阵中非零的元素的个数对于矩阵元素的个数来说非常少，如 $100 \times 100$ 的矩阵只有不到 100 的非零元素

如果采用常规法来存储就很浪费空间了，所以将非零元素及其相应的行和列构成一个三元组（**行标、列标、值**）

![image-20210914203617205](..\images\image-20210914203617205.png)

稀疏矩阵的**三元组**既可以采用**数组存储**，也可以采用**十字链表法**存储

